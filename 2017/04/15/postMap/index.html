<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/data-structure/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/data-structure/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/data-structure/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="data structure," />








  <link rel="shortcut icon" type="image/x-icon" href="/data-structure/favicon.ico?v=5.1.0" />






<meta name="description" content="MapIntroductionMap是很常用的一种数据结构。在了解map之前，我们需要了解一点Set。set就是集合，是一种更加偏向数学抽象概念的结构。对于set的实现是多种多样的，但是基本概念是共通的。对于集合来说，所有元素的种类应该是相同的。在大部分语言中对于set的实现应当是类似的，但是也取决于具体实现的类型。比如java和python之中，set是不包含重复元素的。Set的基本逻辑操作有几">
<meta property="og:type" content="article">
<meta property="og:title" content="第4天的Map">
<meta property="og:url" content="https://alex-mengx.github.io/2017/04/15/postMap/index.html">
<meta property="og:site_name" content="Alex's data structure class">
<meta property="og:description" content="MapIntroductionMap是很常用的一种数据结构。在了解map之前，我们需要了解一点Set。set就是集合，是一种更加偏向数学抽象概念的结构。对于set的实现是多种多样的，但是基本概念是共通的。对于集合来说，所有元素的种类应该是相同的。在大部分语言中对于set的实现应当是类似的，但是也取决于具体实现的类型。比如java和python之中，set是不包含重复元素的。Set的基本逻辑操作有几">
<meta property="og:updated_time" content="2017-05-07T05:22:17.384Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第4天的Map">
<meta name="twitter:description" content="MapIntroductionMap是很常用的一种数据结构。在了解map之前，我们需要了解一点Set。set就是集合，是一种更加偏向数学抽象概念的结构。对于set的实现是多种多样的，但是基本概念是共通的。对于集合来说，所有元素的种类应该是相同的。在大部分语言中对于set的实现应当是类似的，但是也取决于具体实现的类型。比如java和python之中，set是不包含重复元素的。Set的基本逻辑操作有几">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/data-structure/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://alex-mengx.github.io/2017/04/15/postMap/"/>





  <title> 第4天的Map | Alex's data structure class </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/data-structure/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Alex's data structure class</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/data-structure/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/data-structure/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/data-structure/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://alex-mengx.github.io/data-structure/2017/04/15/postMap/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="弦子">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/data-structure/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Alex's data structure class">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Alex's data structure class" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                第4天的Map
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-15T11:08:49-04:00">
                2017-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Map是很常用的一种数据结构。在了解map之前，我们需要了解一点Set。set就是集合，是一种更加偏向数学抽象概念的结构。对于set的实现是多种多样的，但是基本概念是共通的。对于集合来说，所有元素的种类应该是相同的。在大部分语言中对于set的实现应当是类似的，但是也取决于具体实现的类型。比如java和python之中，set是不包含重复元素的。<br>Set的基本逻辑操作有几种，我们只列举两个例子：</p>
<ol>
<li>取交集。两个集合，交集就是一个新的集合，它包括了两个集合中的全部元素，但是没有重复。</li>
<li>取并集。两个集合，并集也是一个新的集合，包含了两个集合之中共同的元素。</li>
</ol>
<p>对于map来讲，map就是set的一种稍微具体一点的抽象形式。我们知道set之中是一类元素，而map可以包含的元素有着特定的结构。我们想将一个元素放入map，那这个元素就需要是<code>&lt;key-value&gt;</code>的形式才可以。熟悉数据库的小伙伴可能会对于这种形式更加熟悉一点。今天我们就通过讲解key value，hash的概念来实现一个简单的hashmap。</p>
<h2 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h2><p>key value 的概念其实很好理解。就像是有编码的柜子，我们放入物品的时候就会记住我们的东西放进了几号柜子。这种情况下，柜子的号码就是key，放入的物品就是value。所以实际上，key就是便于查找的位置索引，value则是要存入的数据。数据库中需要提供主键也是这个原因，索引会大大提高查询的效率。想象一下，你知道你的东西在某个柜子里，然而柜子的存储是无序的。那么你需要遍历全部的柜子才能找到你的东西。但是，当你有了柜子的号码，你不需要任何搜索，只要打开对应的柜子门，就可以取出物品。于是取出的时间从O(n)变成了O(1)。在map中，一对key value 叫做一个entry。我们来实现这个entry。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Entry &#123;</div><div class="line">    K key;</div><div class="line">    V value;</div><div class="line">    int hashcode;</div><div class="line"></div><div class="line">    public Entry(K key, V value) &#123;</div><div class="line">        this.key = key;</div><div class="line">        this.value = value;</div><div class="line">        this.hashcode = hashFunction(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final K getKey() &#123;</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final V getValue() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public final String toString() &#123;</div><div class="line">        return key + &quot;=&quot; + value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是我们的map中的最小存储单位啦。就像链表中的节点Node一样，map中的每个元素都在一个Entry之中。在这个entry class中，我们有key，有value，但是我们还多出了一个hashcode。这是什么呢？</p>
<h2 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h2><p>哈希值，是元素的指纹。我们都知道，人的指纹是独一无二的，很少有两个人的指纹是一样的。哈希值也是如此，我们希望所有的元素的哈希值都是独一无二的。在讲解哈希值之前，我们先来了解一下hashmap的原理。依旧用柜子来举例吧。现在我们来到了一家商场，这个商场有存包的柜子。于是我们怎么做？找到一个空的柜子，锁上，然后记住柜门的编号。这样我们来取包裹的时候，只需要找到这个编号的柜子，就能拿到我们想要的东西。<br>现在，问题变得复杂了一些，假设我们有很多包裹，我们该怎么存呢？如果我们采用了同样的策略，对于每一个包裹，我们都找到一个空的柜子，然后放入包裹，那么当我们需要找到某个包裹的时候，我们该怎么办？因为包裹的数量很多，我们可以用一个表来记录哪个包裹存在了哪个柜子里。假设我们在存包的同时保存了一张表，上面记录着柜子编号和保存的包裹。这样当我们需要找某一个包裹的时候，我们就可以从表上找到这个包裹，然后查询对应的柜子的编号。但是这样做的缺点是什么呢？当包裹数量很多的时候，从表中找到某个包裹所花费的时间会很多。我们对于算法的时间复杂度已经有了一些初步的了解，所以我们知道，在N个无序的元素中找到某个特定元素的时间复杂度是O(n)。如果每次取出或者查找的时间都是O(N)，那么map的耗时跟无序链表就一样了，同样的O(1) 插入，O(n)查找和取出。那么我们该怎样改善我们存包裹的方法呢？<br>这个问题的关键是如何记录包裹所对应的柜子的编号。如果包裹自身的天然特性就包含了某种编号，这个问题就解决了。假设我们的包裹是已经有自己的编号的，那么我们存包的时候只需要保证一个原则，既柜子编号和包裹编号是一致的，那么当我们想要找某个编号为x包裹，我们就可以直接去x号柜子。<br>但是更进一步的问题是，很多时候要存储的目标元素没有这种天然的编号，我们又不能人为编号，否侧查找编号和包裹对应的过程同样要花费O(n)的时间。这种时候，我们就需要一个方法，这个方法接受一个包裹，然后针对这个包裹计算出只属于这个包裹的特定值，并且对于同一个包裹每次计算的结果都是一致的，那么我们就可以用这个方法来计算对应的柜子编号。这个方法就是hash function，也叫哈希函数。<br>一个比较具体的例子就是电话本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 假设我们有个函数，这个函数接受人的名字，并且把名字的首字母转换成0-25的数字，这就是一个很好的哈希函数。</div><div class="line"></div><div class="line">&quot;Alex&quot;                                      0</div><div class="line">&quot;Bailey&quot;                                    1</div><div class="line">&quot;Claire&quot;        -&gt;  Hash Function  -&gt;       2</div><div class="line">&quot;Dominic&quot;                                   3</div><div class="line">&quot;Elsa&quot;                                      4</div><div class="line"></div><div class="line">// 名字就有了自然的编号，而且无论重复计算多少次，同一个名字的哈希值也不会变化。</div><div class="line"></div><div class="line">String[] nameTable</div><div class="line"></div><div class="line">nameTable[hashFunction(&quot;Alex&quot;)] = &quot;Alex&quot;</div><div class="line"></div><div class="line">//通过哈希值计算，我们为“Alex”这个名字找到了对应的数组位置。</div></pre></td></tr></table></figure></p>
<h2 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h2><p>哈希值的用法我们已经很清楚了，但是如果当两个元素的哈希值一致，我们该怎么办呢？<br>比如上面的例子，当我们有“Alex”的同时，还有“Arturia”，那么这两个名字就会拥有同样的哈希值。这种情况就叫做碰撞。碰撞是无法完全避免的，我们只能通过调整hash function来尽量减少碰撞。在hashmap中，我们也有别的方法来解决碰撞，稍后会讲到。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>了解了key value和哈希值之后，我们已经做好了实现hashmap的准备。我们再来回顾一下几个要点：</p>
<ol>
<li>entry来存储key value，key是value的某个天然的特征。</li>
<li>hashmap实际上是个数组，我们通过hash function来计算某个key的hash值，来计算这个key value应当被放入的位置</li>
<li>对于这个hashmap的数组，如果我们直接放入Entry，那么碰撞产生的时候我们就无法在同一个位置存储两个entry。所以相对的，我们建立一个List数组，如果哈希值一致，那么我们就放在数组对应位置的List里。每一个list就像是一个篮子，同样哈希值的key就会在同一个篮子里。</li>
<li>我们需要设定一个阈值。因为哈希计算出的值在数组中所对应的篮子不一定是空的。我们想要尽量避免在同一个篮子里放入太多元素。所以当数组中非空的篮子太多，我们就要增加数组的长度。</li>
</ol>
<p>我们来看具体实现吧。总的来说常见的操作就是增删改查，但是对于map来说，因为map属于set的一种具体实现，所以map中没有重复的key，所以在放入同样的key - 无论 value是否相同 - 旧的key value都会被覆盖。因此，我们就不需要实现修改了，因为放入的过程可以等同于修改。先写出框架：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class HashMap&lt;K, V&gt; &#123;</div><div class="line"></div><div class="line">    public class Entry &#123;</div><div class="line">        private K key;</div><div class="line">        private V value;</div><div class="line">        private int hashcode; // 通过hash function 计算出的哈希值，在这里这个哈希值是当前entry在数组中所在的位置。</div><div class="line"></div><div class="line">        public Entry(K key, V value) &#123;</div><div class="line">            this.key = key;</div><div class="line">            this.value = value;</div><div class="line">            this.hashcode = hashFunction(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public final K getKey() &#123;</div><div class="line">            return key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public final V getValue() &#123;</div><div class="line">            return value;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        final int getHashcode() &#123;</div><div class="line">            return hashcode;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public final String toString() &#123;</div><div class="line">            return key + &quot; = &quot; + value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private LinkedList&lt;Entry&gt;[] table; // 这就是我们的table了。所有的key value 都会被放入这个table。</div><div class="line">    private int capacity = defaultCap; // 因为table是数组，我们需要知道数组的长度。这个值会记录数组的长度。</div><div class="line">    private double tableSize = 0; // 这个值是数组中不为null的list的数量，我们用这个值判断是否需要增加数组长度</div><div class="line">    private int size; // 目前table里面元素的数量，这里是entry的数量，不是list的数量。</div><div class="line">    private static final double resizeRatio = 0.5; // 阈值。table中有一半的位置被使用了，则增加长度。</div><div class="line">    private static final int defaultCap = 32; // 初始长度，2^5 大小。</div><div class="line"></div><div class="line">    public int size() &#123;&#125; // 返回当前entry的数量</div><div class="line"></div><div class="line">    public boolean isEmpty() &#123;&#125; // 返回当前map是否为空</div><div class="line"></div><div class="line">    public boolean containsKey(K key) &#123;&#125; // 如果map中有这个key，返回true，反之亦然</div><div class="line"></div><div class="line">    public V get(K key) &#123;&#125; // 给出key，返回key对应的value</div><div class="line"></div><div class="line">    public void put(K key, V value) &#123;&#125; // 放入一对key value</div><div class="line"></div><div class="line">    public boolean remove(K key) &#123;&#125; // 删除某个key，同时也会删除key对应的value</div><div class="line"></div><div class="line">    private int hashFunction(K key) &#123;&#125;// 计算哈希值的方法。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>下面就是map的具体实现了。我们一项一项的来。</p>
<h3 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private int hashFunction(K key) &#123;</div><div class="line">    return key.hashCode() &amp; (capacity - 1); //这是个小技巧。也是为什么我们选择2^n来作为数组的长度。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>哈希值计算方法。这个方法很简单，但是很实用。 具体来说就是用key object自带的hashcode方法，对数组的长度取模 （取余数）。hashcode是java Object类自带的一个方法，具体实现取决于继承自Object的类。对capacity取模则可以把key放置在我们的数组的范围之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">解释一下为什么取模可以用&amp;操作。对于十进制，如果我们取模的数字是10：</div><div class="line">1234 % 10 = 4</div><div class="line">5678 % 10 = 8</div><div class="line"></div><div class="line">很明显，对10取模，等于只保留该数字的各位。再来看二进制。我们对2取模：</div><div class="line">1 % 2 -&gt; 0001 % 2 = 0001</div><div class="line">2 % 2 -&gt; 0010 % 2 = 0000</div><div class="line">3 % 2 -&gt; 0011 % 2 = 0001</div><div class="line"></div><div class="line">一样的道理，只要保留二进制的最后一位，就是取模的结果。那么，当数组的长度是2^n时：</div><div class="line">假设对8取模</div><div class="line">9 % 8  -&gt; 1001 % 1000 = 0001</div><div class="line">10 % 8 -&gt; 1010 % 1000 = 0010</div><div class="line">11 % 8 -&gt; 1011 % 1000 = 0011</div><div class="line"></div><div class="line">找到规律了吧，对于2^n 取模，等于 &amp; (2^n -1) 操作。这个操作比 % 操作要快得多得多得多。</div></pre></td></tr></table></figure></p>
<h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><p>放入一对key value。这个方法比别的操作稍微复杂一点。在每次放入之前，我们需要查看当前数组中空的篮子和总长度的比值是否大于我们设定的阈值。我们设定的值为0.5，也就是说空的篮子占数组总长的一半以下，则我们直接放入。如果空位过少，我们直接加倍数组的长度。数组中空位越多，则元素被放入同一个篮子的概率就越小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public void put(K key, V value) &#123;</div><div class="line">    if (tableSize / capacity &gt; resizeRatio) // 如果空位少于一半，我们增加数组长度</div><div class="line">        resize();</div><div class="line">    remove(key); // 这里是一个偷懒的小方法。因为map中不能存在同样的key，所以在放入新的key的时候，如果这个key已经存在，新的值将会覆盖旧的值。</div><div class="line">    Entry e = new Entry(key, value);</div><div class="line">    if (table[e.hashcode] == null)&#123; // 如果篮子是空的</div><div class="line">        table[e.hashcode] = new LinkedList&lt;Entry&gt;();</div><div class="line">        tableSize++; // 这里我们记录目前数组之中list的个数</div><div class="line">    &#125;</div><div class="line">    table[e.getHashcode()].add(e); // 在对应的篮子中放入key value</div><div class="line"></div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void resize() &#123;</div><div class="line">    capacity = capacity * 2;  // 我们的数组长度一直是2^n。这样可以提高hash function的运行效率</div><div class="line">    tableSize = 0; //tableSize set to 0， 因为重新hash的话位置会改变</div><div class="line"></div><div class="line">    LinkedList&lt;Entry&gt;[] array = new LinkedList[capacity]; // 新建一个数组</div><div class="line">    for (LinkedList&lt;Entry&gt; l : table)&#123;</div><div class="line">            if (l != null)&#123;</div><div class="line">                for (Entry e : l)&#123;</div><div class="line">                    e.hashcode = hashFunction(e.key);</div><div class="line">                    if (array[e.hashcode] == null) &#123;</div><div class="line">                        array[e.hashcode] = new LinkedList&lt;Entry&gt;();</div><div class="line">                        tableSize++;</div><div class="line">                    &#125;</div><div class="line">                    array[e.hashcode].add(e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    // 新建的数组为空。</div><div class="line">    // 这里是两层循环。对于每个篮子：</div><div class="line">        遍历这个篮子，对于每个entry: </div><div class="line">            我们需要重新计算hashcode，因为数组的capacity产生了变化，所以hash function 的结果也会变化。然后根据新的hashcode，把这个entry放入新建的数组中</div><div class="line"></div><div class="line">    this.table = array; // 让我们的table指向新建的数组</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>放入的逻辑其实比较简单：</p>
<ol>
<li>判断是否需要新建一个大一些的数组。</li>
<li>根据key计算hashcode</li>
<li>根据hashcode找到对应的篮子，如果篮子为空，新建List</li>
<li>放入key value。</li>
</ol>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找。逻辑很简单，也是根据key找对应的篮子，然后在篮子里找对应的元素。这里要注意的就是几个null判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean containsKey(K key) &#123;</div><div class="line">    int hashcode = hashFunction(key);</div><div class="line">    if (hashcode &gt;= table.length || size &lt;= 0)</div><div class="line">        return false;</div><div class="line">    LinkedList&lt;Entry&gt; list = table[hashcode];</div><div class="line">    if (list == null)</div><div class="line">        return false;</div><div class="line">    return list.stream().filter(e -&gt; key.equals(e.getKey())).count() &gt; 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要注意的几点：</p>
<ol>
<li>判断hashcode是否在array的长度之内。</li>
<li>判断array中查找的key对应的的篮子是否为null</li>
<li>在篮子中找对应的key</li>
</ol>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>删除的逻辑跟查找是类似的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean remove(K key) &#123;</div><div class="line">    int hashcode = hashFunction(key);</div><div class="line">    if (hashcode &gt;= table.length || size &lt;= 0)</div><div class="line">        return false;</div><div class="line">    LinkedList&lt;Entry&gt; list = table[hashcode];</div><div class="line">    if (list == null)</div><div class="line">        return false;</div><div class="line">    list.removeIf(entry -&gt; entry.getKey().equals(key));</div><div class="line">    if(list.isEmpty())&#123;</div><div class="line">        tableSize--;</div><div class="line">        table[hashcode] = null;</div><div class="line">    &#125;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断的方式也差不多。</p>
<ol>
<li>判断hashcode是否在array的长度之内。</li>
<li>判断array中key对应的的篮子是否为null</li>
<li>如果篮子在，则在篮子中删除目标key</li>
<li>如果篮子空了，那么我们需要把这个篮子整个去除，数组的这个位置变为null，而不是一个空的list。这是为了方便判断空篮子的比例。</li>
</ol>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>这个方法和查找 containsKey() 是一样的，只不过这个方法返回了查找key对应的value。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public V get(K key) &#123;</div><div class="line">    int hashcode = hashFunction(key);</div><div class="line">    if (hashcode &gt;= table.length || size &lt;= 0)</div><div class="line">        return null;</div><div class="line">    LinkedList&lt;Entry&gt; list = table[hashcode];</div><div class="line">    if (list == null)</div><div class="line">        return null;</div><div class="line">    return list.stream().filter(e -&gt; key.equals(e.getKey())).map(e -&gt; e.getValue()).findFirst().orElse(null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样判断是否为null，直到找到目标篮子，然后在篮子里找到目标key，返回对应的value。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们了解了HashMap的概念和，了解了key value 存储和hash function的工作原理。我们也自己动手实现了一个简易版的Hashmap。这个hashmap的优点很多，最大的优点就是，它所有的增删改查方法的时间复杂度都是O(1)。原因是因为，map内部的结构是一个数组，而对于某个key我们计算hashcode的方法不受N的影响，所以无论map里有多少元素，从key到具体篮子的过程耗时都是一个常数。有的小伙伴可能有疑惑：可是再插入N个元素的过程中，当n/2个元素被插入之后，我们会新建一个数组，然后复制所有的元素到新的数组，这样岂不是遍历了一遍，这一次的插入不就是O(N)吗？确实，这一次的插入是O(n)，但是平均到每一次，就是O(1)了。如果我们把这个过程写成等式，我们来看一下插入N的元素的耗时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">T(N) = T(1) * n/2 + T(n/2) + T(1) * n/2 = nT(1) + T(n/2) </div><div class="line">这个递归的时间我们已经很熟悉了：T(n/2) = T(1) * n/4 + T(n/4) + T(1) * n/4</div><div class="line">所以：</div><div class="line">T(N) = (1 + 1/2 + 1/4 + 1/8 + ....) * T(1) 且 1+ 1/2 + 1/4 + ... 收敛。</div><div class="line">因为(1/2)^n数列求和在n趋近于无穷时等于1，所以数列1 + 1/2 + 1/4 + 1/8 + .... =&gt; 2</div><div class="line"></div><div class="line">=&gt; T(N) N趋近于无穷 = 2n*T(1)</div><div class="line">=&gt; 对于N个元素插入操作的总耗时为2n*T(1)，则单个元素的插入耗时为2T(1)</div><div class="line">=&gt; HashMap 的插入时间复杂度为O(1)</div></pre></td></tr></table></figure></p>
<p>照旧附上了代码，里面有额外实现的一些方法，感兴趣的小伙伴可以下载并运行。<br><br>HashMap的简单实现<br><br>
<button onclick="window.open('HashMap.java')">点我下载 HashMap.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/data-structure/tags/data-structure/" rel="tag"># data structure</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/data-structure/2017/04/02/postAlgorithmAnalysisPrologue/" rel="next" title="第4天的算法分析">
                <i class="fa fa-chevron-left"></i> 第4天的算法分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/data-structure/2017/04/22/postMutex/" rel="prev" title="第1天的多线程">
                第1天的多线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/data-structure/avatar.jpg"
               alt="弦子" />
          <p class="site-author-name" itemprop="name">弦子</p>
          <p class="site-description motion-element" itemprop="description">I pledge my life and honor to the Programming, for this night and all the nights to come.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/data-structure/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/data-structure/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-number">1.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key-value"><span class="nav-number">1.2.</span> <span class="nav-text">key-value</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashcode"><span class="nav-number">1.3.</span> <span class="nav-text">Hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#碰撞"><span class="nav-number">1.4.</span> <span class="nav-text">碰撞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">1.5.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation"><span class="nav-number">1.6.</span> <span class="nav-text">Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-function"><span class="nav-number">1.6.1.</span> <span class="nav-text">Hash function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Put"><span class="nav-number">1.6.2.</span> <span class="nav-text">Put</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find"><span class="nav-number">1.6.3.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove"><span class="nav-number">1.6.4.</span> <span class="nav-text">remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get"><span class="nav-number">1.6.5.</span> <span class="nav-text">get</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">1.7.</span> <span class="nav-text">Conclusion</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">弦子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/data-structure/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/data-structure/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/data-structure/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/data-structure/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/data-structure/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/data-structure/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/data-structure/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/data-structure/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/data-structure/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/data-structure/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/data-structure/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
