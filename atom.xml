<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alex&#39;s data structure class</title>
  
  <link href="/data-structure/atom.xml" rel="self"/>
  
  <link href="https://alex-mengx.github.io/"/>
  <updated>2017-05-13T04:36:07.096Z</updated>
  <id>https://alex-mengx.github.io/</id>
  
  <author>
    <name>弦子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第2天的Java Lambda</title>
    <link href="https://alex-mengx.github.io/2017/05/12/postLambda/"/>
    <id>https://alex-mengx.github.io/2017/05/12/postLambda/</id>
    <published>2017-05-12T16:33:05.000Z</published>
    <updated>2017-05-13T04:36:07.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>Lambda其实并不复杂。它只是一个函数而已。今天我们来看看lambda的使用。我们会尝试几个简单的例子，然后尝试建立一个新的lambda接口，最后在试着在实际使用中熟悉它。</p>
<h2 id="Lambda-Types"><a href="#Lambda-Types" class="headerlink" title="Lambda Types"></a>Lambda Types</h2><p>是的，java中的lambda是有类型的。跟JS的区别在于，JS中的lambda是一个自定义函数，这个函数是可以动态定义的，也就是说你不需要提前定义任何的格式或者类型。但是在java中，lambda这个函数实际上也是一个Object，所以需要类型支持。虽然一般在代码里看不到，但是它是存在的。我们来看看自带的几种不同类型的lambda。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer是一个接受单个参数且没有返回值的函数。<br>Consumer的语法是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">数据 -&gt; &#123;</div><div class="line">    处理数据</div><div class="line">    &#125;；</div></pre></td></tr></table></figure></p>
<p>我们来看个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Integer&gt; consumInteger = i -&gt; System.out.println(i); // 如果只有一行代码，&#123;&#125;可以省略。类似于if语句的&#123;&#125;只有一行代码可以省略。</div><div class="line"></div><div class="line">public static void main(final String[] args) &#123;</div><div class="line">        consumInteger.accept(19);</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">19</div><div class="line"></div><div class="line">实际上，这个Consumer在逻辑上等同于：</div><div class="line">consumInteger(Integer i) &#123;</div><div class="line">    System.out.println(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">当然Java的内部实现跟方法是不同的，我们后面会看到。</div></pre></td></tr></table></figure></p>
<p>这就是一个很简单的Consumer。它接受一个integer，然后打印出来。</p>
<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>顾名思义，跟Consumer正好相反，这个函数不接受参数，相对的，它返回一个参数。有同学可能会疑问，为什么我们需要supplier，其实不要把它当作一个小函数，它可以成为一个子系统的对外的接口。来看语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123;</div><div class="line">    生成数据；</div><div class="line">    return 数据；</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>跟Consumer不同，我们看到这个函数不接受参数，而且有返回语句。来看个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Double&gt; supplyRand = () -&gt; Math.random(); // 这里的return省略了，因为只有一行代码，箭头可以直接指向返回的数据。</div><div class="line"></div><div class="line">public static void main(final String[] args) &#123;</div><div class="line">        System.out.println(supplyRand.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">0.3155123546019203</div></pre></td></tr></table></figure></p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>这也是一个常用的函数。这个函数接受一个数据，返回一个true false值。这个函数常用来判断条件，比如输入的值是否满足特定的条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">i -&gt; &#123;</div><div class="line">    boolean testResult =测试数据的结果</div><div class="line">    return testResult;</div><div class="line">&#125;</div><div class="line"></div><div class="line">来看个例子：</div><div class="line">Predicate&lt;Integer&gt; predicate = i -&gt; i % 3 == 0;</div><div class="line"></div><div class="line">public static void main(final String[] args) &#123;</div><div class="line">        System.out.println(predicate.test(19));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">false</div><div class="line">显然，19不能被3整除，所以返回的结果是false。</div></pre></td></tr></table></figure></p>
<h3 id="BiConsumer"><a href="#BiConsumer" class="headerlink" title="BiConsumer"></a>BiConsumer</h3><p>这个函数在使用hashmap的时候会很常见。这个函数跟consumer的区别就是它接受两个参数。<br>格式很类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(数据1, 数据2) -&gt; &#123;</div><div class="line">    处理两个参数；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来看个例子，这个例子里面函数将会接受两个String，并且按条件打印其中一个或者两个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">BiConsumer&lt;String, String&gt; consumerStrings = (str1, str2) -&gt; &#123;</div><div class="line">        if (str1.equalsIgnoreCase(str2))</div><div class="line">            System.out.println(str1);</div><div class="line">        else System.out.println(str1 + str2);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">public static void main(final String[] args) &#123;</div><div class="line">        consumerStrings.accept(&quot;string&quot;, &quot;String&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">string</div><div class="line">因为两个字符串一致，所以输出第一个字符串。</div></pre></td></tr></table></figure></p>
<h2 id="Why-Lambda"><a href="#Why-Lambda" class="headerlink" title="Why Lambda"></a>Why Lambda</h2><p>既然我们可以用方法来完成函数可以完成的事情，那我们为什么还需要函数呢？因为有时候我们需要延迟运行，或者在系统内需要动态的切换一些功能。同时，函数可以帮助减少代码数量，同时不损伤太多的可读性。</p>
<h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    Integer[] array = &#123; 2, 8, 4, 6, 3, 7 &#125;;</div><div class="line">    Arrays.sort(array, new Comparator&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public int compare(Integer i1, Integer i2) &#123;</div><div class="line"></div><div class="line">            return i1 - i2;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    System.out.println(Arrays.asList(array));</div><div class="line"></div><div class="line">输出：</div><div class="line">[2, 3, 4, 6, 7, 8]</div><div class="line"></div><div class="line">因为sort方法本身不知道如何处理一个包含了object的数组，所以我们需要告诉sort这个方法，</div><div class="line">如何比较两个Object，它才能帮助我们排序。</div><div class="line"></div><div class="line">简便一点的做法：</div><div class="line">    Integer[] array = &#123; 2, 8, 4, 6, 3, 7 &#125;;</div><div class="line">    Arrays.sort(array, (i1, i2) -&gt; i1 - i2);</div><div class="line"></div><div class="line">    System.out.println(Arrays.asList(array));</div><div class="line"></div><div class="line">输出：</div><div class="line">[2, 3, 4, 6, 7, 8]</div></pre></td></tr></table></figure>
<p>lambda最大的优势就是可以不仅仅传递数据，还可以传递行为。这里我们用lambda传递了如何比较两个元素的函数，sort就可以排序了。</p>
<h2 id="Typical-Usage"><a href="#Typical-Usage" class="headerlink" title="Typical Usage"></a>Typical Usage</h2><p>在java8中有很多自带的方法接受lambda，这使得很多操作变得很简便。我们来看一下Collection.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    Integer[] array = &#123; 2, 30, 2, 6, 56, 34, 12, 7, 26, 8, 48 &#125;;</div><div class="line">    List&lt;Integer&gt; list = Arrays.asList(array);</div><div class="line"></div><div class="line">    List&lt;Integer&gt; list2 = list.stream().filter(predicate).collect(Collectors.toList());</div><div class="line">    System.out.println(list2);</div><div class="line"></div><div class="line">输出：</div><div class="line">[30, 6, 12, 48]</div></pre></td></tr></table></figure></p>
<p>我们用了之前的Predicate里面我们定义的函数<code>Predicate&lt;Integer&gt; predicate = i -&gt; i % 3 == 0;</code>, 并且我们将数组转化成了stream。stream有很多很好用的方法，很多返回stream自身，所以可以一串的调用过去。这里我们使用了filter方法，这个方法接受一个Predicate函数，所以如果你有一个Collection需要选出一些特定的元素的话，filter是你的好朋友。所以我们看到，根据这个过滤器，我们过滤掉了所有不能被3整除的数字。后面的collect是另一个方法，它会将stream收集起来根据收集器的类型来返回对应的形式。在这里我们用了toList，所以我们获得了一个List。<code>Collectors</code>里面有很多的收集器和其他的函数，包括stream中的平均值，最大值，最小值以及按照某种特性分成不同的组等等。<br>我们再来看一个稍微复杂一点点的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    Integer[] array = &#123; 2, 30, 11, 6, 56, 34, 12, 7, 26, 8, 48 &#125;;</div><div class="line">    List&lt;Integer&gt; list = Arrays.asList(array);</div><div class="line"></div><div class="line">    Map&lt;String, List&lt;Integer&gt;&gt; map = list.stream()</div><div class="line">            .collect(Collectors.groupingBy(i -&gt; i - i % 10 + &quot;&quot;, Collectors.toList()));</div><div class="line"></div><div class="line">    map.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue().toString()));</div><div class="line"></div><div class="line">输出：</div><div class="line">0: [2, 6, 7, 8]</div><div class="line">50: [56]</div><div class="line">40: [48]</div><div class="line">30: [30, 34]</div><div class="line">20: [26]</div><div class="line">10: [11, 12]</div></pre></td></tr></table></figure></p>
<p>看起来可能有点复杂，但是逻辑说起来就不复杂了。重点在于这一行<code>list.stream().collect(Collectors.groupingBy(i -&gt; i - i % 10 + &quot;&quot;, Collectors.toList()));</code>。 首先数组被转化成了stream，然后直接调用了collect方法。方法里面我们传递了一个函数。这一个函数是个groupingbBy的收集器，这个收集器会对于每一个元素进行一个转化，方式就是我们lambda中规定的，假设是数字48，计算的结果就是48 - 48%10 = 40，然后加上空字符串，转化成了“40”字符串。转化后的字符串会被当做key放入一个map，然后将元素放入这个key对应的value中。从前面的定义我们可以看到，<code>Map&lt;String, List&lt;Integer&gt;&gt;</code>，就是说，对于每个数字，我们根据数字来计算一个字符串，这个字符串是这个数字所在的10位数区间，然后将同区间内的数字放入同一个list里面。<br>比较复杂的操作，在使用了lambda之后变得如此的简单明了，只要了解了函数的概念，自带的函数会帮你解决很多需要写好几行甚至几十行代码才可以解决的问题。</p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>除了java自带的函数，如果我们需要别的函数该怎么办呢？实际上，由于函数本身其实也是Object， 所以java中我们可以自定义一个interface接口来定义新的函数格式。我们先来看个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">interface TriFunction&lt;T&gt; &#123;</div><div class="line">    public T Operation(T t1, T t2, T t3);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>非常简单的一个interface。但是由于这个interface，我们就可以建立一种新的匿名函数了。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TriFunction&lt;Integer&gt; max = (i1, i2, i3) -&gt; Math.max(Math.max(i1, i2), i3);</div></pre></td></tr></table></figure></p>
<p>这个函数返回三个数字中的最大值。这里主要是为了说明，lambda自身在java中也是对象，所以不像JS一样可以任意创建新的函数。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们主要讲了Java自带的几种lambda函数类型，也看了几个简单的例子，希望大家在工作中可以尝试使用这些新的方法来解决问题，让代码变得简洁高效且易读。</p>
<p>今天主要是概念，代码很少，但是我还是写在了一个类文件里，感兴趣的同学可以下载下来看看。</p>
<p><br>Java Lambda<br><br>
<button onclick="window.open('Lambda.java')">点我下载 Lambda.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lambda&quot;&gt;&lt;a href=&quot;#Lambda&quot; class=&quot;headerlink&quot; title=&quot;Lambda&quot;&gt;&lt;/a&gt;Lambda&lt;/h1&gt;&lt;p&gt;Lambda其实并不复杂。它只是一个函数而已。今天我们来看看lambda的使用。我们会尝试几个简单的例子，然
    
    </summary>
    
    
      <category term="Java" scheme="https://alex-mengx.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第5天的Heap</title>
    <link href="https://alex-mengx.github.io/2017/05/04/postSorting/"/>
    <id>https://alex-mengx.github.io/2017/05/04/postSorting/</id>
    <published>2017-05-05T02:38:37.000Z</published>
    <updated>2017-05-07T17:00:34.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>堆是一个很神奇的结构。与其说是数据结构，不如说是一种算法或者想法。这个结构常用来作为排序的方式之一而被使用。堆跟二叉树其实十分的相似。堆一般有两种，我们称为最大堆和最小堆。用递归的方式来定义一下堆：根节点的数字，大于或者小于左右两侧的子堆。跟二叉树的区别在于，堆结构不在意左右两侧子节点之间的大小关系，且堆永远是完全二叉树结构。</p>
<h3 id="Completed-Binary-Tree"><a href="#Completed-Binary-Tree" class="headerlink" title="Completed Binary Tree"></a>Completed Binary Tree</h3><p>完全二叉树的概念其实很简单，一个二叉树，如果除了最底层以外的每一层都没有空节点，且最底层的节点都在左侧，则这个二叉树是完全二叉树。图来举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">完全二叉树1：</div><div class="line">                14  </div><div class="line">             /      \  </div><div class="line">           12        11</div><div class="line">         /  \      /    \  </div><div class="line">        1    0    6      9</div><div class="line"></div><div class="line"></div><div class="line">完全二叉树2：</div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           12        11</div><div class="line">         /  \     /   </div><div class="line">        1    0   6</div></pre></td></tr></table></figure></p>
<p>由图可知，只要二叉树除了最底层以外其它层的节点都是满的，且最底层的空节点也只在右侧，则这就是一个完全二叉树。</p>
<h3 id="Max-Heap"><a href="#Max-Heap" class="headerlink" title="Max Heap"></a>Max Heap</h3><p>我们今天用最大堆来举例实现什么是堆。最大堆最重要的特点就是无论什么时候，堆内的最大元素一定在根部。我们今天要实现的堆将有两个主要的方法：插入和取出。插入的时候是乱序，但是取出的元素一定是当前情况下堆内的最大元素。我们画图来看看堆的特性吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">我们有一个空的堆，我们将插入 &#123;14， 5， 12， 11 ，7， 0&#125; 6个数字到一个最大堆中。</div><div class="line"></div><div class="line">插入14 </div><div class="line">                14</div><div class="line"></div><div class="line">插入5 </div><div class="line">                14  </div><div class="line">             /     </div><div class="line">           5</div><div class="line"></div><div class="line">插入12</div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           5        12</div><div class="line"></div><div class="line">插入11</div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           11        12</div><div class="line">         / </div><div class="line">        5</div><div class="line"></div><div class="line">插入7</div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           11        12</div><div class="line">         /  \  </div><div class="line">        5    7</div><div class="line"></div><div class="line">插入0</div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           11        12</div><div class="line">         /  \      /</div><div class="line">        5    7    0</div></pre></td></tr></table></figure></p>
<p>无论任何时候，这个堆和其中的子堆，堆中的最大值一定在根节点。</p>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>堆的应用有很多种。我们想一想这种特性可以用来做什么呢？<br>堆排序。因为堆顶端的元素一定是当前堆内最大或者最小，我们只要持续从根节点取出元素，那么我们取出的元素就一定是排好序的。原理很简单，我们将需要排序的元素放入最大堆中，根据最大堆的原理，我们取出的顶端根元素一定是全部元素的最大值。取出顶端元素之后，这个最大堆会重新调整结构，使得堆内的元素的最大值移动到顶端。我们持续从堆中取出元素，则取出元素的顺序一定是从大到小的。<br>优先级队列。因为堆在任何时刻的最大元素都在顶端，所以在多次插入取出的时候，如果需要一直取出当前的最大值，则可以使用堆。<br>任务管理。很多任务是有优先级的。比如系统进程，有很多的优先级。那么在队列中，我们希望优先完成优先级高的任务，则我们可以使用堆。因为在插入更高优先级任务到堆中，堆顶会是当前最大优先级的任务。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>我们来实现一个最大堆。首先我们先来看一种新的二叉树的表示方法。二叉树我们以前的实现方式是先实现一个节点node，然后靠左右的指针来构建二叉树。但是呢，其实二叉树可以放进一个数组里。我们来看看这种表示方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">                14  </div><div class="line">             /      \  </div><div class="line">           12        11</div><div class="line">         /  \      /    \  </div><div class="line">        1    0    6      9</div><div class="line"></div><div class="line">我们来把这个二叉树放到数组里。</div><div class="line">[14, 12, 11, 1, 0, 6 ,9]</div><div class="line">这个数组为什么能表达二叉树呢？我们来看看每一个父节点和子节点在数组内的关系。</div><div class="line">便于计算，我们这个数组的角标从1开始而不是0.其实规律很好发现，我们把二叉树逐层遍历，放进数组就可以了。</div><div class="line">那么节点间的关系怎样表示呢？</div><div class="line">1的子节点在2和3的位置，2的子节点在4和5的位置，3的子节点在6和7的位置。</div><div class="line">也就是说，对于二叉树，节点i的左子节点在i*2, 右子节点在i*2+1.</div></pre></td></tr></table></figure></p>
<p>这样的二叉树表达的优点是读取快操作简单，但是当二叉树内有空节点的时候，就会占用额外的空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">                14  </div><div class="line">                    \  </div><div class="line">                     11</div><div class="line">                   /   </div><div class="line">                  6 </div><div class="line"></div><div class="line">[14, , 11, , , 6, ]</div><div class="line">只有三个元素，但是占用了7个元素的空间。</div></pre></td></tr></table></figure></p>
<p>但是对于我们的最大堆来说，这就不是一个问题了，因为最大堆的特性就是，这个堆是完全二叉树，不会有空子节点，且最后一层节点都在左侧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           11        12</div><div class="line">         /  \      /</div><div class="line">        5    7    0</div><div class="line"></div><div class="line">[14, 11, 12, 5, 7, 0]</div><div class="line">不会占用额外的空间。</div></pre></td></tr></table></figure></p>
<p>我们来用数组实现这个最大堆吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123;</div><div class="line">    private E[] heap;</div><div class="line">    private int currentIndex;</div><div class="line"></div><div class="line">    public MaxHeap(Class&lt;E&gt; c, final int size) &#123;</div><div class="line">        final E[] a = (E[]) Array.newInstance(c, size);</div><div class="line">        heap = a;</div><div class="line">        currentIndex = 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        public boolean isEmpty() &#123;</div><div class="line">        return currentIndex == 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean isFull() &#123;</div><div class="line">        return currentIndex == heap.length - 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Comparable我们已经很眼熟了，在二叉树中我们也限定了插入的元素必须是Comparable类，否则无法比大小。heap数组是我们的堆的数组表现形式，所有的元素都会保存在这个数组内。currentIndex 指向了堆的最下层的第一个空节点，也就等于数组元素的数量-1. 也就是说，当堆内没有元素，这个currentIndex等于1。另外注意为了便于计算，heap数组我们将会从位置1开始而不是0。在构造器内我们玩了个小把戏，因为java不支持generic数组，所以我们为了动态支持generic类型，在构造器内新建数组的时候，我们用反射的方式新建动态类型数组。反射的原理我们以后会开专门的一篇来讲解。</p>
<h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>首先我们来实现插入的方法。插入的原理其实很简单，因为我们的最大堆实际上是数组，而且我们已经知道这个完全二叉树的第一个空子节点的位置，所以把元素放入堆是个O(1)的操作。之后我们需要比较新元素和每一层的父元素，来确定最大值依旧在堆顶。我们来看图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">假设我们有最大堆： [14, 12, 11, 1, 0, 6] </div><div class="line"></div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           12        11</div><div class="line">         /  \     /   </div><div class="line">        1    0   6  </div><div class="line"></div><div class="line">这是个最大堆，因为每一个位置的值都大于这个位置的子堆。假设我们要插入16。</div><div class="line">堆的数组变成: [14, 12, 11, 1, 0, 6, 16] </div><div class="line"></div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           12        11</div><div class="line">         /  \     /    \</div><div class="line">        1    0   6      16</div><div class="line"></div><div class="line">比较16和它的父节点，如果新元素16较大，我们交换16和父节点的位置。</div><div class="line">因为在插入前，16的父节点是这个子堆的最大值，所以如果新元素16大于父节点，那么16一定大于父节点的左子节点6.</div><div class="line"> 堆的数组变成: [14, 12, 16, 1, 0, 6, 11] </div><div class="line"></div><div class="line">                14  </div><div class="line">             /     \  </div><div class="line">           12        16</div><div class="line">         /  \     /    \</div><div class="line">        1    0   6      11</div><div class="line"></div><div class="line">比较16和新的父节点。14原本是堆的最大值，所以如果16大于14，那么16一定大于原本堆内的其他元素。</div><div class="line">堆的数组变成: [16, 12, 14, 1, 0, 6, 11] </div><div class="line"></div><div class="line">                16  </div><div class="line">             /     \  </div><div class="line">           12        14</div><div class="line">         /  \     /    \</div><div class="line">        1    0   6      11</div><div class="line"></div><div class="line">到此，插入完成。我们再来插入一个新元素13：[16, 12, 14, 1, 0, 6, 11， 13]</div><div class="line"></div><div class="line">                16  </div><div class="line">             /     \  </div><div class="line">           12        14</div><div class="line">         /  \     /    \</div><div class="line">        1    0   6      11</div><div class="line">      /</div><div class="line">     13</div><div class="line"></div><div class="line">比较13和父节点，13较大，交换位置。13的位置是8， 父节点位置是8/2 = 4  </div><div class="line">新数组：[16, 12, 14, 13, 0, 6, 11， 1] 注意数组的位置从1开始计算。</div><div class="line"></div><div class="line">                16  </div><div class="line">             /     \  </div><div class="line">           12        14</div><div class="line">         /  \     /    \</div><div class="line">       13    0   6      11</div><div class="line">      /</div><div class="line">     1</div><div class="line"></div><div class="line">比较13和父节点，交换位置。父节点4/2 = 2, 新数组：[16, 13, 14, 12, 0, 6, 11， 1] </div><div class="line"></div><div class="line">                16  </div><div class="line">             /     \  </div><div class="line">           13        14</div><div class="line">         /  \     /    \</div><div class="line">       12    0   6      11</div><div class="line">      /</div><div class="line">     1</div><div class="line"></div><div class="line">13小于新的父节点，插入结束。</div></pre></td></tr></table></figure></p>
<p>通过图解我们看到，元素放入数组队尾只需要O(1)时间，等于对变量赋值。而整个插入过程，如果新元素小于其父元素，则插入立刻结束。最坏的情况，新的元素是堆中的最大值，则我们最多需要等于二叉树深度的次数的比较。N元素的完全二叉树，深度为logN,所以新元素插入的整体时间消耗是O(logN)。<br>来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void push(E e) &#123;</div><div class="line">    if (isFull())</div><div class="line">        throw new ArrayIndexOutOfBoundsException(&quot;This Heap Is Full!&quot;);</div><div class="line"></div><div class="line">    heap[currentIndex] = e;</div><div class="line">    int i = currentIndex;</div><div class="line">    while (i &gt; 1) &#123;</div><div class="line">        if (heap[i].compareTo(heap[i / 2]) &gt; 0)</div><div class="line">            swap(i, i / 2);</div><div class="line">        else</div><div class="line">            break;</div><div class="line">        i /= 2;</div><div class="line">    &#125;</div><div class="line">    currentIndex++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为我们的堆本质上是个数组，所以它长度有限，当满了之后我们就不能再继续放入新元素。但是这一点可以通过数组扩充来避免。在hashmap一章中我们已经了解了如何增加数组长度，这里就不在重新实践了。而且这里的扩容相对简单，因为最大堆的元素的位置跟数组的长度没有关系，所以简单的新建数组并且复制就可以了，感兴趣的小伙伴可以自行尝试。<br>从代码中我们可以看到基本的逻辑：</p>
<ol>
<li>首先将新元素放入堆的尾部。</li>
<li>从当前的新元素位置开始，比较新元素和当前的父节点i/2，如果新元素较大则交换位置。</li>
<li>重复步骤2直到新元素小于父节点或者到达顶端也就是i==1.</li>
</ol>
<p>逻辑很简单，实现起来也不复杂，要注意的一点就是无论是新元素在左侧还是右侧，因为对于int来说，<code>(i*2) / 2</code> 和 <code>(i*2+1) /2</code> 都等于i，所以我们不需要在意左右位置和i的奇偶性，只需要比较i/2就可以了。</p>
<h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><p>取出的操作也很简单。最大值已经在根节点，所以我们只要取出根节点就可以了。之后我们需要从尾部拿到最后一个元素，放到根节点，然后一路跟子节点比较，如果小于子节点就交换位置，直到到达底层或者不在小于子节点。我们看图说话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">有最大堆 [16, 13, 14, 12, 0, 6, 11， 1] </div><div class="line"></div><div class="line">                16  </div><div class="line">             /     \  </div><div class="line">           13        14</div><div class="line">         /  \     /    \</div><div class="line">       12    0   6      11</div><div class="line">      /</div><div class="line">     1</div><div class="line"></div><div class="line">取出顶部元素 16. 将尾部元素1放入顶端： [1, 13, 14, 12, 0, 6, 11] </div><div class="line"></div><div class="line">                1 </div><div class="line">             /     \  </div><div class="line">           13        14</div><div class="line">         /  \     /    \</div><div class="line">       12    0   6      11</div><div class="line"></div><div class="line">比较1和两个子节点，跟较大的交换位置： [14, 13, 1, 12, 0, 6, 11] </div><div class="line"></div><div class="line">                14 </div><div class="line">             /     \  </div><div class="line">           13        1</div><div class="line">         /  \     /    \</div><div class="line">       12    0   6      11</div><div class="line"></div><div class="line">继续比较，跟较大的交换位置  [14, 13, 11, 12, 0, 6, 1] </div><div class="line"></div><div class="line">                14 </div><div class="line">             /     \  </div><div class="line">           13        11</div><div class="line">         /  \     /    \</div><div class="line">       12    0   6      1</div><div class="line"></div><div class="line">取出结束.</div></pre></td></tr></table></figure></p>
<p>跟放入的逻辑很相似。</p>
<ol>
<li>取出最大值，将尾部元素放到堆首。</li>
<li>比较该元素和两个子节点的较大子节点，如果该元素小于较大的子节点，则将元素与较大子节点交换。</li>
<li>重复步骤2直到该元素不在小于子节点。</li>
</ol>
<p>来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public E poll() &#123;</div><div class="line">    if (isEmpty())</div><div class="line">        throw new IllegalStateException(&quot;This Heap Is Empty!&quot;);</div><div class="line"></div><div class="line">    currentIndex--;</div><div class="line">    E max = heap[1];</div><div class="line">    heap[1] = heap[currentIndex];</div><div class="line">    heap[currentIndex] = null;</div><div class="line">    int i = 1;</div><div class="line">    while (i &lt;= currentIndex / 2) &#123;</div><div class="line">        int larger = 0;</div><div class="line">        if (heap[i * 2] == null)</div><div class="line">            break;</div><div class="line">        else if (heap[i * 2 + 1] == null)</div><div class="line">            larger = i * 2;</div><div class="line">        else</div><div class="line">            larger = heap[i * 2].compareTo(heap[i * 2 + 1]) &gt; 0 ? i * 2 : i * 2 + 1;</div><div class="line"></div><div class="line">        if (heap[i].compareTo(heap[larger]) &lt; 0)</div><div class="line">            swap(i, larger);</div><div class="line">        else</div><div class="line">            break;</div><div class="line">        i = larger;</div><div class="line">    &#125;</div><div class="line">    return max;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码看起来稍微复杂一点。但是逻辑还是一样的。主要的复杂点在于最后一层可能有空节点，所以需要判断子节点时候为空。这里其实可以简化，但是为了便于阅读和理解我们用三个if来表示逻辑分支。当i*2子节点也就是当前节点的左节点为空，说明两个节点都为空，可以返回。如果当前节点的右节点为空，则左节点是子节点中的最大值。如果两个节点都在，则比较两个节点，选择较大子节点。<br>之后比较我们的父节点和较大的子节点，如果子节点比父节点大，交换位置继续向下比较，否则循环停止，取出完成。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>我们来看看运行的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    MaxHeap&lt;Integer&gt; heap = new MaxHeap&lt;&gt;(Integer.class, 11);</div><div class="line"></div><div class="line">    while (!heap.isFull())</div><div class="line">        heap.push((int) (Math.random() * 100));</div><div class="line">    while (!heap.isEmpty())</div><div class="line">        System.out.print(heap.poll() + &quot; &quot;);</div><div class="line"></div><div class="line">    System.out.println();</div><div class="line"></div><div class="line">    while (!heap.isFull())</div><div class="line">        heap.push((int) (Math.random() * 100));</div><div class="line">    while (!heap.isEmpty())</div><div class="line">        System.out.print(heap.poll() + &quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入一些随机数，然后取出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">86 74 63 59 58 35 20 14 1 </div><div class="line">97 93 59 56 52 42 34 33 6</div></pre></td></tr></table></figure></p>
<p>可以看到已经排好序了。这个结构和排序方法的放入和取出都是最坏情况O(logN)，所以对于N个数字排序这种堆排序的时间复杂度是O(logN)。但是，这种堆排序有它独特的优点和使用场景。比如在生产中，工厂的数字信号都是时间信号，既每个数据点都有时间戳，比如某检测电机转速的探头的数据 {timestamp:long value, data:double value}。对于这样的数据，通常是数据流传输到控制中心来集中处理。但是由于网络的延迟和实际远程部署的物理限制，数据流的传输可能会受到影响.<br>也就是说，对于时间信号[{1,100}, {2,200}, {3, 300}, {4,400}…]控制中心接收到的数字信号可能是[{1,100}, {3,300}, {2, 200}, {4,400}…]。由于网络延迟等，收到的数据信号的顺序可能会有小范围的混乱。这种时候，一个堆排序就可以解决这个问题。如果在接收端，我们先把信号放入一个固定长度的最小堆结构，比如这个最小堆长度为3秒钟的数据量，则从堆中取出的时候，我们取出的元素一定是最近三秒内到达的数据中的的最小时间戳数据。这样一来，由于网络延迟不太会超过特定时间长度，则我们处理的信号就可以恢复原本的时间顺序。在工业信号处理中，由最小堆实现的优先级队列是很常见的时间顺序过滤方法。</p>
<p><br>依旧附上了源码。<br><br>
<button onclick="window.open('MaxHeap.java')">点我下载 MaxHeap.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Heap&quot;&gt;&lt;a href=&quot;#Heap&quot; class=&quot;headerlink&quot; title=&quot;Heap&quot;&gt;&lt;/a&gt;Heap&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>第1天的多线程</title>
    <link href="https://alex-mengx.github.io/2017/04/22/postMutex/"/>
    <id>https://alex-mengx.github.io/2017/04/22/postMutex/</id>
    <published>2017-04-23T03:29:09.000Z</published>
    <updated>2017-04-24T02:21:31.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MultiThreading"><a href="#MultiThreading" class="headerlink" title="MultiThreading"></a>MultiThreading</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>多线程是常见的并发实现方式。要了解多线程，我们会来试着从什么是线程开始了解如何在java中使用线程来帮助我们更快的完成任务。我们先来看一下什么是线程。这个问题其实需要很多的背景知识，不过我们在这里先大概了解一下，具体的细节先不用在意。</p>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>首先，我们先来回忆一下电脑执行程序的时候的表现。当你打开一个游戏，一个文档或者一个浏览器，对于你来说，你感受到的是这个程序的流畅的运行。在用户的角度来看，你所运行的程序是流畅的，不间断的，你的输入总是能瞬间反馈到程序之中，释放的技能似乎也没有任何延迟。但是，事实真的如此吗？<br>现在的电脑有多个cpu核心，但是在数十年以前，连超线程技术都没有的时候，计算机的cpu还只有一个核心，操作系统也只有一个进程。如果那个时候的用户打开一个程序，当这个程序占用了核心的时候，没有其他的程序可以被执行。如果一个程序可以长期占用核心，那就会带来很大的问题。比如你在玩游戏的时候，你的这个游戏就占用了唯一的核心。那么，操作系统自身就没有了cpu资源，也没有其他任何程序可以运行。为了解决这个问题，新的硬件和操作系统支持了context switching，在这个过程中，操作系统的内核(kernal)会保存当前正在执行的进程的运行状态，切换到另一个等待的进程并继续执行。这个过程十分的短暂和智能，在用户的角度来讲，就好像打开的程序完全没有暂停或者中断过，但是实际上在cpu看来，这个程序在不停的暂停和恢复。不仅仅是CPU，当多个程序读取IO的时候，这种切换也在频繁的发生。所以当我们打开多个程序，对于每一个程序而言，似乎它都独自占有了整套的内存，CPU和硬盘IO等等。<br>那么，进程到底是什么呢？进程就是一个程序在操作系统中的抽象。进程包含了即将执行的指令和需要的数据，也包含了需要的内存地址。进程的运行状态可以有很多种，包括运行，等待，结束等等。对于每一个进程来说，其所拥有的资源是独立的，这使得进程的运行稳定且快速，每个进程都拥有完整的内存空间，这是通过虚拟地址空间和物理地址的mapping实现的。当然这中间的细节有很多，不可能在这里全部讲完，感兴趣的同学我推荐<a href="https://book.douban.com/subject/5333562/" target="_blank" rel="external">Computer Systems: A Programmer’s Perspective</a>，第一章节就对这些有了基本的描述。</p>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>上面我们提到了每个进程都是相互独立的，这使得进程间交换数据变得很复杂。进程的内存空间也相互独立，也就意味着进程不能够访问其他进程的内存地址。在这种情况下，我们通过一些方法比如共享内存，本地socket连接，信息队列等来在进程间通信。但是只有多进程可以加速程序运行吗？其实，在现代的操作系统中，进程已经不是执行序列的最小单位了。比如JVM，大部分的JVM实现是单进程的。也就是说，一个JVM实例就是一个进程，这个进程包含了JAVA程序执行所需要的全部环境变量和资源需求。在一个进程中，可以有很多的线程存在。从操作系统的角度来看，当用户创建了一个进程时，这个进程中最少包含了一个线程。不同的操作系统管理线程的方式不同。以Linux为例子，当我们建立了进程，这个进程就拥有了唯一的进程ID(PID)。同时这个进程中也有一个线程，线程也拥有自己的ID(TID)。线程与进程最大的不同在于，同属于同一个进程的线程是共享进程资源的。线程本身的资源来自于进程，而拥有同一个线程组ID(TGID)的线程则分享同一个虚拟内存空间。这使得线程间分享数据传递消息变得十分的简易。</p>
<h2 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h2><p>我们已经对于什么是线程有了基本的了解。那么，为什么我们需要多线程呢？其实，对于早期的单核cpu来说，多线程只会增加耗时。原因很简单，当只有一个核心时，能同时运行的线程只有一个，那么原本一个线程的任务拆成了两个线程,操作系统和cpu就要花费额外的时间来管理多个线程，包括创建线程，线程间切换也就是context switch，这些都会消耗额外的资源。所以其实单核心的CPU和单进程的操作系统理论上拥有最高的执行效率。但是当单核心的频率遇到了瓶颈，多核就出现了。现在的CPU大多都在4核心以上，也就是说，我们可以将一份任务拆成多分，让每个核心执行一份，这样就可以大大缩小任务的耗时。<br>我们可以试着对比一下单线程和多线程完成同样的任务的耗时。</p>
<h3 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h3><p>我们可以设计一个小实验。试验用的电脑是4核，所以我们可以对比单线程，双线程和四线程的耗时。以下是实验设计：</p>
<ol>
<li>读取一个较大的英文文档到内存中，以字符串数组的形式保存。</li>
<li>将数组分成很多份。</li>
<li>每一个线程中将获得一份数组，并且对数组中的字母出现次数进行统计。</li>
<li>将结果整合，并计算耗时。</li>
</ol>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>代码的整体逻辑还是比较简单的。我们来设计一下。首先我们需要一个函数来在每个线程里跑。这个函数应该接受一个数组，然后返回数组内的字符串出现过的全部字符以及出现次数。这个函数返回的结果应该用什么结构来存储呢？其实这个形式我们已经很熟悉了，我们注意到了结果是一对一对，一个字符对应一个数字，这种key value 很适合hashmap。那么统计的过程我们可以用这种思想：</p>
<ol>
<li>在字符串中读取下一个字符。</li>
<li>如果该字符不在hashmap里，则我们放入[字符， 1]， 这意味着这个字符目前是第一次出现。</li>
<li>如果该字符已经在hashmap里，则我们使得[字符， value++]，</li>
<li>重复步骤1,2,3 直到到达字符串结尾</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 注意，这个方法返回的是一个函数，而不是结果</div><div class="line">private static Callable&lt;Map&lt;Character, Integer&gt;&gt; task(List&lt;String&gt; job, int trail) &#123;</div><div class="line">    return () -&gt; &#123; // 这是一个Callable，也就是我们的函数。这个函数会返回一个hashmap</div><div class="line">        HashMap&lt;Character, Integer&gt; result = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        for (String str : job) &#123; // 遍历字符串链表</div><div class="line">            str.chars().forEach(c -&gt; &#123; // 遍历每个字符</div><div class="line">                result.computeIfPresent((char) c, (key, value) -&gt; ++value); // 这个是hashmap的自带方法，如果key存在，则调用函数++value</div><div class="line">                result.computeIfAbsent((char) c, (value) -&gt; 1); //如果key不存在，放入key, 1</div><div class="line">            &#125;); // 注意，computeIfPresent 和 computeIfAbsent 的顺序是不能改变的。否则我们会先调用computeIfAbsent生成key，然后重复调用computeIfPresent</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个线程的任务已经实现了，下面我们来看执行这些任务的方法。我们希望这个方法可以接受全部的文件字符串，接受线程的数目，然后将文件分割成跟线程数目一样多的小块，让每个线程执行上面方法返回的Callable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">private static long runTask(List&lt;String&gt; file, int numberOfThreads, int trail) &#123;</div><div class="line">    List&lt;List&lt;String&gt;&gt; jobs = new LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    int portion = file.size() / numberOfThreads; // 每一份的字符串链表的大小</div><div class="line">    IntStream.range(0, numberOfThreads).forEach(i -&gt; jobs.add(file.subList(i * portion, (i + 1) * portion))); // 这里我们将file这个包含了全部字符串的链表分割成了numberOfThreads 份。</div><div class="line"></div><div class="line">    List&lt;Callable&lt;Map&lt;Character, Integer&gt;&gt;&gt; tasks = IntStream.range(0, numberOfThreads)</div><div class="line">            .mapToObj(i -&gt; task(jobs.get(i), i)).collect(Collectors.toList()); // 这里建立一个链表，里面是这里我们将file这个包含了全部字符串的链表分割成了numberOfThreads数量的任务。</div><div class="line">    ExecutorService executor = Executors.newFixedThreadPool(numberOfThreads); // 这个executor可以执行numberOfThreads个线程。</div><div class="line"></div><div class="line">    long start = System.currentTimeMillis(); // 开始计时</div><div class="line"></div><div class="line">    CompletionService&lt;Map&lt;Character, Integer&gt;&gt; ecs = new ExecutorCompletionService&lt;Map&lt;Character, Integer&gt;&gt;(</div><div class="line">            executor);</div><div class="line">    for (Callable&lt;Map&lt;Character, Integer&gt;&gt; task : tasks)</div><div class="line">        ecs.submit(task); // 运行全部的线程和任务</div><div class="line"></div><div class="line">    HashMap&lt;Character, Integer&gt; finalResult = new HashMap&lt;&gt;(); // 这里是为了从各个线程的结果reduce到一个最终结果。</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; numberOfThreads; i++) &#123;</div><div class="line">        Map&lt;Character, Integer&gt; result;</div><div class="line">        try &#123;</div><div class="line">            result = ecs.take().get(); // 这个方法会block当前线程，等待任务结束。</div><div class="line">            result.entrySet().forEach(e -&gt; &#123; // 对于每个任务返回的结果，我们用跟单个任务同样的逻辑来整理</div><div class="line">                finalResult.computeIfPresent(e.getKey(), (key, value) -&gt; value + e.getValue()); // 如果已经存在，key的value也就是出现次数叠加</div><div class="line">                finalResult.computeIfAbsent(e.getKey(), (value) -&gt; e.getValue()); // 如果不存在，我们直接把key value 放进来。</div><div class="line">            &#125;);</div><div class="line">        &#125; catch (InterruptedException | ExecutionException e3) &#123;</div><div class="line">            e3.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    long cost = System.currentTimeMillis() - start; // 到这里，全部的任务都结束了，我们可以知道全部线程完成任务</div><div class="line"></div><div class="line">    finalResult.entrySet().stream().sorted((e1, e2) -&gt; e1.getKey().charValue() &gt; e2.getKey().charValue() ? 1 : -1)</div><div class="line">            .forEach(e -&gt; System.out.println(e)); // 这里只是打印出来整理好的结果。 如果重复多次，这个结果应该是一致的。</div><div class="line"></div><div class="line">    executor.shutdown();</div><div class="line"></div><div class="line">    System.out.println(&quot;Run with &quot; + numberOfThreads + &quot; threads. Current trail is: &quot; + trail</div><div class="line">            + &quot;. Overall time cost is: &quot; + cost + &quot; milliseconds.&quot;);</div><div class="line"></div><div class="line">    return cost; // 返回耗时</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很好，现在我们有了单次测试的方法，只要调用这个方法，我们就会获得某个数量的线程完成任务的耗时。但是实验需要重复，我们来运行这个方法50次，取平均值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static double runTasksForAverage(List&lt;String&gt; file, int numberOfThreads) &#123;</div><div class="line">    return IntStream.range(0, runs).mapToLong(i -&gt; runTask(file, numberOfThreads, i)).average().getAsDouble();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法调用了上面的测试，运行一定的次数，然后计算平均值。<br>现在我们就有了全部所需的方法。在main方法中，我们可以运行不同的线程数量，然后对比结果。这里我只贴出结果，全部的代码会附在结尾。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>这个结果所计算的txt文件是102MB大小的一个txt文档。我们看到速度还是很快的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Test Results:</div><div class="line">Enviroument: number of process is 8. Size of memory is : 1896873984</div><div class="line">Number of Threads    |    Average running time </div><div class="line">     1               |            1874 ms</div><div class="line">     2               |            1362 ms</div><div class="line">     4               |            778 ms</div><div class="line">     8               |            604 ms</div><div class="line">    16               |            563 ms</div><div class="line">    32               |            522 ms</div><div class="line">    64               |            561 ms</div><div class="line">   128               |            572 ms</div><div class="line">   256               |            587 ms</div><div class="line">   512               |            595 ms</div><div class="line">  1024               |            681 ms</div><div class="line">  2048               |            837 ms</div><div class="line">  4096               |            1026 ms</div></pre></td></tr></table></figure></p>
<p>运行底部的代码，可以获得同样格式的输出，但是具体数字会有所不同。<br>这个结果跟我们期望的结果差不多。你可能会疑惑，为什么不是8个线程的结果最快？8核心不是应该8线程最快吗？理论上来说是的，如果我们的操作系统是单进程系统的话。这个测试运行在Windows 系统中，且后台有多项服务在运行，所以8线程的情况下，操作系统和其他程序会抢夺更多的资源。从结果来看，32线程从CPU中抢夺到了最多的资源，同时没有导致过高的context switch。线程切换的副作用是很明显的。当我们的线程数提高到四千时，几乎一半的时间被用在了Context switch上。另外为什么两个线程的耗时不是一个线程的一半，四个线程的耗时也不是两个线程的一半，这是因为建立新线程和资源分配的消耗。这也是多核的副作用，单核的效率依旧是最高的。<br>另外多说一点，这个CPU其实是4核，超线程到了8核，所以4线程和8线程的结果相差不是很多，而且部分提升其实来自于多个线程从其他程序抢夺到的系统资源。</p>
<p>照旧附上了代码，使用这个代码需要在同一个目录下放置一个名为resources的文件夹，文件夹里需要放置一个足够大的名为all.txt的文件。<br><br>Multithreading<br><br>
<button onclick="window.open('MultiThreading.java')">点我下载 MultiThreading.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MultiThreading&quot;&gt;&lt;a href=&quot;#MultiThreading&quot; class=&quot;headerlink&quot; title=&quot;MultiThreading&quot;&gt;&lt;/a&gt;MultiThreading&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a 
    
    </summary>
    
    
      <category term="Concurrency" scheme="https://alex-mengx.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>第4天的Map</title>
    <link href="https://alex-mengx.github.io/2017/04/15/postMap/"/>
    <id>https://alex-mengx.github.io/2017/04/15/postMap/</id>
    <published>2017-04-15T15:08:49.000Z</published>
    <updated>2017-05-07T05:22:17.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Map是很常用的一种数据结构。在了解map之前，我们需要了解一点Set。set就是集合，是一种更加偏向数学抽象概念的结构。对于set的实现是多种多样的，但是基本概念是共通的。对于集合来说，所有元素的种类应该是相同的。在大部分语言中对于set的实现应当是类似的，但是也取决于具体实现的类型。比如java和python之中，set是不包含重复元素的。<br>Set的基本逻辑操作有几种，我们只列举两个例子：</p>
<ol>
<li>取交集。两个集合，交集就是一个新的集合，它包括了两个集合中的全部元素，但是没有重复。</li>
<li>取并集。两个集合，并集也是一个新的集合，包含了两个集合之中共同的元素。</li>
</ol>
<p>对于map来讲，map就是set的一种稍微具体一点的抽象形式。我们知道set之中是一类元素，而map可以包含的元素有着特定的结构。我们想将一个元素放入map，那这个元素就需要是<code>&lt;key-value&gt;</code>的形式才可以。熟悉数据库的小伙伴可能会对于这种形式更加熟悉一点。今天我们就通过讲解key value，hash的概念来实现一个简单的hashmap。</p>
<h2 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h2><p>key value 的概念其实很好理解。就像是有编码的柜子，我们放入物品的时候就会记住我们的东西放进了几号柜子。这种情况下，柜子的号码就是key，放入的物品就是value。所以实际上，key就是便于查找的位置索引，value则是要存入的数据。数据库中需要提供主键也是这个原因，索引会大大提高查询的效率。想象一下，你知道你的东西在某个柜子里，然而柜子的存储是无序的。那么你需要遍历全部的柜子才能找到你的东西。但是，当你有了柜子的号码，你不需要任何搜索，只要打开对应的柜子门，就可以取出物品。于是取出的时间从O(n)变成了O(1)。在map中，一对key value 叫做一个entry。我们来实现这个entry。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Entry &#123;</div><div class="line">    K key;</div><div class="line">    V value;</div><div class="line">    int hashcode;</div><div class="line"></div><div class="line">    public Entry(K key, V value) &#123;</div><div class="line">        this.key = key;</div><div class="line">        this.value = value;</div><div class="line">        this.hashcode = hashFunction(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final K getKey() &#123;</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final V getValue() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public final String toString() &#123;</div><div class="line">        return key + &quot;=&quot; + value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是我们的map中的最小存储单位啦。就像链表中的节点Node一样，map中的每个元素都在一个Entry之中。在这个entry class中，我们有key，有value，但是我们还多出了一个hashcode。这是什么呢？</p>
<h2 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h2><p>哈希值，是元素的指纹。我们都知道，人的指纹是独一无二的，很少有两个人的指纹是一样的。哈希值也是如此，我们希望所有的元素的哈希值都是独一无二的。在讲解哈希值之前，我们先来了解一下hashmap的原理。依旧用柜子来举例吧。现在我们来到了一家商场，这个商场有存包的柜子。于是我们怎么做？找到一个空的柜子，锁上，然后记住柜门的编号。这样我们来取包裹的时候，只需要找到这个编号的柜子，就能拿到我们想要的东西。<br>现在，问题变得复杂了一些，假设我们有很多包裹，我们该怎么存呢？如果我们采用了同样的策略，对于每一个包裹，我们都找到一个空的柜子，然后放入包裹，那么当我们需要找到某个包裹的时候，我们该怎么办？因为包裹的数量很多，我们可以用一个表来记录哪个包裹存在了哪个柜子里。假设我们在存包的同时保存了一张表，上面记录着柜子编号和保存的包裹。这样当我们需要找某一个包裹的时候，我们就可以从表上找到这个包裹，然后查询对应的柜子的编号。但是这样做的缺点是什么呢？当包裹数量很多的时候，从表中找到某个包裹所花费的时间会很多。我们对于算法的时间复杂度已经有了一些初步的了解，所以我们知道，在N个无序的元素中找到某个特定元素的时间复杂度是O(n)。如果每次取出或者查找的时间都是O(N)，那么map的耗时跟无序链表就一样了，同样的O(1) 插入，O(n)查找和取出。那么我们该怎样改善我们存包裹的方法呢？<br>这个问题的关键是如何记录包裹所对应的柜子的编号。如果包裹自身的天然特性就包含了某种编号，这个问题就解决了。假设我们的包裹是已经有自己的编号的，那么我们存包的时候只需要保证一个原则，既柜子编号和包裹编号是一致的，那么当我们想要找某个编号为x包裹，我们就可以直接去x号柜子。<br>但是更进一步的问题是，很多时候要存储的目标元素没有这种天然的编号，我们又不能人为编号，否侧查找编号和包裹对应的过程同样要花费O(n)的时间。这种时候，我们就需要一个方法，这个方法接受一个包裹，然后针对这个包裹计算出只属于这个包裹的特定值，并且对于同一个包裹每次计算的结果都是一致的，那么我们就可以用这个方法来计算对应的柜子编号。这个方法就是hash function，也叫哈希函数。<br>一个比较具体的例子就是电话本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 假设我们有个函数，这个函数接受人的名字，并且把名字的首字母转换成0-25的数字，这就是一个很好的哈希函数。</div><div class="line"></div><div class="line">&quot;Alex&quot;                                      0</div><div class="line">&quot;Bailey&quot;                                    1</div><div class="line">&quot;Claire&quot;        -&gt;  Hash Function  -&gt;       2</div><div class="line">&quot;Dominic&quot;                                   3</div><div class="line">&quot;Elsa&quot;                                      4</div><div class="line"></div><div class="line">// 名字就有了自然的编号，而且无论重复计算多少次，同一个名字的哈希值也不会变化。</div><div class="line"></div><div class="line">String[] nameTable</div><div class="line"></div><div class="line">nameTable[hashFunction(&quot;Alex&quot;)] = &quot;Alex&quot;</div><div class="line"></div><div class="line">//通过哈希值计算，我们为“Alex”这个名字找到了对应的数组位置。</div></pre></td></tr></table></figure></p>
<h2 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h2><p>哈希值的用法我们已经很清楚了，但是如果当两个元素的哈希值一致，我们该怎么办呢？<br>比如上面的例子，当我们有“Alex”的同时，还有“Arturia”，那么这两个名字就会拥有同样的哈希值。这种情况就叫做碰撞。碰撞是无法完全避免的，我们只能通过调整hash function来尽量减少碰撞。在hashmap中，我们也有别的方法来解决碰撞，稍后会讲到。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>了解了key value和哈希值之后，我们已经做好了实现hashmap的准备。我们再来回顾一下几个要点：</p>
<ol>
<li>entry来存储key value，key是value的某个天然的特征。</li>
<li>hashmap实际上是个数组，我们通过hash function来计算某个key的hash值，来计算这个key value应当被放入的位置</li>
<li>对于这个hashmap的数组，如果我们直接放入Entry，那么碰撞产生的时候我们就无法在同一个位置存储两个entry。所以相对的，我们建立一个List数组，如果哈希值一致，那么我们就放在数组对应位置的List里。每一个list就像是一个篮子，同样哈希值的key就会在同一个篮子里。</li>
<li>我们需要设定一个阈值。因为哈希计算出的值在数组中所对应的篮子不一定是空的。我们想要尽量避免在同一个篮子里放入太多元素。所以当数组中非空的篮子太多，我们就要增加数组的长度。</li>
</ol>
<p>我们来看具体实现吧。总的来说常见的操作就是增删改查，但是对于map来说，因为map属于set的一种具体实现，所以map中没有重复的key，所以在放入同样的key - 无论 value是否相同 - 旧的key value都会被覆盖。因此，我们就不需要实现修改了，因为放入的过程可以等同于修改。先写出框架：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class HashMap&lt;K, V&gt; &#123;</div><div class="line"></div><div class="line">    public class Entry &#123;</div><div class="line">        private K key;</div><div class="line">        private V value;</div><div class="line">        private int hashcode; // 通过hash function 计算出的哈希值，在这里这个哈希值是当前entry在数组中所在的位置。</div><div class="line"></div><div class="line">        public Entry(K key, V value) &#123;</div><div class="line">            this.key = key;</div><div class="line">            this.value = value;</div><div class="line">            this.hashcode = hashFunction(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public final K getKey() &#123;</div><div class="line">            return key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public final V getValue() &#123;</div><div class="line">            return value;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        final int getHashcode() &#123;</div><div class="line">            return hashcode;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public final String toString() &#123;</div><div class="line">            return key + &quot; = &quot; + value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private LinkedList&lt;Entry&gt;[] table; // 这就是我们的table了。所有的key value 都会被放入这个table。</div><div class="line">    private int capacity = defaultCap; // 因为table是数组，我们需要知道数组的长度。这个值会记录数组的长度。</div><div class="line">    private double tableSize = 0; // 这个值是数组中不为null的list的数量，我们用这个值判断是否需要增加数组长度</div><div class="line">    private int size; // 目前table里面元素的数量，这里是entry的数量，不是list的数量。</div><div class="line">    private static final double resizeRatio = 0.5; // 阈值。table中有一半的位置被使用了，则增加长度。</div><div class="line">    private static final int defaultCap = 32; // 初始长度，2^5 大小。</div><div class="line"></div><div class="line">    public int size() &#123;&#125; // 返回当前entry的数量</div><div class="line"></div><div class="line">    public boolean isEmpty() &#123;&#125; // 返回当前map是否为空</div><div class="line"></div><div class="line">    public boolean containsKey(K key) &#123;&#125; // 如果map中有这个key，返回true，反之亦然</div><div class="line"></div><div class="line">    public V get(K key) &#123;&#125; // 给出key，返回key对应的value</div><div class="line"></div><div class="line">    public void put(K key, V value) &#123;&#125; // 放入一对key value</div><div class="line"></div><div class="line">    public boolean remove(K key) &#123;&#125; // 删除某个key，同时也会删除key对应的value</div><div class="line"></div><div class="line">    private int hashFunction(K key) &#123;&#125;// 计算哈希值的方法。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>下面就是map的具体实现了。我们一项一项的来。</p>
<h3 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private int hashFunction(K key) &#123;</div><div class="line">    return key.hashCode() &amp; (capacity - 1); //这是个小技巧。也是为什么我们选择2^n来作为数组的长度。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>哈希值计算方法。这个方法很简单，但是很实用。 具体来说就是用key object自带的hashcode方法，对数组的长度取模 （取余数）。hashcode是java Object类自带的一个方法，具体实现取决于继承自Object的类。对capacity取模则可以把key放置在我们的数组的范围之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">解释一下为什么取模可以用&amp;操作。对于十进制，如果我们取模的数字是10：</div><div class="line">1234 % 10 = 4</div><div class="line">5678 % 10 = 8</div><div class="line"></div><div class="line">很明显，对10取模，等于只保留该数字的各位。再来看二进制。我们对2取模：</div><div class="line">1 % 2 -&gt; 0001 % 2 = 0001</div><div class="line">2 % 2 -&gt; 0010 % 2 = 0000</div><div class="line">3 % 2 -&gt; 0011 % 2 = 0001</div><div class="line"></div><div class="line">一样的道理，只要保留二进制的最后一位，就是取模的结果。那么，当数组的长度是2^n时：</div><div class="line">假设对8取模</div><div class="line">9 % 8  -&gt; 1001 % 1000 = 0001</div><div class="line">10 % 8 -&gt; 1010 % 1000 = 0010</div><div class="line">11 % 8 -&gt; 1011 % 1000 = 0011</div><div class="line"></div><div class="line">找到规律了吧，对于2^n 取模，等于 &amp; (2^n -1) 操作。这个操作比 % 操作要快得多得多得多。</div></pre></td></tr></table></figure></p>
<h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><p>放入一对key value。这个方法比别的操作稍微复杂一点。在每次放入之前，我们需要查看当前数组中空的篮子和总长度的比值是否大于我们设定的阈值。我们设定的值为0.5，也就是说空的篮子占数组总长的一半以下，则我们直接放入。如果空位过少，我们直接加倍数组的长度。数组中空位越多，则元素被放入同一个篮子的概率就越小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public void put(K key, V value) &#123;</div><div class="line">    if (tableSize / capacity &gt; resizeRatio) // 如果空位少于一半，我们增加数组长度</div><div class="line">        resize();</div><div class="line">    remove(key); // 这里是一个偷懒的小方法。因为map中不能存在同样的key，所以在放入新的key的时候，如果这个key已经存在，新的值将会覆盖旧的值。</div><div class="line">    Entry e = new Entry(key, value);</div><div class="line">    if (table[e.hashcode] == null)&#123; // 如果篮子是空的</div><div class="line">        table[e.hashcode] = new LinkedList&lt;Entry&gt;();</div><div class="line">        tableSize++; // 这里我们记录目前数组之中list的个数</div><div class="line">    &#125;</div><div class="line">    table[e.getHashcode()].add(e); // 在对应的篮子中放入key value</div><div class="line"></div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void resize() &#123;</div><div class="line">    capacity = capacity * 2;  // 我们的数组长度一直是2^n。这样可以提高hash function的运行效率</div><div class="line">    tableSize = 0; //tableSize set to 0， 因为重新hash的话位置会改变</div><div class="line"></div><div class="line">    LinkedList&lt;Entry&gt;[] array = new LinkedList[capacity]; // 新建一个数组</div><div class="line">    for (LinkedList&lt;Entry&gt; l : table)&#123;</div><div class="line">            if (l != null)&#123;</div><div class="line">                for (Entry e : l)&#123;</div><div class="line">                    e.hashcode = hashFunction(e.key);</div><div class="line">                    if (array[e.hashcode] == null) &#123;</div><div class="line">                        array[e.hashcode] = new LinkedList&lt;Entry&gt;();</div><div class="line">                        tableSize++;</div><div class="line">                    &#125;</div><div class="line">                    array[e.hashcode].add(e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    // 新建的数组为空。</div><div class="line">    // 这里是两层循环。对于每个篮子：</div><div class="line">        遍历这个篮子，对于每个entry: </div><div class="line">            我们需要重新计算hashcode，因为数组的capacity产生了变化，所以hash function 的结果也会变化。然后根据新的hashcode，把这个entry放入新建的数组中</div><div class="line"></div><div class="line">    this.table = array; // 让我们的table指向新建的数组</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>放入的逻辑其实比较简单：</p>
<ol>
<li>判断是否需要新建一个大一些的数组。</li>
<li>根据key计算hashcode</li>
<li>根据hashcode找到对应的篮子，如果篮子为空，新建List</li>
<li>放入key value。</li>
</ol>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找。逻辑很简单，也是根据key找对应的篮子，然后在篮子里找对应的元素。这里要注意的就是几个null判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean containsKey(K key) &#123;</div><div class="line">    int hashcode = hashFunction(key);</div><div class="line">    if (hashcode &gt;= table.length || size &lt;= 0)</div><div class="line">        return false;</div><div class="line">    LinkedList&lt;Entry&gt; list = table[hashcode];</div><div class="line">    if (list == null)</div><div class="line">        return false;</div><div class="line">    return list.stream().filter(e -&gt; key.equals(e.getKey())).count() &gt; 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要注意的几点：</p>
<ol>
<li>判断hashcode是否在array的长度之内。</li>
<li>判断array中查找的key对应的的篮子是否为null</li>
<li>在篮子中找对应的key</li>
</ol>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>删除的逻辑跟查找是类似的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean remove(K key) &#123;</div><div class="line">    int hashcode = hashFunction(key);</div><div class="line">    if (hashcode &gt;= table.length || size &lt;= 0)</div><div class="line">        return false;</div><div class="line">    LinkedList&lt;Entry&gt; list = table[hashcode];</div><div class="line">    if (list == null)</div><div class="line">        return false;</div><div class="line">    list.removeIf(entry -&gt; entry.getKey().equals(key));</div><div class="line">    if(list.isEmpty())&#123;</div><div class="line">        tableSize--;</div><div class="line">        table[hashcode] = null;</div><div class="line">    &#125;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断的方式也差不多。</p>
<ol>
<li>判断hashcode是否在array的长度之内。</li>
<li>判断array中key对应的的篮子是否为null</li>
<li>如果篮子在，则在篮子中删除目标key</li>
<li>如果篮子空了，那么我们需要把这个篮子整个去除，数组的这个位置变为null，而不是一个空的list。这是为了方便判断空篮子的比例。</li>
</ol>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>这个方法和查找 containsKey() 是一样的，只不过这个方法返回了查找key对应的value。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public V get(K key) &#123;</div><div class="line">    int hashcode = hashFunction(key);</div><div class="line">    if (hashcode &gt;= table.length || size &lt;= 0)</div><div class="line">        return null;</div><div class="line">    LinkedList&lt;Entry&gt; list = table[hashcode];</div><div class="line">    if (list == null)</div><div class="line">        return null;</div><div class="line">    return list.stream().filter(e -&gt; key.equals(e.getKey())).map(e -&gt; e.getValue()).findFirst().orElse(null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样判断是否为null，直到找到目标篮子，然后在篮子里找到目标key，返回对应的value。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们了解了HashMap的概念和，了解了key value 存储和hash function的工作原理。我们也自己动手实现了一个简易版的Hashmap。这个hashmap的优点很多，最大的优点就是，它所有的增删改查方法的时间复杂度都是O(1)。原因是因为，map内部的结构是一个数组，而对于某个key我们计算hashcode的方法不受N的影响，所以无论map里有多少元素，从key到具体篮子的过程耗时都是一个常数。有的小伙伴可能有疑惑：可是再插入N个元素的过程中，当n/2个元素被插入之后，我们会新建一个数组，然后复制所有的元素到新的数组，这样岂不是遍历了一遍，这一次的插入不就是O(N)吗？确实，这一次的插入是O(n)，但是平均到每一次，就是O(1)了。如果我们把这个过程写成等式，我们来看一下插入N的元素的耗时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">T(N) = T(1) * n/2 + T(n/2) + T(1) * n/2 = nT(1) + T(n/2) </div><div class="line">这个递归的时间我们已经很熟悉了：T(n/2) = T(1) * n/4 + T(n/4) + T(1) * n/4</div><div class="line">所以：</div><div class="line">T(N) = (1 + 1/2 + 1/4 + 1/8 + ....) * T(1) 且 1+ 1/2 + 1/4 + ... 收敛。</div><div class="line">因为(1/2)^n数列求和在n趋近于无穷时等于1，所以数列1 + 1/2 + 1/4 + 1/8 + .... =&gt; 2</div><div class="line"></div><div class="line">=&gt; T(N) N趋近于无穷 = 2n*T(1)</div><div class="line">=&gt; 对于N个元素插入操作的总耗时为2n*T(1)，则单个元素的插入耗时为2T(1)</div><div class="line">=&gt; HashMap 的插入时间复杂度为O(1)</div></pre></td></tr></table></figure></p>
<p>照旧附上了代码，里面有额外实现的一些方法，感兴趣的小伙伴可以下载并运行。<br><br>HashMap的简单实现<br><br>
<button onclick="window.open('HashMap.java')">点我下载 HashMap.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>第4天的算法分析</title>
    <link href="https://alex-mengx.github.io/2017/04/02/postAlgorithmAnalysisPrologue/"/>
    <id>https://alex-mengx.github.io/2017/04/02/postAlgorithmAnalysisPrologue/</id>
    <published>2017-04-03T02:58:14.000Z</published>
    <updated>2017-04-10T04:15:46.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AlgorithmAnalysis"><a href="#AlgorithmAnalysis" class="headerlink" title="AlgorithmAnalysis"></a>AlgorithmAnalysis</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>今天我们来聊一聊算法的分析。这一篇算是一篇入门的科普读物，所以我们会尽量减少数学公式，更多地使用描述性的语言来便于大家理解。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>算法分析，就是分析算法的方法。算法是什么大家应该都有所了解。我们通常意义上所说的算法，就是一系列完备的指令，通过这个序列的指令来将输入转化为输出。而算法分析，就是一种分析方法，来判断这个序列的指令所消耗的资源的数量。这里的资源一般指时间和空间，即一个算法所消耗的时间和内存，也就是我们常说的时间复杂度和空间复杂度。</p>
<h3 id="Brute-force"><a href="#Brute-force" class="headerlink" title="Brute-force"></a>Brute-force</h3><p>俗称暴力法。一般来说，对于一个复杂问题，都会有一种自然的简单解决方式，这个方式通常会占用大量的资源，有很高的复杂度。我们来看看例子。如果我们有一个包含了n个数字的数组，我们该如何排序呢？如果不考虑任何的技巧，那么最自然的想法是什么？就像从框里面挑苹果一样，每次都找最小的拿出来就可以了。我们新建一个尺寸为n的数组，然后在原始数组中找最小值，把这个最小值复制到新数组，并且从旧数组中删除。重复这个步骤n次，我们的新数组就会是一个已经排好序的数组了。这个方法简单易懂，从来没有接触过算法的人也能想到。这样的来自生活的方法很大程度上就是暴力的，费时的。再比如，我们需要找寻两个地点的最短路径。直觉的想法是什么？把全部的路径都找出来，然后对比找到最短的。但是在实践中，这是难以接受的，因为对于稍微大量的数据，这些方法的时间消耗会难接受。</p>
<h3 id="Polynomial-time"><a href="#Polynomial-time" class="headerlink" title="Polynomial time"></a>Polynomial time</h3><p>多项式时间。这个概念目前不是很好解释，因为我们对于P和NP以及其他的Complexity class均没有涉及，所以这里稍微介绍一下，不用深究。这个概念是为了和Exponential time分开。多项式时间是实践中可以被接受的时间复杂度，而指数时间是基本上不可以被接受的。抛开公式定义，我们来用简单但是不是十分准确的语言来描述一下。 多项式时间的复杂度，一般是指算法的消耗的时间和样本数量N的关系是多项式关系，即N^k。而指数时间是指消耗时间和N是指数关系，即2^N。</p>
<h2 id="What-is-Big-O"><a href="#What-is-Big-O" class="headerlink" title="What is Big-O"></a>What is Big-O</h2><p>大O表示法是常见的表示算法耗时的方法。其实它就是一个函数，用来表述某个算法的耗时与数量Ｎ的关系。但是要注意，这里的Ｏ()并不是准确的时间函数，而是算法的时间函数的上界。我们先看一下简化的的定义，然后再来仔细描述。<br><code>对于时间函数T(x)，如果有函数f(x)使得x趋近于无穷时有f(x)*常数c &gt; T(x) 则O(f(x))s是时间函数T(x)的上界。</code><br>也就是说，对于某个算法，如果耗时和n的关系在n接近无穷大的时候小于某个函数f(n)和特定常数的乘积，则O(f(n))就是这个算法的时间复杂度。首先先看一个简单的例子。对于一个大小为N的数组，我们要找到这个数组的最小值。这个问题很好解决，对于数组的一次遍历就可以了。对于两个数字的比较所占用的时间是O(1)，那么比较n次的时间消耗就是O(n)。不管n如何增加，消耗的时间一定是与n同比增长，对于任意n趋近于无穷，都有T(n) &lt; n*c，所以O(n)就是这个方法的时间复杂度。我们记得之前在讲递归的时候，我们用斐波那契数列算法举过例子，我们今天就来分析一下这个算法的时间复杂度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// F(n) =   1                   n = 1</div><div class="line">//          0                   n = 0</div><div class="line">//          F(n-1) + F(n-2)     n &gt; 1</div><div class="line"></div><div class="line">int fibonacci(int n) &#123;</div><div class="line">    if (n == 1)</div><div class="line">        return 1;</div><div class="line">    if (n == 0)</div><div class="line">        return 0;</div><div class="line">    return fibonacci(n-1) + fibonacci(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个就是斐波那契的计算方式。我们来拆分一下它的运行过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                                              f(n)</div><div class="line">                          ____________________/ \_____________________</div><div class="line">                         |                                           |</div><div class="line">                      f(n-1)                                      f(n-2)</div><div class="line">                 _______/ \_______                          ________/ \_______</div><div class="line">                |                 |                        |                  |</div><div class="line">              f(n-2)            f(n-3)                   f(n-3)              f(n-4)</div><div class="line">           ____/ \_____       ____/ \_____          ______/ \_____      ______/ \_______</div><div class="line">          |            |     |            |        |             |      |               |</div><div class="line">        f(n-3)      f(n-4)  f(n-4)      f(n-5)    f(n-4)      f(n-5)   f(n-5)          f(n-6)</div><div class="line">                                                。</div><div class="line">                                                。</div><div class="line">                                                。</div><div class="line">f(0)  f(1)  f(0)  f(1)  f(0)  f(1)  f(0)  f(1) ............  f(0)  f(1)  f(0)  f(1)  f(0)  f(1)  f(0)  f(1)</div></pre></td></tr></table></figure></p>
<p>我们观察一下这个运行树。这个树有以下几个特点：</p>
<ol>
<li>第k层的节点数量是2^k。对于f(n)则从第一层开始节点数量依次为 1,2,4,8,16….2^n。</li>
<li>左边依次为n-1, n-2, n-3 … 直到1。</li>
<li>右侧依次为n-2, n-4, n-6 … 直到1或者0</li>
<li>对于最底层，所有的节点都会是f(0)或者f(1)</li>
</ol>
<p>那么很显然，f(0)和f(1)的耗时是常数O(1)。对于f(n)，我们实际的时间消耗是等于树全部叶子节点的O(1)相加再加上n次常数相加的耗时，显然，这个耗时的上限不会超过O(2^n)也就是第n层的节点数量乘以O(1)。<br>通过计算我们可以得到同样的结论。我们用T(n)来表示计算第n个数消耗的时间。对于n等于0和1的情况，算法消耗常数时间，我们将其记为O(1)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">T(0) = O(1)</div><div class="line">T(1) = O(1)</div><div class="line">T(2) = T(1) + T(0) + O(1)</div><div class="line">T(3) = T(2) + T(1) + O(1)</div><div class="line"></div><div class="line">计算f(n)的耗时T(n)实际上包含了三部分：</div><div class="line">1. 计算f(n-1)的时间T(n-1)</div><div class="line">2. 计算f(n-2)的时间T(n-2)</div><div class="line">3. 将f(n-1)和f(n-2)相加的时间O(1)</div><div class="line"></div><div class="line">可推出：</div><div class="line">T(n) = T(n-1) + T(n-2) + O(1)</div></pre></td></tr></table></figure></p>
<p>不需要解出这个公式，我们可以看出对于n这个式子将会有2^n个O(1)操作，既O(2^n)。这就是一个很慢的算法，因为它是exponential的，是程指数函数增长的。<br>我们再来看另一个fibonacci。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int fibonacci(int n) &#123;</div><div class="line">    int fibonacci[] = new int[n+1];</div><div class="line">    fibonacci[0] = 0;</div><div class="line">    fibonacci[1] = 1;</div><div class="line">    for (int i = 2; i &lt;= n; i++) &#123;</div><div class="line">        fibonacci[i] = fibonacci[i-1] + fibonacci[i-2];</div><div class="line">    &#125;</div><div class="line">    return fibonacci[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便，这些实现没有做n的输入检查，这是不好的。不过我们来看时间复杂度吧。这个复杂度很好分析，它只有一个从2到n的for loop，而每个循环的操作的耗时都是常数c，既O(1)。所以这个方法的耗时就是O(n)。但是这个方法的空间消耗要大一些，当n很大的时候，需要建立一个很大的数组,这个算法的空间复杂度也是O(n)。但是，在循环中，我们并不需要数组的全部，我们只需要这个数组的最后三个元素，之前的都可以扔掉。我们来改进一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int fibonacci(int n) &#123;</div><div class="line">    int pfibonacci = 0;</div><div class="line">    int cfibonacci = 1;</div><div class="line">    int nfibonacci = 1;</div><div class="line">    for (int i = 2; i &lt;= n; i++) &#123;</div><div class="line">        nfibonacci = cfibonacci + pfibonacci;</div><div class="line">        pfibonacci = cfibonacci;</div><div class="line">        cfibonacci = nfibonacci;</div><div class="line">    &#125;</div><div class="line">    return nfibonacci;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这下，这个算法的空间复杂度变成了O(1),因为不管输入的N有多大，消耗的空间都是一个特定的常数。</p>
<h2 id="Why-Big-O"><a href="#Why-Big-O" class="headerlink" title="Why Big O"></a>Why Big O</h2><p>我们为什么需要分析算法呢？来看一个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">100*N^100  vs  2^0.001N</div></pre></td></tr></table></figure></p>
<p>假设现在有一个问题，我们有两个解决方法。第一个方法的时间复杂度是O(100N^100)，100乘以N的一百次方，第二个方法是O(2^0.001N)，2的0.001N次方，我们该如何选择呢？<br>在回答之前，我们先来做一个简单的计算。假设现在我们有一个CPU，这个CPU每秒钟可以进行10^9次浮点运算（实际上家用CPU没有这么快，这需要几十GHz的时钟频率）我们来对比一下不同的时间复杂算法对于特定N的耗时吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">我们不去计算具体的数字，我们只列出数量级和单位。</div><div class="line">如果小于1秒钟，我们记做L1(less than 1 second)</div><div class="line">如果时间超过了宇宙年龄，我们就定义一个新的时间单位叫做EOU(end of universe)</div><div class="line"></div><div class="line">N的大小        O(n)        O(nLogn)        O(n^2)        O(n^3)        O(2^n)        O(n!)</div><div class="line">10^1            L1           L1             L1            L1            L1            L1</div><div class="line">10^2            L1           L1             L1            L1            10^22年       10^150年</div><div class="line">10^3            L1           L1             L1            1秒           EOU           EOU</div><div class="line">10^4            L1           L1             L1            10^1分        EOU           EOU</div><div class="line">10^5            L1           L1             10^1秒        10^1天        EOU           EOU</div><div class="line">10^6            L1           L1             10^1分        10^1年        EOU           EOU</div><div class="line">10^7            L1           10^1秒         10^1时        10^2世纪      EOU           EOU</div><div class="line">10^8            L1           10^1秒         10^2天        10^1万年      EOU           EOU</div><div class="line">10^9            1秒          10^1分         10^1年        10^1亿年      EOU           EOU</div></pre></td></tr></table></figure></p>
<p>我们看到了，一个好的算法的能力是多么的强大。当我们使用冒泡排序的时候，几千几万个数字的耗时会很小，跟快排没有直观上的区别，但是当数量级增长到了百万的时候，这个差距就变成了秒和小时。同样，我们说一个算法是Polynomial的是常数项时间的，这是可以接受的，但是对于一个指数时间的算法，通常我们是敬谢不敏的。</p>
<h2 id="常见时间复杂度举例"><a href="#常见时间复杂度举例" class="headerlink" title="常见时间复杂度举例"></a>常见时间复杂度举例</h2><p>最后我们来看几个例子吧。</p>
<h3 id="O-Logn"><a href="#O-Logn" class="headerlink" title="O(Logn)"></a>O(Logn)</h3><p>二叉树的插入和查找，这是典型的二分查找。对于数量N的数组，二分查找最多需要logn次比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">只给出算法，具体实现自己去尝试吧</div><div class="line">对于有序数组A，取范围0-A.length，以[left -right]标示。从数组中查找目标值x</div><div class="line"></div><div class="line">步骤1. 比较[left - right]范围的中间的值和目标值x。如果x小于中间值，则新的范围为left-中间。反之，则新的范围为[中间-right]</div><div class="line">步骤2. 重复步骤一直到找到x或者left大于right</div></pre></td></tr></table></figure></p>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><p>一个数组中找最大值，两个有序数列的合并等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int maxAt(int[] array) &#123;</div><div class="line">    int max = 0;</div><div class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</div><div class="line">        max = max &gt; array[i] ? max : array[i];</div><div class="line">    &#125;</div><div class="line">    return max;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常只需要遍历一次全部数据，耗时增长和n增长同比的算法，就是O(n)</p>
<h3 id="O-nLogn"><a href="#O-nLogn" class="headerlink" title="O(nLogn)"></a>O(nLogn)</h3><p>归并排序。我们后面会拿出一章专门讲排序。</p>
<h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><p>冒泡排序。 这需要用每个元素跟全部N个元素做一次对比，所以耗时是N*N</p>
<h3 id="O-n-3"><a href="#O-n-3" class="headerlink" title="O(n^3)"></a>O(n^3)</h3><p>我们有N个数组int[]。请找到所有不相交的数组。不相交的意思是这两个数组包含的数字完全不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for 每一个数组 S</div><div class="line">    for 所有除了S以外的其他数组 V</div><div class="line">        for V中的每一个元素 e</div><div class="line">            判断e 是否属于 S</div><div class="line">        如果所有V中的e都不属于S，则我们找到了V和S这一对</div></pre></td></tr></table></figure></p>
<p>这个算法就是O(n^3)。首先对于判断数组S是否包含元素e，这需要对S进行遍历，这是一个O(n)操作。这个O(n)的操作要被重复O(n)次，因为我们对于V中的全部元素都要进行这个操作。这就给了我们O(n^2)的时间复杂度。而对于全部N个数组S，我们都要进行一样的操作，于是这就给了我们O(n^3)的复杂度。</p>
<h3 id="O-2-n"><a href="#O-2-n" class="headerlink" title="O(2^n)"></a>O(2^n)</h3><p>暴力破解密码。假设密码全部是数字，且只有6位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void testPassword() &#123;</div><div class="line">    IntStream.range(0, 9).forEach(i -&gt; &#123;</div><div class="line">        IntStream.range(0, 9).forEach(j -&gt; &#123;</div><div class="line">            IntStream.range(0, 9).forEach(k -&gt; &#123;</div><div class="line">                IntStream.range(0, 9).forEach(l -&gt; &#123;</div><div class="line">                    IntStream.range(0, 9).forEach(m -&gt; &#123;</div><div class="line">                        IntStream.range(0, 9).forEach(n -&gt; &#123;</div><div class="line">                            if ((&quot;&quot;+i+j+k+l+m+n).equals(password))</div><div class="line">                                System.out.println(&quot;FIND IT!&quot;);</div><div class="line">                        &#125;);</div><div class="line">                    &#125;);</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于n位密码，每一位我们都要测试0-9十个数字。很明显，两位密码耗时10^2，三位密码耗时10^3，这个算法的耗时是O(10^n)。所以对于密码只包含数字字母和符号的rar压缩包，我们暴力破解的耗时取决于密码长度。常见字符有128个，所以破解密码复杂度为O(128^n)。那么一个四位的密码，耗时大约2秒钟。六位的密码耗时就是大约12小时。八位的密码，耗时要22年。而八位数字密码则只需要一秒钟。所以复杂密码很重要，很重要，很重要。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们讲述了big O 标记的使用方法和基本含义，也介绍了一些常见的时间复杂度和对应的例子。这算是一个好的开始，以后如果有需要，我们会继续写关于算法分析的部分，而实际的分析步骤就需要我们努力去理解一些证明和数学归纳了。下面我们就用归纳法来证明一下斐波那契数的递归算法的复杂度吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">基线 n = 0 明显可知耗时为O(1)</div><div class="line">     n = 1 同样明显可知耗时为O(1)</div><div class="line"></div><div class="line">假设 T(n-1) = O( 2^(n-1) ) </div><div class="line"></div><div class="line">由 F(n) = F(n-1) + F(n-2) 可推出 T(n) = T(n-1) + T(n-2) + O(1)</div><div class="line">=&gt; T(n) = O( 2^(n-1) ) + O( 2^(n-2) ) + O(1) </div><div class="line"></div><div class="line">因为 2^(n-1) + 2^(n-2) &lt; 2^(n-1) + 2^(n-1) = 2 * 2^(n-1) = 2^n</div><div class="line">=&gt; T(n) = O(2^n)</div><div class="line"></div><div class="line">由推论可知 2^n就是这个算法的时间函数的上限，对任意大的n都有2^n / T(n) = 常数c 且c &lt; infinite</div></pre></td></tr></table></figure></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AlgorithmAnalysis&quot;&gt;&lt;a href=&quot;#AlgorithmAnalysis&quot; class=&quot;headerlink&quot; title=&quot;AlgorithmAnalysis&quot;&gt;&lt;/a&gt;AlgorithmAnalysis&lt;/h1&gt;&lt;h2 id=&quot;Abstr
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://alex-mengx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>第3天的BinaryTree遍历之广度优先</title>
    <link href="https://alex-mengx.github.io/2017/03/31/postBFSandQueueStack/"/>
    <id>https://alex-mengx.github.io/2017/03/31/postBFSandQueueStack/</id>
    <published>2017-03-31T22:14:24.000Z</published>
    <updated>2017-04-08T02:19:12.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-traversal"><a href="#Binary-Tree-traversal" class="headerlink" title="Binary Tree traversal"></a>Binary Tree traversal</h1><h2 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h2><p>昨天我们讲了二叉树的深度优先遍历的三种顺序和各自的实现方式。用递归的方式实现的遍历十分的简便。今天我们来尝试两种新的遍历方式。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>今天我们将实现两种遍历方式，一种是深度优先的中序遍历，一种是广度优先的遍历。之前我们已经复习了堆栈和队列的概念，没有看过的小伙伴可以阅读来帮助理解。<a href="https://alex-mengx.github.io/data-structure/2017/03/11/postStackAndQueue/">堆栈和队列</a>。这次的中序遍历将摒弃递归的思想，使用额外的结构和循环来实现。</p>
<h2 id="Depth-first-traversal-with-stack"><a href="#Depth-first-traversal-with-stack" class="headerlink" title="Depth first traversal with stack"></a>Depth first traversal with stack</h2><p>我们来回忆一下中序遍历的逻辑。</p>
<ol>
<li>遍历左边子树。</li>
<li>访问当前根节点。</li>
<li>遍历右边子树。</li>
</ol>
<p>如果是递归，那么这里很好实现，只要反复递归调用这个方法遍历两侧子树就可以。因为二叉树的性质决定了对于当前树使用的方法对于子树也一定适用。但是如果摒除递归的思想，那么我们需要一个新的思路。我们先来画一个二叉树吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 依旧是很眼熟的一棵树。</div></pre></td></tr></table></figure></p>
<p>在没有递归的情况下，我们需要想办法来记录即将访问的节点。我们先来看看中序遍历的顺序。这个树的中序遍历的访问应该从2开始，然后依次是4，6，9 和12。所以我们的遍历应该可以从2开始，也就是树中的最小节点。2访问结束后，我们发现2没有子树，所以我们需要一个结构来记录每一个父节点，这样在访问完左子树之后，我们可以返回父节点继续遍历。我们先来假设我们有一个集合，可以记录任意的节点，来试着手动遍历这个二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">                4  &lt;-  start</div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 4 是整个树的根节点，所以我们的遍历的起始点一定是4。那么我们就将4放入到集合之中。</div><div class="line">4 -&gt; &#123;4&#125;</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">  这里 -&gt;  2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 4是有左侧子树的，所以按照中序的顺序，我们需要先遍历左侧。所以我们将2也放入集合。</div><div class="line">2 -&gt; &#123;2， 4&#125;</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">           ^      /    \  </div><div class="line">           |    6       12</div><div class="line">    左边是null</div><div class="line">// 来到了null，所以前一个节点就是当前子树的最小节点，可以访问了。</div><div class="line">2 &lt;- &#123;4&#125;</div><div class="line">从集合里取出2并访问。同时，试图将2的右子树放入集合</div><div class="line">输出：2</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">           ^      /    \  </div><div class="line">           |    6       12</div><div class="line">    右边是null</div><div class="line">// 2的右边也是null，则2的左右都访问结束，是时候继续返回上层了。</div><div class="line">4 &lt;- &#123;&#125;</div><div class="line">从集合里取出4并访问。同时试图将4的右子树放入集合</div><div class="line">输出：2， 4</div><div class="line">9 -&gt; &#123;9&#125;</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 &lt;-  这里</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 9 的左侧不为null，将左侧放入集合，以保证先访问左侧小节点。</div><div class="line">6 -&gt; &#123;6, 9&#125;</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 </div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">                ^</div><div class="line">            左边是null</div><div class="line">// 与节点2的情况是一样的，左侧为null，所以我们输出6，并且尝试将右侧节点放入集合。</div><div class="line">6 &lt;- &#123;9&#125;</div><div class="line">输出：2， 4， 6</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 </div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">                ^</div><div class="line">            右边是null</div><div class="line">// 右侧也是null，继续从集合里取出上层父节点</div><div class="line">9 &lt;- &#123;&#125;</div><div class="line">输出：2， 4， 6， 9</div><div class="line">取出了9并且访问。同时试图把右侧子树放入集合。</div><div class="line">12 -&gt; &#123;12&#125;</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 </div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">                        ^</div><div class="line">                    左边是null</div><div class="line">// 左边为null，于是当前节点一定是当前子树的最小值。取出12节点并访问。</div><div class="line">12 &lt;- &#123;&#125;</div><div class="line">输出：2， 4， 6， 9， 12</div><div class="line">// 试图将右侧放入集合。右侧为空，试图从集合中取出上层，集合为空，停止遍历。</div></pre></td></tr></table></figure></p>
<p>这个过程中，我们发现当有这个集合，且从集合中取出节点的顺序正确的时候，我们可以通过循环来遍历这个树。通过画图我们验证了非递归遍历的可行性。现在存在的问题有两个：</p>
<ol>
<li>如何保证集合放入节点和取出节点的顺序是我们所需要的？</li>
<li>如何设计条件检查和边界条件来实现循环？</li>
</ol>
<p>我们分别来解决这两个问题。</p>
<h3 id="集合顺序"><a href="#集合顺序" class="headerlink" title="集合顺序"></a>集合顺序</h3><p>我们先把集合所有放入和取出的步骤都拿出来摆在一起看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">4 -&gt; &#123;4&#125;</div><div class="line">2 -&gt; &#123;2， 4&#125;</div><div class="line">2 &lt;- &#123;4&#125;</div><div class="line">4 &lt;- &#123;&#125;</div><div class="line">9 -&gt; &#123;9&#125;</div><div class="line">6 -&gt; &#123;6, 9&#125;</div><div class="line">6 &lt;- &#123;9&#125;</div><div class="line">9 &lt;- &#123;&#125;</div><div class="line">12 -&gt; &#123;12&#125;</div><div class="line">12 &lt;- &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>通过观察，我们发现了一个很有趣的现象：既节点插入的顺序永远是先入后出的。我们来重新走一遍这个放入取出的步骤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">--------------------------</div><div class="line">| 底部                   4    4进入 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                 4 2    2进入 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                   4    2取出 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                        4取出 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                   9    9进入 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                 9 6    6进入 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                   9    6取出 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                   9    9取出 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                  12    12进入 </div><div class="line">--------------------------</div><div class="line"></div><div class="line">--------------------------</div><div class="line">| 底部                  12    12取出 </div><div class="line">--------------------------</div></pre></td></tr></table></figure></p>
<p>是不是很眼熟？有没有恍然大悟？是的，正是堆栈的入栈和出栈的顺序！这样的话第二个问题也就好解决了，只需要判断子树是不是null就可以按照顺序插入或者取出节点。我们来详细看看。</p>
<h3 id="循环的几个条件"><a href="#循环的几个条件" class="headerlink" title="循环的几个条件"></a>循环的几个条件</h3><p>在手动遍历的过程中，我们发现我们需要记录父节点。为了保证中序遍历的顺序，我们又需要从最左边的节点开始遍历。那么我们可以设计这样的逻辑：首先我们假设整个树的根节点已经被放入了堆栈，并且有一个当前节点变量指向根节点。</p>
<ol>
<li>从当前节点开始我们依次将每一个左侧节点放入堆栈，并使当前节点等于其左侧节点，直到当前节点为null。</li>
<li>从堆栈中取出顶端节点，这个节点应该是当前节点的父节点。使得当前节点等于其右节点，这里有两个分支。<ol>
<li>if 右节点不为null，当前节点等于右节点，将右节点放入堆栈并继续步骤1。</li>
<li>else 从堆栈中取出顶端元素，使当前元素等于该元素，并继续步骤2。</li>
</ol>
</li>
</ol>
<p>这样我们的逻辑就有了。停止条件也很简单，当前节点为null且堆栈中没有节点可以取出，就可以结束遍历了。我们来看代码实现。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>上面的逻辑在实现的时候可以通过一些优化和技巧合并一部分，我们来看具体实现，代码中我们会进一步解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static void inOrderWithStack(Node root) &#123;</div><div class="line">    Stack stack = new Stack();</div><div class="line">    Node current = root;</div><div class="line">    stack.push(root); // 堆栈放入根节点，准备进入循环</div><div class="line"></div><div class="line">    while (!stack.isEmpty()) &#123; // 当堆栈为空我们就可以停止了</div><div class="line">        while (current != null) &#123;</div><div class="line">            stack.push(current);</div><div class="line">            current = current.left;  // 这里就是上面逻辑的第一步，一路向左直到null</div><div class="line">        &#125;</div><div class="line">        current = stack.pop(); // 从堆栈中取出顶端节点，这个节点应该是当前节点的父节点。使得当前节点等于其右节点。</div><div class="line">        if (current == null) // 这里为null，则说明我们已经走到了树的最右，可以停止了。</div><div class="line">            break;</div><div class="line">        System.out.print(current.treasure + &quot; &quot;);</div><div class="line">        current = current.right; </div><div class="line">        // 这里其实有两个分支。虽然这里只是使得当前节点等于右子树，但是当进入下一个循环，if current为null，我们进入步骤2.1， else我们进入2.2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，中序遍历就通过堆栈实现了。</p>
<h2 id="breadth-first-traversal"><a href="#breadth-first-traversal" class="headerlink" title="breadth first traversal"></a>breadth first traversal</h2><p>我们再来看看广度优先。对于二叉树来说，广度优先遍历的顺序很清晰，就是逐行访问。用图来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 没错还是这个树。</div><div class="line">我们想要的遍历顺序就是：</div><div class="line">4, 2, 9, 6, 12</div></pre></td></tr></table></figure></p>
<p>这个遍历的顺序是从根节点开始的。主要的思想在于，当我们遍历当前行节点的时候，我们需要一个结构来存储下一行要遍历的节点。因为只有在遍历当前节点的时候，我们才可以获得当前节点的子节点。我们用图来表示一下遍历的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">                4  &lt;- 起始点</div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 按照先左后右将4的子树放入集合</div><div class="line">9, 2 -&gt; &#123;9, 2&#125;</div><div class="line">输出： 4</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9  &lt;- 当前行</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 从集合中依次取出2， 9 并且访问。在取出每一个节点的过程中，将该节点的子节点放入集合。</div><div class="line">12, 6 -&gt; &#123;12, 6&#125; -&gt; 9, 2</div><div class="line">输出： 4， 2， 9</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9  </div><div class="line">                  /    \  </div><div class="line">                6       12  &lt;- 当前行</div><div class="line">// 从集合中依次取出6， 12 并且访问。在取出每一个节点的过程中，将该节点的子节点放入集合。</div><div class="line">&#123;&#125; -&gt; 12， 6</div><div class="line">输出： 4， 2， 9， 6， 12</div><div class="line"></div><div class="line">// 集合为空，遍历结束。</div></pre></td></tr></table></figure></p>
<p>有了之前堆栈的经验，我们很容易就能发现，这个集合放入和取出的规律也很熟悉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">4 -&gt; &#123;4&#125;</div><div class="line">2 -&gt; &#123;2&#125; -&gt; 4</div><div class="line">9 -&gt; &#123;9, 2&#125; -&gt; 2</div><div class="line">6 -&gt; &#123;6&#125; -&gt; 9</div><div class="line">12 -&gt; &#123;12&#125; -&gt; 6</div><div class="line">     &#123;&#125; -&gt; 12</div></pre></td></tr></table></figure></p>
<p>这个集合精确地执行着先进先出的顺序，那么队列在这里就非常的合适。我们来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; void breadthFirst(BinaryTree&lt;T&gt;.Node tree)  &#123;</div><div class="line">    if (tree == null)</div><div class="line">        return;</div><div class="line">    QueueStack.Queue&lt;BinaryTree&lt;T&gt;.Node&gt; queue = new QueueStack().new Queue&lt;&gt;();</div><div class="line">    queue.push(tree);</div><div class="line">    while (!queue.isEmpty())&#123;  // 只要队列不为空我们就继续遍历</div><div class="line">        BinaryTree&lt;T&gt;.Node current = queue.pop(); //从队列中取出当前节点</div><div class="line">        System.out.print(current.treasure + &quot; &quot;); // 访问当前节点</div><div class="line">        Optional.ofNullable(current.left).ifPresent(n -&gt; queue.push(n)); //如果这个节点的子树不为null，则将子树放入队列</div><div class="line">        Optional.ofNullable(current.right).ifPresent(n -&gt; queue.push(n));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>队列的性质决定了在之前的节点没有被全部拿出之前，我们当前放入的节点是绝不会被拿出来的。所以我们将根节点从队列中取出之后，我们按顺序将根节点的左右节点放入了队列。那么在我们取出左节点之前，右节点一定不会被取出。依次递推，我们取出左节点，并将左节点的两个子节点放入队列，那么在我们从队列中取出右节点之前，这两个节点一定不会被取出。这就保证了，每一行最先从队列中被取出的节点一定是当前行最左侧的节点。假设这个最左侧的节点是A，那么A的子节点的放入一定晚于A节点同一行的其他节点，但是一定早于A节点的子节点所在行的其他节点。这也就决定了，在当前行没有遍历完毕之前，我们是不会进入下一行的。这就保证了广度优先遍历的顺序。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们在堆栈和队列的帮助下实现了深度优先的中序遍历和广度优先的逐行遍历。照旧，源代码会贴在下面，感兴趣的朋友可以下载并运行。另外，我们的广度优先遍历只是输出了广度优先遍历的结果。如果我们想单独输出树的每一行，该怎么做？今天的源码中其实包含了这个问题的解答，但是有余力的小伙伴可以试着自己重新思考并且尝试实现。</p>
<p><br>二叉树遍历之二。<br><br>
<button onclick="window.open('BinaryTreeTraversal.java')">点我下载 BinaryTreeTraversal.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binary-Tree-traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree traversal&quot;&gt;&lt;/a&gt;Binary Tree traversal&lt;/
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://alex-mengx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>第2天的BinaryTree遍历之深度优先</title>
    <link href="https://alex-mengx.github.io/2017/03/20/postDepthFirst/"/>
    <id>https://alex-mengx.github.io/2017/03/20/postDepthFirst/</id>
    <published>2017-03-21T01:52:49.000Z</published>
    <updated>2017-03-31T21:52:19.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-traversal"><a href="#Binary-Tree-traversal" class="headerlink" title="Binary Tree traversal"></a>Binary Tree traversal</h1><h2 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h2><p>今天我们来讲一讲二叉树的遍历。遍历意思就是按照某种顺序依次访问每一个节点。对于二叉树，我们有三种常见的遍历方式：前序，中序和后序。这都属于深度优先遍历，除此之外还有广度优先遍历。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>深度优先和广度优先是两种概念不同的思。不仅仅是遍历树或者图，这两种思想还可以用于多种算法。比如深度优先搜索常用于迷宫寻路，拓扑排序等，而广度优先查找则常见于最短路径查找，最大流量路径查找等等。今天我们不会将重点放在这两种搜索方式，而是通过实现二叉树的深度优先遍历，来让大家对于深度优先有初步的认识。在以后的文章中，我们会对拓扑和图进行介绍，之后我们再次尝试对于深度优先和广度优先进行深一步的介绍。</p>
<h2 id="depth-first-traversal-of-binary-tree"><a href="#depth-first-traversal-of-binary-tree" class="headerlink" title="depth-first traversal of binary tree"></a>depth-first traversal of binary tree</h2><p>深度优先遍历，顾名思义，主旨思想在于先尽量走到更深的地方，直到尽头在考虑如何转向其他的路径。就如同走迷宫，这种方式就好比我们沿着入口一侧的墙壁走到底，在返回最后一个分叉口，继续尝试另一个路径。这种方式的关键点在于，在我们走完某个分叉口A一侧的全部子分叉之前，我们不会去尝试A另一侧的分叉。树的深度优先遍历有三种常见的顺序，前序，中序和后序。我们先来看中序，这是相对比较好理解的顺序。</p>
<h3 id="In-order"><a href="#In-order" class="headerlink" title="In-order"></a>In-order</h3><p>二叉树的性质我们应该还记得，如果有比较陌生的小伙伴，建议先看一下这篇<a href="https://alex-mengx.github.io/data-structure/2017/03/01/postBinaryTree/">二叉树</a>来帮助理解。二叉树的重要性之之一就是递归性，每个节点的左右两个子树都是完整的二叉树。另外，插入元素时，小于当前节点的元素会被插入到左边子树，大于当前节点的元素则被插入到右边。所以对于任意一个二叉树而言，树左边的的全部元素都小于根节点元素，右边的的元素则全部大于根节点元素。那么在遍历过程，如果有一种便利的方式是这样的：我先遍历左侧子树，然后访问当前节点，然后在访问右侧子树，那么我访问全部节点的顺序是什么样子的？是的，如果我们打印出来的话，我们会发现我们访问全部的节点的顺序是从小到大的。首先先来看一下逻辑和图来帮助理解。</p>
<ol>
<li>访问左侧子树。</li>
<li>访问当前节点。</li>
<li>访问右侧子树。</li>
</ol>
<p>我们来用这种方式访问一下下面这个二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 很眼熟的一棵树。</div><div class="line">// 首先从根节点开始。</div><div class="line"></div><div class="line">                4 &lt;- 根节点开始</div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">Output：</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">    这里 -&gt; 2       9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 访问左侧子树：4.left</div><div class="line">// 2成为了新的根节点。 重复这个方法，第一步访问左子树，为null，第二部访问当前节点2，打印2， 第三步访问右子树，为null。</div><div class="line">// 2 这个子树已经全部访问完毕，返回4。</div><div class="line">Output：2</div><div class="line"></div><div class="line">                4 &lt;- 访问</div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 访问4。这里完成了4的左侧的访问和4的访问，下一步是4的右侧 4.right</div><div class="line">Output：2, 4</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 &lt;- 这里是新的根节点</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 9这个子树也是一样的访问顺序。先访问9.left</div><div class="line">Output：2, 4</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">        这里 -&gt; 6       12</div><div class="line">// 6和2的情况是一样的，没有子树，访问完6就可以返回9了</div><div class="line">Output：2, 4, 6</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 &lt;- 访问</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 访问9这个节点</div><div class="line">// 现在9的左侧和9都已经访问过了，继续访问9的右侧。</div><div class="line">Output：2, 4, 6, 9</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 </div><div class="line">                  /    \  </div><div class="line">                6       12 &lt;- 访问</div><div class="line">// 访问12的左侧为null，访问12， 访问12的右侧为null。跟2 和6的情况一样。</div><div class="line">Output：2, 4, 6, 9, 12</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 &lt;- 返回</div><div class="line">                  /    \  </div><div class="line">                6       12 </div><div class="line">// 9的右子树全部访问完成，回到了9</div><div class="line">Output：2, 4, 6, 9, 12</div><div class="line"></div><div class="line">                4 &lt;- 返回</div><div class="line">             /    \  </div><div class="line">           2        9 </div><div class="line">                  /    \  </div><div class="line">                6       12 </div><div class="line">// 4的右子树全部访问完成，已经是根节点，输出为最终输出</div><div class="line">Output：2, 4, 6, 9, 12</div></pre></td></tr></table></figure></p>
<p>上面的图给出了依照这个算法遍历树的每一个运行步骤，基本精确到了每行代码。我们按照这个思想来实现一下这个方法。首先这很显然是一个递归的方法。边界条件应该很清晰，就是如果这个节点不为null，则按照上面的三步逻辑来访问，如果为null，则返回上一层调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void inOrder(Node tree) &#123;</div><div class="line">    if (tree == null)</div><div class="line">        return;</div><div class="line">    inOrder(tree.left);</div><div class="line">    System.out.print(tree.treasure + &quot; &quot;);</div><div class="line">    inOrder(tree.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法接受一个二叉树的根节点，并且按照左中右的顺序遍历整棵树。这个实现为了便于理解，行数比较多，后面将使用更简略的方式来实现。</p>
<h3 id="Pre-Order"><a href="#Pre-Order" class="headerlink" title="Pre-Order"></a>Pre-Order</h3><p>前序，跟中序基本一致，唯一的区别就是这种顺序的遍历将会首先访问当前节点，然后是左子树和右子树。来看逻辑：</p>
<ol>
<li>访问当前节点。</li>
<li>访问左侧子树。</li>
<li>访问右侧子树</li>
</ol>
<p>因为跟中序很一致，我们直接看代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void preOrder(Node tree) &#123;</div><div class="line">    System.out.print(tree.treasure + &quot; &quot;);</div><div class="line">    Optional.ofNullable(tree.left).ifPresent(node -&gt; preOrder(node));</div><div class="line">    Optional.ofNullable(tree.right).ifPresent(node -&gt; preOrder(node));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前序的好处是最先访问当前节点而非子树，所以在一些场合会非常合适。最常见的应用就是算式处理。除了常见的算式表达方法，我们还有前缀表达法。比如(3+5)*8，用前缀表达法就是* + 3 5 8，这种方式的语法不需要括号就可以顺利表达操作。写成树的形式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">       *</div><div class="line">     /   \</div><div class="line">   +       8</div><div class="line"> /   \</div><div class="line">3     5</div></pre></td></tr></table></figure></p>
<p>我们用前序遍历一下这个树，得到的结果就是 * + 3 5 8, 树形结构也很清晰的看出来我们计算的是3和5的和乘以8。</p>
<h3 id="Post-Order"><a href="#Post-Order" class="headerlink" title="Post-Order"></a>Post-Order</h3><p>这三种遍历的方式其实就是访问顺序的不同，实际实现起来只需要改动代码的顺序就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; void postOrder(BinaryTree&lt;T&gt;.Node tree) &#123;</div><div class="line">    Optional.ofNullable(tree.left).ifPresent(node -&gt; preOrder(node));</div><div class="line">    Optional.ofNullable(tree.right).ifPresent(node -&gt; preOrder(node));</div><div class="line">    System.out.print(tree.treasure + &quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到，与前序相反，后序的访问则是将对当前节点放到了最后面。这对于表达式的计算其实也很有帮助。我们来看一个稍微复杂一点的表达式树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">       *</div><div class="line">     /   \</div><div class="line">   +       8</div><div class="line"> /   \ </div><div class="line">3     *</div><div class="line">    /   \ </div><div class="line">   5     2</div></pre></td></tr></table></figure></p>
<p>这个式子是 ( ( 5 * 2 ) + 3 ) * 8，如果我们用后序来遍历，结果就是 3 5 2 * + 8 *。这个表达有什么好处呢？我们来看一个神奇的计算方试。首先我们建立一个stack，将这个式子压入stack。遇到数字就压入，遇到操作符号就pop出然后按照符号计算。我们来看看计算顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">式子: 3 5 2 * + 8 *</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                  top</div><div class="line">===========================</div><div class="line"></div><div class="line">step 1: 3 5 2 * + 8 * </div><div class="line">        ^  压入 3</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                    3</div><div class="line">===========================</div><div class="line"></div><div class="line">step 2: 3 5 2 * + 8 * </div><div class="line">          ^  压入 5</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                  3 5</div><div class="line">===========================</div><div class="line"></div><div class="line">step 3: 3 5 2 * + 8 * </div><div class="line">            ^  压入 2</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                3 5 2</div><div class="line">===========================</div><div class="line"></div><div class="line">step 4: 3 5 2 * + 8 * </div><div class="line">              ^  遇到* 操作符，弹出两次</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                    3    -&gt;  5 2 * 计算 5*2 = 10</div><div class="line">===========================</div><div class="line"></div><div class="line">step 5: 3 5 2 * + 8 * </div><div class="line">              ^  上一步得到的结果压入</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                 3 10</div><div class="line">===========================</div><div class="line"></div><div class="line">step 6: 3 5 2 * + 8 * </div><div class="line">                ^  遇到+操作符，弹出两次</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                          -&gt;  3 10 + 计算 3+10 = 13</div><div class="line">===========================</div><div class="line"></div><div class="line">step 7: 3 5 2 * + 8 * </div><div class="line">                ^  上一步得到的结果压入</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                   13</div><div class="line">===========================</div><div class="line"></div><div class="line">step 8: 3 5 2 * + 8 * </div><div class="line">                  ^  压入 8</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                 13 8</div><div class="line">===========================</div><div class="line"></div><div class="line">step 9: 3 5 2 * + 8 * </div><div class="line">                    ^  遇到操作符*，弹出两次</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                          -&gt;  13 8 * 计算 13*8 = 104</div><div class="line">===========================</div><div class="line"></div><div class="line">step 10: 3 5 2 * + 8 * </div><div class="line">                     ^  上一步得到的结果压入</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                  104</div><div class="line">===========================</div><div class="line"></div><div class="line">step 10: 3 5 2 * + 8 * </div><div class="line">                      ^  遇到了式子的结尾，弹出stack</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                          -&gt;  104  结果是104</div><div class="line">===========================</div><div class="line">如果到了式子结尾，这里stack内依然有内容，则表达式有错误。</div></pre></td></tr></table></figure></p>
<p>我们可以看到，实际上这种形式存储的计算式，后序遍历之后通过堆栈压入弹出可以很轻易的进行计算。这种后缀表达式的计算方式逻辑如下：<br>如果遇到数字，压入堆栈。<br>如果遇到计算符号，弹出两次，计算之后将结果压入。<br>重复这一步骤直到式子结束，式子正确的情况下，我们就可以得到式子的正确结果啦。</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>这一章我们介绍了深度优先遍历的三种顺序和常见的应用。中序遍历的输出结果会是按照顺序的，先序和后序则有其他的应用方式。<br>我们来稍微看一下三种便利的输出有什么不同吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    BinaryTree&lt;Integer&gt; intTree = new BinaryTree&lt;&gt;();</div><div class="line">    IntStream.range(0, 20).forEach(i -&gt; intTree.add((int) (Math.random() * 100)));</div><div class="line">    preOrder(intTree.root);</div><div class="line">    inOrder(intTree.root);</div><div class="line">    postOrder(intTree.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Output:</div><div class="line">pre-order: </div><div class="line">90 56 6 3 10 43 14 33 18 27 39 40 50 73 61 87 74 </div><div class="line"></div><div class="line">in-order: </div><div class="line">3 6 10 14 18 27 33 39 40 43 50 56 61 73 74 87 90 </div><div class="line"></div><div class="line">post-order</div><div class="line">3 27 18 40 39 33 14 50 43 10 6 61 74 87 73 56 90</div></pre></td></tr></table></figure></p>
<p>我们可以看到，中序会给出顺序。这也是一种排序的思路，既将全部的数字都插入二叉树，然后中序遍历。耗时分析为：<br>正常情况下，二叉树插入为log n，所以插入全部则是 O(n log(n))。遍历的耗时是O(n)，排序则是O(n log(n))。跟快排，merge排序和堆排序一样。但是二叉树的最好情况就是这样，最差情况下，有顺序的插入会带来n的插入耗时，既全部插入用时O(n^2)，排序总耗时 O(n^2)。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>深度优先就介绍到这里，下一章我们会介绍二叉树的广度优先遍历，并将使用堆栈和队列来实现更多的遍历方式。<br>下面是这一章实现的代码，请感兴趣的同学自取 :-)</p>
<p><br>二叉树遍历之一。<br><br>
<button onclick="window.open('BinaryTreeDepthFirst.java')">点我下载 BinaryTreeDepthFirst.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binary-Tree-traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree traversal&quot;&gt;&lt;/a&gt;Binary Tree traversal&lt;/
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://alex-mengx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>第3天的Stack和Queue</title>
    <link href="https://alex-mengx.github.io/2017/03/11/postStackAndQueue/"/>
    <id>https://alex-mengx.github.io/2017/03/11/postStackAndQueue/</id>
    <published>2017-03-11T06:13:50.000Z</published>
    <updated>2017-04-08T02:27:08.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><p>堆栈与队列</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>今天我们来聊一聊stack和queue。这两个数据结构在很多场合都有很有趣的应用。</p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>堆栈是一个很有趣的结构。还记得我们之前实现的链表LinkedList吗？堆栈stack就可以用链表来实现。我们先来看看堆栈是什么。堆栈是一个先进后出的结构，这个结构中的元素的出入顺序是无法改变的。想象一下手枪的弹夹，假设现在你有一个空的弹夹，在使用之前，你需要一颗子弹一颗子弹的将子弹压入弹夹。那么在上膛之后射击的过程中，你会发现，最先被激发的子弹是最后被压入弹夹的那一颗，而最后被激发的子弹则是第一个被压入的。同时，你并不需要将子弹压满弹夹，只要弹夹里有子弹， 你就可以上膛射击。同样，你也不需要将弹夹打空才能重新压入，只要弹夹有空间，你随时都可以取出弹夹压入新的子弹。这跟堆栈的操作方式是十分类似的。</p>
<h2 id="Stack-Operations"><a href="#Stack-Operations" class="headerlink" title="Stack Operations"></a>Stack Operations</h2><p>堆栈有两个最基本的操作，就是压入push和取出pop，也就是子弹压入push进弹夹，和射击时子弹被弹出pop。我们在链表中实现的操作有插入删除查找和修改，实际上用链表就可以很轻易的实现一个堆栈的结构。我们在这里将使用我们之前创建的LinkedList来实现堆栈。</p>
<h2 id="Stack-Implementation"><a href="#Stack-Implementation" class="headerlink" title="Stack Implementation"></a>Stack Implementation</h2><p>首先来实现一个堆栈的框架。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Stack&lt;E&gt; &#123;</div><div class="line">    LinkedList&lt;E&gt; stack;</div><div class="line">    int currentAmount;</div><div class="line"></div><div class="line">    public Stack () &#123;</div><div class="line">        this.stack = new LinkedList&lt;&gt;();</div><div class="line">        this.currentAmount = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>非常简单，我们需要一个LinkedList来作为存储数据的结构，需要一个currentAmount变量来追踪目前堆栈内的元素的数量。其实如果我们的LinkedList可以实现一个size方法来返回链表中的节点的数量，这样在堆栈中我们就不需要这个currentAmount了，但是因为我们的链表的设计并不完善，我们只好用额外的类变量来记录元素数量。这说明一开始的目标和设计很重要，另外使用现成的轮子也很重要（笑。我们知道，Java中是有List接口(interface)的，实际上正确的做法是使得我们的LinkedList链表implements List接口，这样我们就可以实现全部List所需要的方法了。不过既然链表已经完成了，我们就用这个不完善的链表来实现这个堆栈吧。</p>
<h3 id="Push-and-Pop"><a href="#Push-and-Pop" class="headerlink" title="Push and Pop"></a>Push and Pop</h3><p>入栈，就是将一个元素推入堆栈的方法。这个元素将会成为堆栈最顶端的元素，如果这次入栈之后的下一个操作是出栈pop的话，那么这个元素就会被取出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| 2 | 4 | 1 | 6       &lt;-  push 8</div><div class="line">底端          顶端</div><div class="line">| 2 | 4 | 1 | 6 | 8</div></pre></td></tr></table></figure></p>
<p>原本的堆栈的顶端是6，我们将8推入之后，顶端变成了8。很好理解，就像包装好的桶装羽毛球，装入第二个，第一个就会被压入底部。出栈也是很类似的，当堆栈不为空时，pop就会退出堆栈的顶部元素，并且返回该元素，就如同你从羽毛球筒中拿出了顶部的羽毛球，现在原本排在第二的羽毛球就成为了顶部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| 2 | 4 | 1 | 6 | 8   -&gt;  pop </div><div class="line">底端          顶端</div><div class="line">| 2 | 4 | 1 | 6               return 8</div></pre></td></tr></table></figure></p>
<p>实现也很简单，我们来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void push(E e) &#123;</div><div class="line">    this.stack.add(e);</div><div class="line">    this.currentAmount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E pop() &#123;</div><div class="line">    if (this.currentAmount &gt; 0)&#123;</div><div class="line">        this.currentAmount--;</div><div class="line">        return this.stack.removeFirst();</div><div class="line">    &#125; else return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相比于二叉树，这两个操作的逻辑实在是太简单了。push很好理解，直接将元素e从头部放入链表中，链表本身就会保持元素插入的顺序。pop也很好理解，如果堆栈中元素数量大于零，那么就从链表的头取出一个元素，并且堆栈元素数量减一。</p>
<h3 id="Peek-and-Size"><a href="#Peek-and-Size" class="headerlink" title="Peek and Size"></a>Peek and Size</h3><p>另外堆栈还有两个很有用的方法，一个是查看顶端元素peek，一个是元素数量size。这两个方法可以用来查看但是不移除堆栈的元素，和查看当前堆栈内的元素的数量。当然也可以添加一些辅助性的方法比如是否为空isEmpty，当内部元素数量为0时返回true，反之则返回false。我们来看看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public E peek() &#123;</div><div class="line">    if (isEmpty())</div><div class="line">        return null;</div><div class="line">    </div><div class="line">    E e = pop();</div><div class="line">    push(e);;</div><div class="line">    return e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int size() &#123;</div><div class="line">    return currentAmount;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isEmpty() &#123;</div><div class="line">    return currentAmount == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样,一个简单的堆栈就实现完成了。那么这个堆栈能用来做什么呢？我们一会再说，先看看这篇文章的另一个重点，队列。</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列是一个很有用的结构。在很多复杂的应用中都可以看到它的身影。这个结构跟堆栈有一些类似的地方，也可以用一个链表来实现。跟堆栈不同的是，这个结构的元素的出入顺序是先进先出的。同样，队列中元素的出入顺序是无法改变的，先进入队列的元素一定会先出队列。这个队列我们会从头开始实现，以便加深理解，同时也可以和堆栈的实现方式作对比。</p>
<h2 id="Queue-Operations"><a href="#Queue-Operations" class="headerlink" title="Queue Operations"></a>Queue Operations</h2><p>队列有两个基本操作，进入队列push和从队列中取出poll。顾名思义，push就是将某元素推入队列，poll就是从队列中取出一个元素。除了这两个基本操作之外，跟堆栈一样，isEmpty和size也是很有用的方法。另外peek方法也很有帮助，同样可以查看但是不移除下一个将被拿出队列的元素。因为这一次我们要从头来实现一个队列，所以我们将不借助任何现有的结构。我们先来看看这两个主要的方法，然后再来设计我们该如何实现我们的队列。</p>
<h3 id="Push-and-Poll"><a href="#Push-and-Poll" class="headerlink" title="Push and Poll"></a>Push and Poll</h3><p>这里我们就不多话了，看图吧。push方法：从顶端推入新的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">8 push  -&gt;   2 | 4 | 1 | 6 </div><div class="line">           顶端       底端</div><div class="line">         8 | 2 | 4 | 1 | 6</div></pre></td></tr></table></figure></p>
<p>poll方法：从底端拿出队列中最先进入的元素。注意，所有的元素都是从顶端推入的，且进入队列后顺序不可更改，所以底端的元素一定是目前队列全部元素中最先进入的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">8 | 2 | 4 | 1 | 6 </div><div class="line">  顶端       底端</div><div class="line">8 | 2 | 4 | 1     -&gt;  poll 6</div></pre></td></tr></table></figure></p>
<h2 id="Queue-Design"><a href="#Queue-Design" class="headerlink" title="Queue Design"></a>Queue Design</h2><p>我们看到，队列首先是一个链状的结构。那么我们应该可以使用类似链表的结构来实现。但是我们仔细观察后发现，队列的操作是在两个方向的。换句话说，在堆栈中，我们可以通过操作链表的头来进行push和poll，因为元素只会从一个方向进入或被拿出，但是对于队列，我们需要知道一条链表的头和尾，因为我们将会从一端插入，另一端取出。链表的特性并不能满足这一要求，因为链表只有指向下一个节点的指针，就像在寻宝的过程中，你只能找到下一个藏宝点，而上一个藏宝点的位置已经不可知了。这样的话，如果我们的结构和链表完全一样，则如果每次插入都是在链表头部root节点，那么当我们取出(poll)的时候，我们就需要遍历整条链表。怎么解决这个问题呢？我们有两个选择。</p>
<ol>
<li>我们可以使用array。数组对于某个index位置的读取是O(1)操作，跟数组的元素数量没关系，这会使得队列的入队和出队都是O(1)操作。</li>
<li>我们也可以使用双向链表。双向链表跟链表的区别就是，双向链表每个节点保有两个指针，分别指向前一个和后一个节点。这样我们也能实现O(1)操作，不会影响性能.<h2 id="Queue-Implementation"><a href="#Queue-Implementation" class="headerlink" title="Queue Implementation"></a>Queue Implementation</h2>在这个实现中，我们将使用简化版的双向链表。先来看看大体框架。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Queue&lt;E&gt; &#123;</div><div class="line">    Node top;</div><div class="line">    Node bottom;</div><div class="line">    </div><div class="line">    class Node &#123;</div><div class="line">        E e;</div><div class="line">        Node previous;</div><div class="line">        Node next;</div><div class="line">        </div><div class="line">        public Node(E e, Node previous, Node next) &#123;</div><div class="line">            this.e = e;</div><div class="line">            this.previous = previous;</div><div class="line">            this.next = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Queue() &#123;</div><div class="line">            this.top = null;</div><div class="line">            this.bottom = null;</div><div class="line">            this.size = 0;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们可以看到，很类似链表的结构，只不过我们单个节点有了指向前节点的指针。另外不同于链表只有一个root节点，我们的队列有了top和bottom两个节点，分别指向我们的顶端和底端。我们来继续实现需要的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void push(E e) &#123;</div><div class="line">    this.top = new Node(e, null, top);</div><div class="line">    if (size++ == 0) &#123;</div><div class="line">        this.bottom = top;</div><div class="line">    &#125; else &#123;</div><div class="line">        this.top.next.previous = top;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E poll() &#123;</div><div class="line">    if (size == 0)</div><div class="line">        return null;</div><div class="line">    E e = bottom.e;</div><div class="line">    this.bottom = bottom.previous;</div><div class="line">    if (this.bottom != null)</div><div class="line">        this.bottom.next = null;</div><div class="line">    size--;</div><div class="line">    return e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E peek() &#123;</div><div class="line">    if (size == 0)</div><div class="line">        return null;</div><div class="line">    return bottom.e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int size() &#123;</div><div class="line">    return size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isEmpty() &#123;</div><div class="line">    return size == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>push的操作比较好理解，我们用图来表示这个双向链表来帮助理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">初始为空的队列：</div><div class="line">    top -&gt; null </div><div class="line">    null &lt;- bottom</div><div class="line"></div><div class="line">插入新节点1：</div><div class="line">    top  -&gt;  new Node 1: previous, next -&gt; null</div><div class="line">    null &lt;-                             &lt;- bottom</div><div class="line">    因为之前队列是空的，所以再插入第一个节点之后，top和bottom就都是这个节点了。</div><div class="line"></div><div class="line">插入新节点2：</div><div class="line">    top  -&gt;  new Node 2: previous, next -&gt; node 1 -&gt; null</div><div class="line">    null &lt;-                             &lt;-        &lt;- bottom</div><div class="line">    我们可以看到，插入都是在top进行的。</div></pre></td></tr></table></figure></p>
<p>从图上我们可以看到，插入的新节点都在top。插入的逻辑我们来看代码和图。只要是执行插入一个新节点的操作，我们就使得top等于这个新的节点，然后使这个新节点的next指向旧的top。这样，我们就在队列的顶端放入了一个新的节点。但是还没完，如果我们发现队列是空的，这是第一个节点，那么说明这个点也是底端节点，所以我们使得bottom也等于这个新节点。如果队列不为空，这说明新节点的next指向的旧的top是有节点的，所以我们要使得新节点的next的previous等于新节点。看起来有点绕，但是逻辑是很清楚的。新节点知道自己的next是旧的top。但是旧的top并不知道自己的previous变成了新节点。所以旧的top的previous依旧是null，需要我们来使得它指向新节点。poll的逻辑也是类似的。如果为空，返回null，否则返回底部的元素，并且使bottom指向bottom的前一个元素。这里注意的是，如果bottom不为null，则我们希望设置bottom的next指针为null。如果没有这一步，队列一样可以正常工作，但是在内存中，我们实际上将会保留全部插入过得元素，只有bottom指针的位置在随着poll出元素而改变。这样运行时间长了内存会被占用的越来越多。所以将不在使用的对象赋值成为null，保证没有指针指向可以被销毁的对象，是保证内存低占用的关键之一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">队列： 4，1，7，9，4，3，6</div><div class="line">    top -&gt; 4 -&gt; 1 -&gt; 7 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; null</div><div class="line">    null &lt;-  &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;- bottom</div><div class="line"></div><div class="line">poll: 有设置next = null</div><div class="line">    top -&gt; 4 -&gt; 1 -&gt; 7 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; null       poll 6</div><div class="line">    null &lt;-  &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;- bottom</div><div class="line"></div><div class="line">poll：没有设置next = null</div><div class="line">    top -&gt; 4 -&gt; 1 -&gt; 7 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; null</div><div class="line">    null &lt;-  &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;- bottom</div></pre></td></tr></table></figure></p>
<p>区别很明显，没有this.bottom.next = null的话，从top到bottom的链表会越来越长，没有元素会被删除，只有bottom指针在随着poll不断地向左移动。想象一下我们这个队列是一个系统的消息队列，那么内存占用就会随着消息的传递而越来越大，就算队列表现为空，实际内存占用依然会居高不下，直到出现OutOfMemoryError或者虚拟机停机为止。所以在日常的工作或者学习中，注意内存的合理使用和销毁不必要的对象是很有必要的。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>今天我们实现了队列和堆栈这两种新的数据结构，这两种结构在一些算法的实现中非常常见。明天我们将会介绍一些有趣的问题，并且使用队列和堆栈来解决。</p>
<p><br>惯例，下面是这篇文章实现的队列和堆栈，需要的读者可以尝试运行。<br><br>
<button onclick="window.open('QueueStack.java')">点我下载 QueueStack.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Stack-and-Queue&quot;&gt;&lt;a href=&quot;#Stack-and-Queue&quot; class=&quot;headerlink&quot; title=&quot;Stack and Queue&quot;&gt;&lt;/a&gt;Stack and Queue&lt;/h1&gt;&lt;p&gt;堆栈与队列&lt;/p&gt;
&lt;h1 id=&quot;
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>第2天的BinaryTree</title>
    <link href="https://alex-mengx.github.io/2017/03/01/postBinaryTree/"/>
    <id>https://alex-mengx.github.io/2017/03/01/postBinaryTree/</id>
    <published>2017-03-02T03:57:09.000Z</published>
    <updated>2017-04-08T02:19:12.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Binary tree - a tree with binary branches.<br>在阅读这篇文章之前，如果你对于链表和递归不是很了解的话，建议先阅读一下这两篇文章，他们分别用简单生动的例子描述了递归和链表，对于理解本文会非常有帮助。<a href="https://alex-mengx.github.io/data-structure/2017/02/11/postLinkedList/">第1天的LinkedList</a> <a href="https://alex-mengx.github.io/data-structure/2017/02/24/postRecursive">第1天的递归</a>。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>二叉树，是鼎鼎大名的数据结构。我们之前讲过递归，我们已经理解了递归的含义和作用，二叉树其实也可以用递归的思想来理解。在理解结构之前，我们还是先来用生活的例子来浅尝辄止的接触一下。首先我们来回忆一下链表中那个藏宝和纸条的例子。在那个故事中，每个藏宝点都有一个宝藏和一张写着下一个藏宝点的纸条，而你的手中则掌握着指向第一个藏宝点的纸条。这样的话，只要你始终保有这张最初的纸条，你就总能够找到第一个藏宝点，进而沿着链路一直找到这条链的终点。现在我们来设想一种新的情况。你手中依旧掌握着一张最初的纸条，指向了某个藏宝的地点。然而，这一次，每个藏宝点都有两张纸条，指向了两个不同的藏宝点。你在找寻的过程中，就需要在每一个二叉路口作出决定：“向左走？向右走？”。这就是一颗由藏宝点构成的二叉树。链表有一个特性，就是无论从哪一个点开始访问，这个点向后一直到终点都是一条链表。二叉树有着一样的特性。一个二叉树的结构可以理解为它是由一个根节点和两个二叉树所构成的树。一个二叉树，它的两边的子树是两颗完整的二叉树。就如同宝藏二叉树，无论你站在哪个藏宝点，两张纸条上所标示的地点都是完整的二叉树。递归的特性就在这里体现了出来。针对根节点设计的方法，对于左右两个子树就会同样适用。</p>
<h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>我们来通过修改之前的LinkedList来一步一步的实现这个二叉树。先来看节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Node &#123;</div><div class="line">    E treasure;</div><div class="line"></div><div class="line">    Node left;</div><div class="line">    Node right;</div><div class="line"></div><div class="line">    public Node(E treasure, Node left, Node right) &#123;</div><div class="line">        this.treasure = treasure;</div><div class="line">        this.left = left;</div><div class="line">        this.right = right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到，这个节点跟链表的节点十分的类似，唯一的区别就是多了一个指向其他的节点的指针。这样这个节点就可以存储一份宝藏，同时可以指向另外两个藏宝点。但是，如果这两个藏宝点只是随便指向其他的点，那么我们寻找特定宝藏的时候就会很麻烦，可能需要走遍全部的宝藏才会找到。那么，我们怎样可以使得找寻特定宝藏这个操作变得简单快速呢？这其实就是二叉树的重要特性之一，有序性。在我们从零节点开始创建这个宝藏二叉树的时候，我们的插入就是有目的性的。想象一下，每个藏宝点的宝藏跟它所指向的下两个藏宝点的宝藏都有一定的关系，比如从你能去到的第一点开始，你就发现那里的两张纸条写着“食物向左”和“玩具向右”。如果我们想寻找“棉花糖”这个宝藏，我们就会向左走。左边的节点的两张纸条则是“糖果向左”和“饮料向右”， 我们就需要继续向左。依次深入，我们就会找到我们所找寻的棉花糖。在实际操作中，则可以是数字的大小，字符串的顺序等等。所以，从根节点开始，到任意一个叶节点 - 叶节点就是左右子树都是null的节点，也就是类似链表的终点，只不过这个终点在树中不唯一 - 都是一条完整的链表，链表的元素则是从小到大或者从大到小，或者是其他的某种顺序。所以，树可以被想象成多条链表，只不过相互有重合。现在我们来构建一个树的基本框架，方便我们后面的实现。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class BinaryTree &lt;T extends Comparable&lt;T&gt;&gt; &#123;</div><div class="line">    Node root;</div><div class="line"></div><div class="line">    class Node &#123;</div><div class="line">        T treasure;</div><div class="line">        Node left;</div><div class="line">        Node right;</div><div class="line">        public Node(T treasure, Node left, Node right) &#123;</div><div class="line">            this.treasure = treasure;</div><div class="line">            this.left = left;</div><div class="line">            this.right = right;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        @Override</div><div class="line">        public String toString()&#123;</div><div class="line">            return Optional.ofNullable(left).map(node -&gt; node.toString()).orElse(&quot; &quot;) </div><div class="line">                    + &quot; &quot; + treasure.toString() + &quot; &quot;</div><div class="line">                    + Optional.ofNullable(right).map(node -&gt; node.toString()).orElse(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是我们的树啦。为什么这个树的节点所包含的宝藏要是Comparable呢？我们先回忆一下之前的Java特性那篇文章。<a href="https://alex-mengx.github.io/data-structure/2017/02/17/postJavaProperties/">第1天的Java特性</a> 从这里，我们知道了extends的效果就是使得类可以从父类中继承所有的非私有方法和元素。在我们这棵树中，节点所包含的宝藏的类型是未知的，这样我们就可以装入任何的类型。但是，为了使得树的特性可以表现出来，既装入的元素需要可以判断相互关系。比如数字，比如字符串，或者其他的可以比较的类型。所以，这里的<code>BinaryTree &lt;T extends Comparable&lt;T&gt;&gt;</code>就限制了T必须要是Comparable的子类。也就是说，T必须要实现了T.compareTo(T t)的方法，返回-1,0,1来代表大于等于和小于的关系。这样，我们在放入元素的时候，就可以按照比如小的放左边，大的放右边的规律来插入。我们在实现插入查找之类的方法的时候，就会具体看到有这种关系和规律所带来的便利之处。另外多提一点，因为二叉树是递归的所以左右两侧都是两个完整的二叉树。所以假设我们有二叉树A，根节点包含了数字n，那么A的左边子树所包含的数字一定都小于n，而右边的子树则一定只包含大于n的数字。这条规律同样是递归的，适用于任何一个A的子树。比如对于A的某个右侧的子树n+m，则有n+m的左子树的全部数字都小于n+m，右子树的全部数字都大于n+m。这条推论反之也是成立的，既对于树A所包含的全部数字，小于n的一定在左侧。而子树n+m，这棵子树所包含的数字中小于n+m的数字也一定在子树n+m的左侧。你或许会感到矛盾，n不是也小于n+m吗？可是n作为A的根节点，怎么可能会在n+m这颗子树的左边子树呢？是的，注意n+m所包含的数字合集是远小于A的，n并不在n+m这棵树包含的数字中。只有n+m树所包含的数字，才符合这个逻辑。另外或许你对于这个toString方法很困惑，不要紧，我们先实现别的方法，最后再来看它，到时候你会很容易就理解它。</p>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>插入对于二叉树是很简单的。假设我们要插入数字n，来看逻辑：</p>
<ol>
<li>首先看根节点。如果root是null，则root变成新的Node(n, null,null)，既包含数字n，左右子树皆为null，返回即可。</li>
<li>逻辑分支一：如果能进行到这里，证明root不是null。那么我们来比较n和root.treasure,如果小于，则插入左边的子树。</li>
<li>逻辑分支二：如果n大于root.treasure，则插入右边的子树。</li>
</ol>
<p>重点在这里，我们如果用loop，代码量和判断会比较复杂。如果用递归的思想来解决这个问题，则会简化很多。我们来做一下简单的思维实验和设计。首先我们需要一个方法，这个方法的操作必须要针对一颗二叉树，这样对于子树我们就可以重复调用这么方法。其次我们需要边界判断，在条件满足的时候要停止继续递归深入。我们来先看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void add(T t) &#123;</div><div class="line">    if (t == null)</div><div class="line">            return;</div><div class="line">    if (root == null)</div><div class="line">        root = new Node(e, null, null);</div><div class="line">    else add(t, root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void add(T t, Node root)&#123;</div><div class="line">    if (root.treasure.equals(t))</div><div class="line">        return;</div><div class="line">    if (root.treasure.compareTo(t) &gt; 0)&#123;</div><div class="line">        if (root.left == null)</div><div class="line">            root.left = new Node(t, null, null);</div><div class="line">        else add(t, root.left);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (root.right == null)</div><div class="line">            root.right = new Node(t, null, null);</div><div class="line">        else add(t, root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个add方法只接受一个T作为参数，它更像是一个对外的接口，接受了要插入的元素T之后和跟节点一起传递给我们的递归的add方法。而私有的add方法就是我们的重点了。我们来看看每一行的逻辑。首先是签名，这个方法接受要插入的元素e，和开始插入的根节点root，然后将e插入到root树中合适的位置。在来看这个方法的实现，首先我们需要判断这个根节点root所保存的元素与要被插入的元素t是否相等。因为我们限制了T必需是Comparable的子类，所以T一定有compare这个方法的实现。通过判断，如果root元素与t相等，则我们可以停止插入的动作并且返回，因为我们不想插入同样的元素。继续看下面的代码。如果不相等，则我们需要用conpareTo方法来判断root元素和t的关系，用这个关系来决定t应该被插入哪边的子树。在这个实现中，如果t小于root元素，则我们插入左边。反之则插入右边。再决定了插入哪侧子树之后，我们查看这一侧的树是否是null，如果是null，则新建一个节点，让root的对应的指针指向这个节点。而如果这一侧的树不为null，则我们需要做的事情就是获取这个子树的根节点和t然后找到一个方法可以接受子树的root节点和t，来将t插入到子树合适的位置。由二叉树和递归的特性可以知道，二叉树的子树也是一个完整的二叉树，而子树的根节点就是父节点的某一侧的节点。由此可知，我们实现的add方法，不仅对于根节点root和t有效，应该也对于root.left或者root.right和元素t有效。所以我们可以递归调用<code>add(T t, Node root)</code>方法来实现插入。<br>我们来看一个实际运行的例子。假设我们有数字集合<code>{4,2,9,5,7}</code>，我们来按照代码一步一步的插入这些数字到一个空的二叉树中。<br>插入数字4，add(4)。root为null，所以root = new Node(4, null,null);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    4   // first number, in the root</div><div class="line">  /   \</div><div class="line">null  null</div></pre></td></tr></table></figure></p>
<p>插入数字2，add(2). 因为root 不为 null, 所以我们调用add(4, root)。 进入私有add方法，2小于4，所以2将被插入4的左边的子树。4左边为null，所以建立新的节点new Node(2, null, null)，4的左侧指向新的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">       4   </div><div class="line">     /   \</div><div class="line">    2   null</div><div class="line">  /   \</div><div class="line">null  null</div></pre></td></tr></table></figure></p>
<p>插入数字9，add(9). 因为root 不为 null, 所以我们调用add(9, root)。 进入私有add方法，9大于4，所以所以9将被插入4的右边的子树。4右边为null，所以建立新的节点new Node(9, null, null)，4的右侧指向新的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">            4  </div><div class="line">         /    \  </div><div class="line">       2       9</div><div class="line">    /   \     /   \</div><div class="line">null  null  null  null</div></pre></td></tr></table></figure></p>
<p>插入数字5，add(5). 因为root 不为 null, 所以我们调用add(5, root)。 进入私有add方法，5大于4，所以所以5将被插入4的右边的子树。4右边的子树不为null，我们对5和4的右子树调用add方法。add(5, 9)。5小于9，所以5将被插入9左边的子树。9左边为null，所以我们建立新的节点new Node(5, null, null),使得9的左边指向这个新节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">            4  </div><div class="line">         /    \  </div><div class="line">       2       9</div><div class="line">    /   \     /   \</div><div class="line">null  null   5   null</div><div class="line">           /  \</div><div class="line">        null  null</div></pre></td></tr></table></figure></p>
<p>插入数字7，同样的调用和判断方式，7将被插入5的右侧子树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">            4  </div><div class="line">         /    \  </div><div class="line">       2       9</div><div class="line">    /   \     /   \</div><div class="line">null  null   5   null</div><div class="line">           /  \</div><div class="line">        null   7</div><div class="line">             /   \ </div><div class="line">         null    null</div></pre></td></tr></table></figure></p>
<p>这个例子的讲解比较繁琐和细致，基本体现到了每一行代码的执行过程。这样我们对于二叉树插入操作的递归方式应该就有了具体的了解。接下来我们来看看查找操作。</p>
<h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>查找的代码跟插入十分的类似，基本逻辑是一样的。首先判断根节点的元素是否是查找的目标元素，不是的话就根据查找的目标和根节点的元素的比较关系判断应该向左右两侧哪一侧深入查找，然后用递归的方式查找子二叉树。我们来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean contains(final T t) &#123;</div><div class="line">    if (t == null || root == null)</div><div class="line">        return false;</div><div class="line">    else return contains(t, root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean contains(final T t, final Node root) &#123;</div><div class="line">    if (root == null)</div><div class="line">        return false;</div><div class="line">    if (root.treasure.equals(t))</div><div class="line">        return true;</div><div class="line"></div><div class="line">    if (root.treasure.compareTo(t) &gt; 0)</div><div class="line">        return contains(t, root.left);</div><div class="line">    else return contains(t, root.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与add方法一样，public的contains方法提供了一个接口，并对于根节点root调用了递归的私有contains方法。私有contains方法中递归的边界条件有两个，第一个是找到了尽头，即root等于null，这说明我们按照逻辑判断走到了尽头，依旧没有找到目标元素，则目标元素不存在。第二个边界条件则是当前root节点就包含着目标元素，则我们返回true表示目标元素存在。如果这两个边界条件都不满足，则说明我们目前还没有找到目标元素，我们需要继续向下查找，所以根据大小判断，我们来决定向左侧或者右侧递归深入。这里就不在给出具体例子和逐行代码运行解释了，可以按照上面add方法的例子来自行尝试。</p>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>删除的逻辑就要稍微复杂一点了。因为我们需要在删除了某个节点之后，整个二叉树必须要继续遵循我们订好的规律和要求。之前的例子中为了方便查看我们把为null的子节点也标示了出来，后面的例子将不再标示null。看下图中的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     4  </div><div class="line">  /    \  </div><div class="line">2        9</div><div class="line">       /    \  </div><div class="line">     6       12</div><div class="line">   /  \     /  \</div><div class="line">  5    7   11   14</div></pre></td></tr></table></figure></p>
<p>这颗二叉树是符合我们的逻辑的。即对于每一个节点，以这个节点为根节点的二叉树都符合这样的要求：左边的子树包含的数字一定小于这个根节点，右边的子树所包含的数字一定大于这个根节点。举例来说，我们看到数字9这个节点，那么以这个节点作为根节点的二叉树则包含了<code>{9,6,12,5,7,11,14}</code>这几个数字。那么在9左边的子树包含的数字是6，5和7，全部小于9，而右边子树包含的数字是12,11和14，则全部大于9。对于任意一个节点，这个规定都一定成立。那么当我们需要删除一个节点的时候，会发生什么情况呢？如果我们删除2 ，5，7，11 或者14，那么我们可以直接删除这些节点，因为这些节点在叶子上，它们都没有子节点，所以删除它们不会对树的特性有任何的影响，这棵树依旧会符合我们上述的要求和逻辑。但是如果我们试图删除节点9，那么会发生什么呢？二叉树的特性决定了一个节点如果有子节点，那么这个节点一定不能为空，因为我们需要这个节点的元素来进行比较，进而判断节点左右子树的大小规律。所以如果我们想要删除一个节点，那么我们必须要重新对二叉树的结构进行整理，来保障二叉树的性质不变。继续看图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     4  </div><div class="line">  /    \  </div><div class="line">2        删除9这个节点</div><div class="line">       /    \  </div><div class="line">     6       12</div><div class="line">   /  \     /  \</div><div class="line">  5    7   11   14</div></pre></td></tr></table></figure></p>
<p>我们需要一个方法来从9的子树之中选出合适的数字填在被删除的节点的位置。具体做法我们后面来讲。现在我们来总结一下删除节点可能会遇见的几种情况：</p>
<ol>
<li>删除的节点没有子节点。</li>
<li>删除的节点有一个子节点。</li>
<li>删除的节点有两个子节点。</li>
</ol>
<p>我们来依次看这三种情况吧。</p>
<h5 id="1-没有子节点的情况。"><a href="#1-没有子节点的情况。" class="headerlink" title="1. 没有子节点的情况。"></a>1. 没有子节点的情况。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">// 删除数字7</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /        /  \</div><div class="line">             5        11   14</div></pre></td></tr></table></figure>
<p>直接删除就可以了，6.right = null; 对于树的结构没有影响。</p>
<h5 id="2-有一个子节点的情况"><a href="#2-有一个子节点的情况" class="headerlink" title="2. 有一个子节点的情况"></a>2. 有一个子节点的情况</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                7       12</div><div class="line">              /        /  \</div><div class="line">             6        11   14</div><div class="line">           /   \</div><div class="line">          5     8</div><div class="line"></div><div class="line">// 删除数字7</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /   \</div><div class="line">             5    8   11    14</div></pre></td></tr></table></figure>
<p>如果只有一个子节点，那么只要将子节点的整个树都放在被删除的节点的位置就可以了。这是因为，由于二叉树的性质，节点7由于在9的左侧，所以以7为根节点的树的全部元素都一定小于9，所以只要拿走7，并将7唯一的子节点放在7的位置上，这样二叉树就会保持原有的性质。</p>
<h5 id="3-有两个子节点的情况"><a href="#3-有两个子节点的情况" class="headerlink" title="3. 有两个子节点的情况"></a>3. 有两个子节点的情况</h5><p>这个情况就会复杂一下，需要一些变换。依旧可以依靠递归的思想来解决问题。先来说一下基本逻辑：假设要被删除的节点为N，N节点有左右两个子树，则我们需要从子树中找到合适的数字来放在这个被删除的节点N。对于有两个子节点的情况，我们实际上不需要真的删除这个节点，我们可以替换节点中的数字。为了保证节点N左边的子树的数字都小于这个新数字，右边的子树的数字都大于这个新数字，我们有两个选择。我们可以从左树中找到最大的数字，或者从右树中找到最小的数字，放在N节点，这样的话N节点左右的子树就会依旧保证遵循同样的规律。但是用数字替换了N节点之后，子树中就出现了重复的数字，我们需要删除这个数字。我们可以用递归的思想，从子树中删除这个数字。我们用图像来看看两个节点的删除方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">// 删除数字9</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        7 // 在这个例子中我们将使用左树最大值来代替被删除的节点。</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">// 用同样的方法删除7， 7没有子节点，则情况1的逻辑适用。</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        7</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /        /  \</div><div class="line">             5        11   14</div></pre></td></tr></table></figure></p>
<p>从这个例子中我们可以看到双子节点的删除逻辑。</p>
<p>上面这三种类型就是删除节点的三种情况，我们来看代码如何实现这些逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public void remove(final T t) &#123;</div><div class="line">    root = remove(t, root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Node remove(final T t, final Node root) &#123;</div><div class="line">    if (root == null)</div><div class="line">        return null;</div><div class="line">    else if (root.treasure.compareTo(t) &gt; 0)</div><div class="line">        root.left = remove(t, root.left);</div><div class="line">    else if (root.treasure.compareTo(t) &lt; 0)</div><div class="line">        root.right = remove(t, root.right);</div><div class="line">    else if (root.left != null &amp;&amp; root.right != null)&#123;</div><div class="line">        root.treasure = findMax(root.left);</div><div class="line">        root.left = remove(root.treasure, root.left);</div><div class="line">    &#125; else return root.left == null ? root.right : root.left;</div><div class="line">    return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private T findMax(Node root) &#123;</div><div class="line">    if (root.right != null)</div><div class="line">        return findMax(root.right);</div><div class="line">    return root.treasure;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>public的remove方法是一样的，是递归方法的入口。私有的findMax方法也很好理解，因为所有的节点都遵循大的数字放右边的规律，所以只需要一直向右走到尽头，该节点的数字就是这棵树的最大数字。代码的逻辑就是：如果右树不为空，则递归调用这个方法来获取右树的最大值。如果右树为空，则这个节点的数字就是最大数字，因为所有的左树的数字都小于根节点。来看这个私有的remove方法，这个方法的逻辑就稍微复杂了一点。为了简化逻辑和代码，我们用返回节点的方式来递归。这个方法接受一个元素和一个二叉树的根节点，然后返回去除了元素的二叉树。注意，这个方法是针对一个完整的二叉树设计的，也就是说只要给出元素t和二叉树的根节点root，这个方法就应该返回删除了t元素之后的二叉树。首先判断root是否为null，如果为null，说明这一个二叉树为空，我们可以直接返回null来代表这个空的二叉树。继续判断元素t和当前root.treasure的关系，t小则t有可能存在于root的左子树，反之则说明t可能会在root的右子树。之所以说t可能存在于子树，是因为也许当前树不包含t这个元素。继续往下看，确定了应当找寻的方向之后，我们需要一个方法来从子树中删除元素t，所以我们用递归的方式调用remove方法本身，且让root.子树 = remove(t, toot.子树)。remove会返回删除了元素t的二叉树，所以root.left = remove(t, root.left)或者root.right = remove(t, root.right) 就会让root的子树成为去除了元素t的二叉树。这里的逻辑稍微有点复杂，我们再来重新观察一下。首先，remove方法接受元素t和一个二叉树，然后返回删除了元素t的二叉树。所以，当root这棵树的左树包含了t，那么我们就可以使得root.left 等于remove(t, root.left)，这样root的左树就会成为删除了元素t的二叉树。让root的子树等于删除了元素t的二叉树之后，就可以返回root了，只不过我们把return root放在了最后一行。继续向下看，如果root.treasure既不大于t也不小于t，这说明当前节点就是包含了元素t的节点。那么，我们的三种情况就适用于这里了。如果左树和右树都不为null，那么我们应用第三种方法，我们使得当前root节点的元素等于左树的最大值，来保证二叉树的特性不被破坏，然后从root的左树中删除这个最大值。这里依旧递归调用remove(max_in_left, root.left)。如果左树或者右树有一个树为null，那么第二种情况就适用于这里，我们可以直接返回不为null的那个树。因为上一层的调用会使得对应的父节点的子树等于我们这一层返回的这颗树，那么这一层的root节点就会被删掉。大概逻辑是这样的：第一层 A.child = remove(n, A.child) -&gt; 第二层 return A.child.child -&gt; 第一层 A.child = A.child.child。这样，包含了目标元素t的A.child就会被删除。这就是删除的逻辑了。重点在于删除节点的三种不同的情况，和如何递归调用remove方法。</p>
<h3 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h3><p>我们已经有了contains，remove和add方法，所以修改就变得十分的容易了。直接看代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void modify(T oldT, T newT)&#123;</div><div class="line">    if (oldT == null || root == null || oldT.equals(newT))</div><div class="line">        return;</div><div class="line">    if(newT == null)</div><div class="line">        remove(oldT);</div><div class="line">    else if (contains(oldT))&#123;</div><div class="line">        remove(oldT);</div><div class="line">        add(newT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>旧值和新值，如果旧值在树立，那么就删除旧值，插入新值。当然，效率并不高，读者可以自行实现一个修改的方法 :-)</p>
<h2 id="Conclution-and-More"><a href="#Conclution-and-More" class="headerlink" title="Conclution and More"></a>Conclution and More</h2><p>在一开始的Node代码中，我们有一个toString的方法，如果你尝试调用的话，你会发现这个方法会按照从小到大的顺序打印出树中的全部数字或者元素。我们把代码拿出来单独看一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String toString()&#123;</div><div class="line">    return Optional.ofNullable(left).map(node -&gt; node.toString()).orElse(&quot; &quot;) </div><div class="line">            + &quot; &quot; + treasure.toString() + &quot; &quot;</div><div class="line">            + Optional.ofNullable(right).map(node -&gt; node.toString()).orElse(&quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法直接来看有点复杂，我们先来变形一下以便于理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void print(Node root) &#123;</div><div class="line">    if (root == null)</div><div class="line">        return;</div><div class="line">    print(root.left);</div><div class="line">    System.out.print(&quot; &quot; + root.treasure);</div><div class="line">    print(root.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就会容易很多。print接受一个二叉树，然后打印出该二叉树的全部数字。逻辑很简单，打印左侧子树，然后打印root节点，然后打印右侧子树。我们来看看实际运行的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(final String[] args) &#123;</div><div class="line">    final BinaryTree&lt;Integer&gt; bTree = new BinaryTree&lt;&gt;();</div><div class="line">    IntStream.range(0, 20).forEach(i -&gt; bTree.add((int)(Math.random()*20)));</div><div class="line">    bTree.print(bTree.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// output :  0 1 5 7 8 10 13 14 15 16 17 18 19</div></pre></td></tr></table></figure></p>
<p>main方法中，我们对bTree进行了二十次插入操作，每次插入的数字都是介于0到20之间，所以实际插入的数字和个数都不确定。然后我们调用print方法来打印。因为打印方法是打印出左侧子树，然后打印根节点，最后打印右节点，所以打印出来的数字是有序的，按从小到大的顺序打印。因为递归调用的原因，当我们打印左侧子树的时候，我们实际上会尝试打印左侧子树的左侧子树，直到左侧是null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">打印的顺序是左，中，右。所以输出是 2,4,5,6,7,9,11,12,14</div></pre></td></tr></table></figure></p>
<p>这下toString方法也很好理解了吧？我们其实就是把左侧子树变成String，然后加上根节点的元素的String形式，再加上右子树。这样toString对于根节点调用返回的就是一个从小到大包含了全部数字的字符串。<br>以左，中，右的顺序访问这个树，就是传说中的中序。相应的，我们可以轻易地修改这些方法，改变访问的顺序。中，左，右的顺序就是先序，左，右，中的顺序就是后序。不同的访问方式，打印出来的元素的排列方式也是不相同的，感兴趣的小伙伴可以自行尝试。</p>
<p>另外，现在我们已经知道二叉树是一层一层的结构了，那么我们怎样可以按行来打印出二叉树的元素呢？比如对于上面这棵树，我们如何打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line">2 9</div><div class="line">6 12</div><div class="line">5 7 11 14</div></pre></td></tr></table></figure></p>
<p>这样的形式呢？下面的代码中我写出了答案，感兴趣的小伙伴也可以下载查看。当然，愿意自己思考并且尝试的话，就更好了。不过这需要我们认识一种新的数据结构，在下一篇文章中，我们将会讲一讲queue和stack，和它们可以应用的场景和算法。</p>
<p><br>下面是这篇文章实现的二叉树，需要的读者可以尝试运行。<br><br>
<button onclick="window.open('BinaryTree.java')">点我下载 BinaryTree.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binary-Tree&quot;&gt;&lt;a href=&quot;#Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree&quot;&gt;&lt;/a&gt;Binary Tree&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot;
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>第1天的递归</title>
    <link href="https://alex-mengx.github.io/2017/02/24/postRecursive/"/>
    <id>https://alex-mengx.github.io/2017/02/24/postRecursive/</id>
    <published>2017-02-25T04:44:46.000Z</published>
    <updated>2017-04-08T02:19:13.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>这是我们遇到的第一只拦路虎。这只名为‘递归’的大猫看似凶残，不少人因之望而却步。然则征途伊始，怎可不战便退？让我们试着化繁为简，用简单的语言和例子来理解这个概念，再以简驭繁，用这个看似简单的概念来解决复杂的问题吧！</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>递归 (Recursion) 是解决一些特定的复杂问题的常见方式之一。它之所以广受欢迎，不仅是因为它能够细分问题，将复杂问题抽丝剥茧般层层剥离，更是因为其独特的思维方式跳出了线性思维的禁锢。 让我们先从简单的问题入手吧。</p>
<h3 id="What-is-recursion"><a href="#What-is-recursion" class="headerlink" title="What is recursion?"></a>What is recursion?</h3><p>递归不是一种具体的事物。它不是某一类的算法，也不是某一类语言的特性，更不是数据的结构。它是思维的方式，是解决问题的手段，是审视问题的另一个角度。它帮助你在纷杂的逻辑中另辟蹊径，能让你在斑驳的代码里游刃有余。那么，它到底是什么呢?<br>在理解递归之前，我们需要先理解什么是函数。首先，函数这个概念大家应该都有所耳闻。函数是一个对应的方式，所描述的是两个合集之间的映射关系。比如<code>{1，2，3，4，5，6...}</code>这个合集所包括的就是自然数。而函数<code>f(x) = 2x</code>所描述的，就是自然数合集和偶数合集的关系。用合集的形式写出来就是 <code>{1,2,3,4,5,6...} -&gt; f(x) = 2x -&gt; {2,4,6,8,10,12...}</code>这个函数所描述的关系非常简单，对于自然数合集中的每一个元素，偶数合集之中都有一个数字是该元素的两倍。<br>题外话：是的，自然数合集所包含的数字的数量，和偶数合集所包含的数字的数量是相等的。这看似反直觉，但是可以通过数学证明推导。<br>回到主题。简单的函数很好理解,给一个输入就会有一个输出，还是用上面的例子来帮助理解。我们看这个数列:<code>{1,3,5,7,9,11....}</code>注意这是一个数列，而不是一个数组，它的位置是从1开始的。我们可以看到数字和它所在的位置有很清楚的关系。用n来表示第n个数字，那么第一个数字是1，第二个数字是3，第三个数字是5，以此类推。不需要拼凑公式，我们通过经验也可以知道，这组数的第n个数字一定是 <code>f(n) = 2n-1</code>。我们就可以说，这个函数描述了自然数数列1,2,3…和奇数数列1,3,5…的映射关系。现在我们对于函数有了很清晰的认识，我们可以来看递归了。</p>
<p>什么是递归呢？一个函数调用自身的过程，就是递归。听起来很不明所以吧？我们来详细的挖掘一下这句话的意思。依旧用一组数字来作为例子。<code>{0,1,1,2,3,5,8,13,21,34...}</code>这个数列叫做 斐波那契数列（Fibonacci number）。那么这个数列的数字和它的位置有没有关系呢？通过观察，我们发现了这个数列的每一个数字，都等于它前两个数字的和。用函数公式来表达 <code>f(n) = f(n-1) + f(n-2)</code>。 只要知道第一个和第二个数字分别是0和1，那么我们就可以通过这个函数得知，f(3) = 0 + 1 = 1，f(4) = f(3) + f(2) = 1 + 1 = 2。以此类推。这个函数我们通过观察，可以看到它有一个很明显的特点，就是它调用了自身。也就是说，自然数数列作为一个合集，和斐波那契数列这个合集的映射关系不是线性的关系，而是与其自身相关。我们把这个特点抽象出来，就会发现，这是一类问题的共通之处。</p>
<h3 id="Why-recursive"><a href="#Why-recursive" class="headerlink" title="Why recursive?"></a>Why recursive?</h3><p>通常，递归可以有效的表达解决问题的逻辑。虽然不会减少甚至可能增加复杂度，但是它可以有效的减少键盘敲击的数量（笑。当然，很多时候它可以帮助我们理清思路，减少不必要的复杂代码。我们再来看几个简单的例子。</p>
<h4 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// F(n) = F(n-1) + F(n-2)</div><div class="line"></div><div class="line">int fibonacci(int n) &#123;</div><div class="line">    return fibonacci(n-1) + fibonacci(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在就有了一个可以计算fibonacci数的函数。只要调用fibonacci(n)， 我们就可以计算第n位的fibonacci数字。但是当我们尝试调用的时候，却发现这个函数无法退出，直到出现了StackOverflowError。这是因为，这个函数没有终点，会一直尝试对n－1和n－2进行调用，直到溢出。那么我们该怎么改进呢？很简单，只需要给定一个结束的条件就可以了。但是，这个结束的条件并不是针对函数的流程，而是针对n本身。原因很简单，这个函数会被运行很多次，我们无法通过流程判断，但是n可以告诉我们结束的正确时机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// F(n) =   1                   n = 1</div><div class="line">//          0                   n = 0</div><div class="line">//          F(n-1) + F(n-2)     n &gt; 1</div><div class="line"></div><div class="line">int fibonacci(int n) &#123;</div><div class="line">    if (n == 1)</div><div class="line">        return 1;</div><div class="line">    if (n == 0)</div><div class="line">        return 0;</div><div class="line">    return fibonacci(n-1) + fibonacci(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，这个程序现在就不会stack over flow了。我们来画个递归树来看一下运行过程。画树是分析算法复杂性的常用方式，以后我们会专门详细解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">为了方便，我们把 fibonacci 简写成 f， 我们来看看f(5)是怎么运行的</div><div class="line">                                                  f(5)</div><div class="line">                                __________________/ \_____________________</div><div class="line">                               |                                          |</div><div class="line">                              f(3)                                       f(4)</div><div class="line">                       _______/ \_______                         ________/ \_______</div><div class="line">                      |                 |                       |                  |</div><div class="line">                     f(1)              f(2)                   f(2)                f(3)</div><div class="line">                                   ____/ \_____          ______/ \_____      ______/ \_______</div><div class="line">                                  |            |        |             |      |               |</div><div class="line">                                 f(0)         f(1)     f(0)          f(1)   f(1)            f(2)</div><div class="line">                                                                                        ____/ \_____</div><div class="line">                                                                                       |            |</div><div class="line">                                                                                     f(0)         f(1)</div></pre></td></tr></table></figure></p>
<p>通过这个树，我们可以很清晰的看到这个函数自我调用的过程。在这里我们不去深究这个函数的复杂度，只对于耗时稍加讨论。一般来说，我们习惯用字母<code>T</code>来表示时间，所以这个函数对于f(5)的耗时可以表达成为T(5)。通过观察可得知，T(5) = T(3) + T(4) + 1。 1是在得到了f(3)与f(4)之后的相加操作，因为是对常量的操作，所以耗时为1，写作O(1)。不要太过于纠结T和O的含义，以后我们会详细说明。追寻到底，我们可以发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(5) = f(1) + f(0) + f(1) + f(0) + f(1) + f(1) + f(0) + f(1) = 8</div></pre></td></tr></table></figure></p>
<p>具体时间复杂度就不在画树了，同样是对于所有叶子节点的累加。通过这个例子，我们发现，递归可以有效地减少代码数量，并且逻辑很清晰。但是缺点也同样明显，观察运行树，可以发现f(3)的值被重复计算了两遍，f(2)的值被重复计算了三遍。随着n的增加，重复计算的分量以N^2的速度增加。这就是为什么明明fibonacci的耗时可以是O(n)，但是递归算法的耗时是O(n^2)。</p>
<h3 id="Factorial"><a href="#Factorial" class="headerlink" title="Factorial"></a>Factorial</h3><p>阶乘是另一个非常助于理解递归的例子。我们来写一下阶乘的函数。<code>f(n) = n * (n-1) * (n-2) * ... * 2 * 1</code>，一目了然，n的阶乘就是从n乘到1的结果。那么，这个函数怎么写可以简单一点呢？我们来变化一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f(n) = n * (n-1) * (n-2) * ... * 2 * 1 = n!</div><div class="line">f(n-1) = (n-1) * (n-2) * ... * 2 * 1 = (n-1)!</div><div class="line"></div><div class="line">==&gt; f(n) = n * (n-1)! = n * f(n-1)</div></pre></td></tr></table></figure></p>
<p>是不是看起来很眼熟？是的，这里也可以用递归的方式来计算阶乘。n的阶乘，就是n和(n-1)的阶乘的乘积。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int factorial(int n) &#123;</div><div class="line">    if (n == 1)</div><div class="line">        return 1;</div><div class="line">    return n * factorial(n-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的边界条件很简单，等于1的时候就是1。这样，这个函数就可以通过调用自身来计算n-1的阶乘，从而计算出n的阶乘。不同于斐波那契数，这个阶乘的递归算法不仅不会增加时间复杂度，逻辑也更加清晰明了。这是因为再一次调用中，它只对自身进行了一次调用，而斐波那契算法则对自身调用了两次。</p>
<h2 id="More-Problems"><a href="#More-Problems" class="headerlink" title="More Problems"></a>More Problems</h2><p>通过上面的介绍，我们已经理解了递归的原理和逻辑，同时对于适用的一类问题有了一些基本的了解。现在让我们来看一看稍微复杂一点的问题吧，看看递归能给我们带来怎样的便利。</p>
<h3 id="GCD-Greatest-Common-Divisor"><a href="#GCD-Greatest-Common-Divisor" class="headerlink" title="GCD Greatest Common Divisor"></a>GCD Greatest Common Divisor</h3><p>寻找两个数字的最大公约数。这个问题直觉上来说最容易想到的办法就是挨个试。比如我们想找1000和300 的最大公约数，我们就可以从两个数字中的较小的数字开始向下寻找。如果两个数字都可以被300除尽，那么300就是最大公约数，不可以的话，就试试299.以此类推，直到2，如果都找不到，说明最大公约数是1。 但是对于大数字，这个办法耗时良久且效率低下。<br>那么，可不可以给力一点呢？<br>可以的，我们可以为这两个数分别列举出来它们全部的约数，然后在两个合集的交集之中寻找最大值。这样的好处是不用一个一个数字尝试，但是缺点也很明显，列举出全部约数并不是一件容易的事情。比如20，2<em>3</em>4=20，但是2*10也等于20， 2,3,4,5,10,20 都是20的约数。所以我们要化简到最小素数乘积，然后找最大的共同素数乘积。<br>那么。可不可以在给力一点呢？<br>我们来借助一下古人的智慧吧。西汉末年，有奇书记载了一种计算约数的方术，名曰“更相减损术”。术云:</p>
<blockquote>
<p>可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。</p>
</blockquote>
<p>又有合分术曰：</p>
<blockquote>
<p>母互乘子，并以为实，母相乘为法，实如法而一。不满法者，以法 命之。其母同者，直相从之。</p>
</blockquote>
<p>从九章算术中的记载，我们可以看到求最大公约数的简便方法。稍微解释一下。可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。 这句话的意思就是，两个数，我们用大数除以小数，大数整除的部分不要，只保留余数。之后，用小数除以保留的余数，整除部分不要，只保留余数。更相交替计算，一直到没有余数，可以整除，那么这个除数就是两个数字的最大公约数了。我们用1000和300举例。mod 运算就是求余的意思，1000 mod 300 = 100,300 mod 100 = 0， 所以100就是1000和三百的最大公约数。我们先来列一下函数看看逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g(n,m) = m              if n % m == 0</div><div class="line">         g(m, n % m)    if n % m != 0</div></pre></td></tr></table></figure></p>
<p>逻辑很清楚，小数能被大数整除，小数就是最大公约数，不能被整除，那么大数除小数取余，就是新的小数，原本的小数就变成了大数。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int gcd(int big, int small) &#123;</div><div class="line">    if (big % small == 0)</div><div class="line">        return small;</div><div class="line">    return gcd(small, big % small);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重点在于大小数取余之后位置的交换。另外，这个算法每一次迭代都会计算两次取余，我们来修改一下优化一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int gcd(int big, int small) &#123;</div><div class="line">    if ( small == 0)</div><div class="line">        return big;</div><div class="line">    return gcd(small, big % small);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的话，我们只需要计算一次取余，效率瞬间飙升了一倍。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们复习了递归的原理，用简单的例子解释了递归的特性。总体来说这篇博文比较容易理解，也没有复杂的问题。等到后面我们讲完二叉树和简单的算法分析，我们再试着用递归解决一些更复杂的问题吧。</p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Recursion&quot;&gt;&lt;a href=&quot;#Recursion&quot; class=&quot;headerlink&quot; title=&quot;Recursion&quot;&gt;&lt;/a&gt;Recursion&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://alex-mengx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>第1天的Java特性</title>
    <link href="https://alex-mengx.github.io/2017/02/17/postJavaProperties/"/>
    <id>https://alex-mengx.github.io/2017/02/17/postJavaProperties/</id>
    <published>2017-02-18T04:29:42.000Z</published>
    <updated>2017-03-02T02:31:36.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-encapsulation-inheritance-polymorphism"><a href="#Java-encapsulation-inheritance-polymorphism" class="headerlink" title="Java encapsulation inheritance polymorphism"></a>Java encapsulation inheritance polymorphism</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>java是一门面向对象的语言，讲究封装继承和多态。不要被这些名字吓到，通过阅读本文，你应该会对这些概念有更直观的理解。本文会试着举出一些有趣而准确地例子帮助你接受并了解面向对象语言的一些共通的特性。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>面向对象是设计模式的一种。为了避免陷入到堆砌专业名词而使得初学者难以理解的困境中，我们暂且不对设计模式进行解释。对于特性的名字也不必要去钻牛角尖，通过例子会有直观的感受，这比强行记住佶屈聱牙的定义要容易且有效很多。作为程序员，我们的准则就是高效且准确，所以就让我们进入到Java的世界，用代码和例子来代替文字定义吧。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>首先我们来通过例子理解封装，继承和多态的大概含义。这些概念之间有着密切的相互联系，让我们一个一个慢慢来看。</p>
<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>封装，顾名思义，把内部的东西包裹起来，封住具体的细节，只保留必要的接口。这既是出于安全角度考虑，同样也会使得开发的过程变得不易出错且易于修改。为什么封装会有这样的效果呢？我们来举例说明吧。<br>想象一台ATM取款机，这个取款机就是一个封装的很好的系统，我们只能通过操作界面(interface)来操作。现在我们把这个取款机当做一个Java的类，然后把取款机的方法列举出来看看我们都有什么。取款机最基本的功能就是输入密码取钱存钱， 我们先无视掉别的功能，来写一个Java的类实现输入密码取钱存钱的功能，并且来看看封装能带来什么好处。为了简化这个模型，我们假设你是一个超级重要的VIP客户，银行在你家里设立了一台定制的ATM取款机，这个ATM只有你一个人可以使用，里面只保存了你一个人的信息，只要输对了密码就能取钱，里面也只有你一个人的余额信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ATM &#123;</div><div class="line">    public String password = &quot;p@ssw0rd&quot;;</div><div class="line">    public int balance = 0;;</div><div class="line"></div><div class="line">    public ATM() &#123;&#125;</div><div class="line"></div><div class="line">    public void withdraw(String password, int howMuch) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            if (balance &gt; howMuch) &#123;</div><div class="line">                balance -= howMuch;</div><div class="line">                System.out.println(&quot;Withdraw &quot; + howMuch + &quot;, you have remaining balance &quot; + balance);</div><div class="line">            &#125; else</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void save(String password, int howMuch) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            balance += howMuch;</div><div class="line">            System.out.println(&quot;Save &quot; + howMuch + &quot;, you have remaining balance &quot; + balance);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int query(String password) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            return balance;</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，上面就是一个很简单的ATM的实现，银行建立一个包含了初始密码和0余额的ATM，放在你家里，你就可以开始使用了。我们可以看到，这个ATM实现了三个方法，分别是存款(save)，取款(withdraw)和查询余额(query)。 下面我们来试着存钱取钱试试看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ATM atm = new ATM();</div><div class="line">    atm.save(&quot;wrong&quot;, 100); //错误的密码</div><div class="line">    System.out.println(&quot;I have &quot; + atm.query(&quot;p@ssw0rd&quot;) + &quot; in ATM.&quot;); //正确的密码查余额</div><div class="line">    atm.save(&quot;p@ssw0rd&quot;, 100); // 存100</div><div class="line">    System.out.println(&quot;I have &quot; + atm.query(&quot;p@ssw0rd&quot;) + &quot; in ATM.&quot;);</div><div class="line">    atm.withdraw(&quot;p@ssw0rd&quot;, 50); //取50</div><div class="line">    System.out.println(&quot;I have &quot; + atm.query(&quot;p@ssw0rd&quot;) + &quot; in ATM.&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">Authorization Error!</div><div class="line">I have 0 in ATM.</div><div class="line">Save 100, you have remaining balance 100</div><div class="line">I have 100 in ATM.</div><div class="line">Withdraw 50, you have remaining balance 50</div><div class="line">I have 50 in ATM.</div></pre></td></tr></table></figure></p>
<p>我们看到，输入密码，我们就可以存钱取钱。但是，这个系统真的安全吗？如果我们直接修改密码或者余额，会发生什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">atm.password = &quot;&quot;;</div><div class="line">atm.balance = 9999;</div><div class="line">System.out.println(&quot;I have &quot; + atm.query(&quot;&quot;) + &quot; in ATM.&quot;);</div><div class="line"></div><div class="line">输出：</div><div class="line">I have 9999 in ATM.</div></pre></td></tr></table></figure></p>
<p>啊哈，直接修改余额，我们现在有了9999的余额，而且密码变成了空白。显然，这个ATM十分的不安全，我们不用通过操作界面也就是系统提供的那些方法，就可以对数据进行操作。那么，我们来试着封装一下这个ATM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class ATM &#123;</div><div class="line">    private String password = &quot;p@ssw0rd&quot;; //修改为private</div><div class="line">    private int balance = 0;</div></pre></td></tr></table></figure></p>
<p>我们为这两个元素添加了private关键字。现在再试着运行同样的程序，我们会看到这样的错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The field ATM.password is not visible</div><div class="line">The field ATM.balance is not visible</div></pre></td></tr></table></figure></p>
<p>这下我们的ATM就安全多啦！这两个元素的可见性从公共的程度降低到了私有，也就是说，除了ATM机这个class的内部方法以外，没有别的方法可以读取和修改你的密码和余额啦！下面是这个ATM的Java代码，包含了存款取款修改密码和查询功能，有兴趣的小伙伴可以下载之后修改余额和密码的可见性，做一些其他的尝试。<br>
<button onclick="window.open('ATM.java')">点我下载 ATM.java</button>
<br>封装的概念比较容易理解，实际上就是控制外部对于类内部数据的访问，为了保证安全，我们尽量使得内部的数据私有化(private)，使外部用户只能通过规定的public方法来进行操作。表现在以上的例子中就是ATM中的密码，只能通过changePassword方法来修改，这就要求用户输入正确的密码，而不是可以随意对ATM内部的密码变量进行直接修改。封装的概念在下文中还会被多次提及，因为Java的特性大多数时候是相互影响的，我们会通过例子来看到这些变化和影响。</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>继承，算是Java最重要的特性之一。他的意思很简单，父亲有的东西，儿子一样会有。举例来说，假如你是一个造船厂的老板，你可以生产帆船，汽油机船和人力船三种船。生产每一种船都很耗费时间，所以每次拿到订单工期都会很赶，而没有订单的时候工人们又很闲。但是你是一个很聪明的老板，你发现，这三种船可以使用同一个模具建造出来的基本款船，只要加上船帆，发动机或者船桨，就会成为不同的产品。于是，闲暇时期你开始生产基本款，而接到订单后，只需要根据数量来安装对应的模块，就会很高效的完成订单。在这个例子中，三种成品都是继承于船体这个父类，生产中可以节约完成订单的时间，而表现在代码中则是很多代码都可以重复使用，而不需要重新编写。<br>现在，你应该对于继承有了一个大概的感觉，似乎明白了什么是继承，但是又无法跟代码联系起来。不要紧，下面我们就回到ATM的例子，来试着用代码表现出继承这一特性。上面的例子中，ATM是针对你这个超级VIP设计的，他可以满足你存取款修改密码查询余额的要求。假设现在我们又有了一个超级VIP，他不仅要求以上这些功能，同时他还需要转账功能，我们该怎么办呢？ATM不能被修改，因为你这个VIP还在使用，那我们是不是应该重新制作一个不一样的ATM呢？这种时候，继承的优点就表现出来了。让我们来建立一个可以转账的TransATM吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class TransATM extends ATM &#123;</div><div class="line"></div><div class="line">    public void transferTo(String password, int howMuch, long toAccount) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            if (this.balance &gt;= howMuch) &#123;</div><div class="line">                this.balance -= howMuch;</div><div class="line">                System.out.println(&quot;Successfully transferred &quot; + howMuch + &quot; to the account &quot; + toAccount + &quot; , balance is &quot; + balance);</div><div class="line">            &#125; else</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个TransATM继承了ATM的全部non-private的元素和方法。但是你会发现，当你调用这个transferTo方法的时候，Java会提醒你<code>The field ATM.password is not visible</code>。这是为什么呢？答案很简单，这个方法中this.password试图调用的是ATM这个父类当中的password变量，而这个变量我们为了安全性将可视性变为了private，所以就算是ATM的子类，这个变量也是不可见得。将ATM中的这两个变量修改为默认default，这个TransATM就可以正常工作了，而ATM的这两个变量的可视性则增加到了包，也就是在同一个package内的类都可以访问这两个变量了。在封装的部分中我们为了安全而将其设置成了私有，这里为了能够使得子类继承到这两个变量，我们修改了变量的可见性，这自然会降低安全性。那么，有没有什么办法能够既保证安全，又能减少重复劳动呢？复制黏贴代码并不是一个好习惯，让我们从设计的角度来思考一下更加可行的解决方法吧。<br>上文中的这个TransATM和ATM类的关系是父子关系，可以说TransATM “is-a” ATM，非私有的方法和元素都可以被继承。这是一种“是”的关系，例如玛莎拉蒂和五菱宏光都是车，他大舅他二舅都是他舅，这就是典型的“是”关系。除了“是”以外，我们还可以有“has-a”的关系。比如，玛莎拉蒂有发动机，帆船有帆，这都是有的关系。具体到我们ATM的例子，我们可以用有的关系来尝试解决这个问题。想象一下，我们为了节省工作负荷，再生产TransATM的时候，我们将一台ATM内嵌到了TransATM之中，然后增加了新的模块来实现转账功能，这也是继承关系的一种，是“有”的关系。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TransATM &#123;</div><div class="line">    private String password = &quot;transP@ssw0rd&quot;;</div><div class="line">    private ATM atm;</div><div class="line">    </div><div class="line">    public TransATM() &#123;</div><div class="line">        this.atm = new ATM();</div><div class="line">        atm.changePassword(&quot;p@ssw0rd&quot;, this.password);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void withdraw(String password, int howMuch) &#123;</div><div class="line">        atm.withdraw(password, howMuch);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void save(String password, int howMuch) &#123;</div><div class="line">        atm.save(password, howMuch);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int query(String password) &#123;</div><div class="line">        return atm.query(password);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void changePassword(String password, String newPassword) &#123;</div><div class="line">        atm.changePassword(password, newPassword);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void transferTo(String password, int howMuch, long toAccount) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            if ( atm.query(password) &gt;= howMuch) &#123;</div><div class="line">                atm.withdraw(password, howMuch);</div><div class="line">                System.out.println(&quot;Successfully transferred &quot; + howMuch + &quot; to the account &quot; + toAccount + &quot; , balance is &quot; + atm.query(password));</div><div class="line">            &#125; else</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + atm.query(password) + &quot; left!&quot;);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，这个TransATM实际上就是给ATM套了一个外壳，但是安全性有了很大的提升，不仅可以有不同的初始密码，密码变量和内部的atm对于用户也是不可见的。这就是封装和继承之间的平衡。找准主要需求，在设计上进行改变来满足需求是程序员解决问题的必要思路。从这个例子中我们可以看到由于ATM类原本不是为了可延展设计的，所以在继承方面需要我们或者改变可见度，或者改变继承的类型来适应。那么，如果一开始就是为了可以延展而设计，这些ATM可以有哪些改变呢？</p>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>因为你和你的小伙伴太成功了，越来越多的定制ATM需求被提了出来。于是银行发现，为了满足这些定制的ATM，要么每一次都重新开发，要么就要对已经投入使用的ATM进行修改。修改正在使用的ATM会导致你们这些超级VIP的ATM也需要更新修改，代价过于高昂，于是银行打算从头来设计一套易于延伸，便与定制同时还要安全稳定的ATM标准，来作为以后ATM的设计方案基础。这就涉及到了多态的特性。首先我们暂时放下ATM的这些事情，先来了解一下interface的概念。interface，就是接口，也是Java的常用关键字之一。它所表示的意思跟它的字面意思是一样的，表示它所标示的是一系列类型的共同操作方式。接口，顾名思义，是指一个系统接受输入和输出的部分。我们来举几个简单的例子帮助理解。假设我们要实现一些class，这些class都有一些共同的方法，那么我们就可以定义一个interface来表示这个共同的方法。比如我们有dog,cat,他们都会摇尾巴，我们就可以定义一个interface来定义摇尾巴这个动作，但凡有新的动物会摇尾巴，我们就可以要求这个动物implements这个interface。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">interface ShakeTail &#123;</div><div class="line">    public void shakeTail();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog implements ShakeTail&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;dog shake tail&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat implements ShakeTail &#123;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;cat shake tail&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子里，dog和cat在定义中包含了ShakeTail的接口，所以他们必须要实现shakeTail这个方法。但是interface只是一个接口，不能有具体的实现，如果我们想要一个interface，同时需要包含一些可以通用的方法，那么我们可以使用abstract类。abstract类跟普通类很相似，区别在于abstract类不能实例化，也就是不能‘new’。只有子类extends abstract类，子类才可以被实例化。来看具体例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">abstract class Animal &#123;</div><div class="line"></div><div class="line">    public void move() &#123;</div><div class="line">        System.out.println(&quot;Animal move&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的Dog类继承了Animal类中的move方法，所以<code>new Dog().move()</code>会调用Animal中的move方法。那么什么时候用抽象（abstract）类，什么时候用接口呢？这里实际上依旧是上文描述过的”is-a”和”has-a”的关系。如果你有一类的东西，那么你可以给这一类的东西归类成一个抽象类。比如我们有猫，有狗，有鸟，我们就可以有一个抽象的动物类，然后实现一些全体动物共同的特性。而当某几类的动物有共同的特征时，我们可以为这个特征建立接口，有这一特征的动物就可以实现这个接口。依旧来看例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">abstract class Animal &#123;</div><div class="line">    public void move() &#123;</div><div class="line">        System.out.println(&quot;Animal move&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface LickPaw &#123;</div><div class="line">    public void lickpaw();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface ShakeTail &#123;</div><div class="line">    public void shakeTail();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal implements ShakeTail &#123;</div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;dog shake tail&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal implements ShakeTail, LickPaw&#123;</div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;cat shake tail&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void lickpaw() &#123;</div><div class="line">        System.out.println(&quot;cat lick paw&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    shakeTail(new Cat());</div><div class="line">    move(new Dog());</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void shakeTail(ShakeTail l) &#123;</div><div class="line">    l.shakeTail();</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void move(Animal a) &#123;</div><div class="line">    a.move();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们从上往下依次来看。首先我们定义了一个抽象的Animal类，包含了一个move的方法。这个类是无法‘new’实例化（instantiation）的。然后我们定义了舔爪子和摇尾巴两个接口。为什么Animal是抽象类而这两个接口是接口呢？因为我们将要定义的类将‘是’动物，而‘有’某些接口定义的方法。所以我们可以说猫是动物，可以舔爪子，而不能反过来。如果我们要创建抽象类是猫，而定义的多个类是各种猫，那么‘舔爪子’这个方法就应该放在抽象类猫之中了。下面的猫和狗我们可以看到，都是动物类的子类，都有摇尾巴的方法，而猫则多出了舔爪子的方法。这样做的优点有几种。首先是代码的重复利用，Animal中的方法猫狗都可以直接调用，而不用重新写。另外是看最下面的方法，<code>new Dog()</code> 可以被只接受Animal的方法接受，<code>new Cat()</code> 也可以被只接受ShakeTail的方法接受。这是因为dog一定是Animal，包含了Animal能被外部调用的全部方法和元素，所以Animal能被看见的能被调用的，dog一定也有。而Cat实现了ShakeTail，所以ShakeTail规定的方法Cat一定全部都实现了，所以对于接受ShakeTail的方法，Cat一定包含了对其对应方法的实现。这样带来的好处有很多，比如Java的executor，你可以有各类job的实现，然后executor只要调用job的run方法，就可以完成各类工作，而不需要了解不同job的具体实现。我们来看用这种抽象思想实现的ATM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">abstract class AbstractATM &#123;</div><div class="line">    </div><div class="line">    protected abstract Map&lt;String, Account&gt; getAccounts();</div><div class="line"></div><div class="line">    public void openAccount(String username, String password) &#123;</div><div class="line">        getAccounts().put(username, new Account(password, 0));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void withdraw(String username, String password, int howMuch) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line"></div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            int balance = account.getBalance();</div><div class="line">            if (balance &gt;= howMuch) &#123;</div><div class="line">                account.setBalance(balance - howMuch);</div><div class="line">                System.out.println(&quot;Withdraw &quot; + howMuch + &quot;, you have remaining balance &quot; + account.getBalance());</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void save(String username, String password, int howMuch) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line"></div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            int balance = account.getBalance();</div><div class="line">            account.setBalance(balance + howMuch); </div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Integer query(String username, String password) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            return account.getBalance(); </div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changePassword(String username, String password, String newPassword) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            account.setPassword(newPassword);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    protected class Account &#123;</div><div class="line">        </div><div class="line">        private String password;</div><div class="line">        private int balance;</div><div class="line">        </div><div class="line">        protected Account(String password, int balance) &#123;</div><div class="line">            this.password = password;</div><div class="line">            this.balance = balance;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        protected int getBalance() &#123;</div><div class="line">            return balance;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        protected String getPassword() &#123;</div><div class="line">            return password;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        protected void setBalance(int balance) &#123;</div><div class="line">            this.balance = balance;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        protected void setPassword(String password) &#123;</div><div class="line">            this.password = password;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个抽象类就是ATM的原型机，我们可以看到他实现了全部的基本操作，同时用一个可以被override的方法来从子类中获得账户信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TransferATM extends AbstractATM &#123;</div><div class="line">    private Map&lt;String, Account&gt; accounts;</div><div class="line"></div><div class="line">    public TransferATM(String username, String password) &#123;</div><div class="line">        super();</div><div class="line">        accounts = new HashMap&lt;&gt;();</div><div class="line">        accounts.put(username, new Account(password, 0));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Map&lt;String, Account&gt; getAccounts() &#123;</div><div class="line">        return accounts;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void transferTo(String username, String password, int howMuch, long toAccount) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line"></div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            int balance = account.getBalance();</div><div class="line">            if (balance &gt;= howMuch) &#123;</div><div class="line">                account.setBalance(balance - howMuch);</div><div class="line">                System.out.println(&quot;Transfer &quot; + howMuch + &quot; to account &quot; + toAccount + &quot;, you have remaining balance &quot; + account.getBalance());</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个子类就是具体的ATM实现，override了getAcccount方法，所以父类中的方法可以获得子类中的账户信息。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们回顾了Java的部分特性，了解了继承多态和封装的基本概念。我们来总结一下。封装是为了安全，良好的系统应该接近黑盒，用户需要根据文档学习使用，而系统内部的运作方式和数据处理过程对外部来说是不可见的。良好的封装不仅增加安全性，同时会降低系统的复杂度，减低用户学习的难度。继承是指类与类之间的关系，而概念跟字面意思是一致的。除了private的方法和元素之外，子类可以继承父类的其他元素，提高代码的重复使用率。多态是指同一个签名拥有不同的实现方法，根据不同场景，可以选择对应的实现方法。这些特性相辅相成，相互影响，共同构成了安全高效的系统。</p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-encapsulation-inheritance-polymorphism&quot;&gt;&lt;a href=&quot;#Java-encapsulation-inheritance-polymorphism&quot; class=&quot;headerlink&quot; title=&quot;Java e
    
    </summary>
    
    
      <category term="Java" scheme="https://alex-mengx.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第0天的Hello World!</title>
    <link href="https://alex-mengx.github.io/2017/02/15/hello-world/"/>
    <id>https://alex-mengx.github.io/2017/02/15/hello-world/</id>
    <published>2017-02-16T01:45:27.844Z</published>
    <updated>2017-02-18T05:22:47.272Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://alex-mengx.github.io/data-structure/">弦子的数据结构小分享</a>! This is my very first post :)</p>
<p>I can be reached by Email: Alex.mengxiangwei@gmail.com</p>
<p>The Goal of this blog is to share my understanding of data structures. Each post would implement one of the most widely used data structure in Java. No specific reason for choosing Java as the developing language, and each language should be treated equally with dignity no matter what their circumstances :D </p>
<h3 id="May-the-force-be-with-you"><a href="#May-the-force-be-with-you" class="headerlink" title="May the force be with you."></a>May the force be with you.</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://alex-mengx.github.io/data-structure/&quot;&gt;弦子的数据结构小分享&lt;/a&gt;! This is my very first post :)&lt;/p&gt;
&lt;p&gt;I can be reached b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第1天的LinkedList</title>
    <link href="https://alex-mengx.github.io/2017/02/11/postLinkedList/"/>
    <id>https://alex-mengx.github.io/2017/02/11/postLinkedList/</id>
    <published>2017-02-12T04:29:42.000Z</published>
    <updated>2017-03-02T02:31:21.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>LinkedList - it is a linked list.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>链表 （ linkedlist） 是常见的数据结构之一。顾名思义，链表由一个一个的节点链接而成。每一个节点，都包含了承载的数据，以及一个指向下一个节点的指针。我们可以通过想象力来帮助我们理解这个数据结构是如何构成的。<br>想象一下儿时玩过的藏宝游戏。你的父亲给了你一张小纸条，上面写了一个地址 - 也许是卧室的窗台上，也许是长廊的过道边  - ， 游戏就由此开始了。 你来到了纸条上描述的位置，发现了一块美味的糖果，和另一张写着其他地址的纸条，于是你吃掉了糖果，向着下一个目的地出发。每个目的地都有一些宝藏，也许是糖果，也许是玩具，最重要的是都会有一张写着地址的小纸条。 你可以一直找寻下去，直到有一天，你抵达了这条链的终点，那里不再有写着地址的纸条，只有父亲在微笑的看着你。<br>这就是一条典型的链表，每个藏着宝藏的地点就是链表的一个节点，写着地址的纸条则成为了指向下一个节点的指针。一个有限长度的链表必然存在着头和尾，在上文的例子中，第一张纸条可以被看做链表头，而没有纸条的最后一个藏宝点则是链表尾。</p>
<h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>这篇博文将用Java来一步一步实现一个拥有基本功能的链表来帮助读者理解这个结构。<br>首先，我们先为藏宝点建立格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Node&#123;</div><div class="line">    E treasure;</div><div class="line">    Node next;</div><div class="line"></div><div class="line">    public Node(E treasure, Node next) &#123;</div><div class="line">        this.treasure = treasure;</div><div class="line">        this.next = next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，一个简单的节点就建立起来了。treasure 可以是任何类型的元素，可以是其他object，也可以是数字或者字符串， 而next则指向了Node这个类。在实例中，next将会指向其他的Node实例。<br>有了藏宝的点，我们现在需要建立我们的第一张写着地址的小纸条了，这个纸条将会成为链表的头，所有的操作都将会通过这个小纸条来进行，它将是我们唯一的接入点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class LinkedList&lt;E&gt; &#123;</div><div class="line">    Node root;</div><div class="line">    </div><div class="line">    class Node&#123;</div><div class="line">        E treasure;</div><div class="line">        Node next;</div><div class="line"></div><div class="line">        public Node(E treasure, Node next) &#123;</div><div class="line">            this.treasure = treasure;</div><div class="line">            this.next = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个LinkedList类，就是我们的链表，而类元素root，则成为了我们可以接入这条链表的接入点。<br>现在我们有了一个框架，那么是时候为这条链表增加一些方法了。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>从上文的例子和部分实现中，我们已经对链表有了一个抽象的认识。那么链表的操作该如何完成呢？<br>下面我们来一步一步的增加增删改查这些常用的方法。</p>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>最简单的插入方式，就是从头部插入新的节点。假设目前你手里握着第一张纸条，那么增加一个新的藏宝点到这个长链中的最简单的的方式则是建立一个新的藏宝点，把你手中的纸条藏在哪里，然后拿出一张新的纸条，记录下来这个新的藏宝点的地址。 这个操作完成之后，新的节点会成为链表的头，而原先的链表头则成为了链中的第二个节点。</p>
<p></p><p align="center"><br>  <img src="LinkedList_Insertion.jpg"><br>  <b>LinkedList insertion operation chart 1.</b><br></p><br>上图解释了插入的过程。基本上可以分为两步：<p></p>
<ol>
<li>新建一个Node，这个Node的next指向原本的root节点。</li>
<li>断开原本的头部，指向新建的节点。</li>
</ol>
<p>这样，一个节点的插入操作就完成了。我们来看一下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void add(E e) &#123;</div><div class="line">    if (root == null)&#123;</div><div class="line">        root = new Node(e, null);</div><div class="line">    &#125; else &#123;</div><div class="line">        root = new Node(e, root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这个if条件是因为当这个链表为空的时候，这个root是null值，没有next元素，所以只需要让root指向新建的节点就可以了。当链表已经有了至少一个元素的时候，我们才需要断开root -&gt; node，然后新节点的next指向node， root指向新节点.</p>
<h3 id="RemoveFirst"><a href="#RemoveFirst" class="headerlink" title="RemoveFirst"></a>RemoveFirst</h3><p>取出并删除头结点的过程和插入类似，只要将root指向root.next就可以了。看图会清晰一点。</p>
<p></p><p align="center"><br>  <img src="LinkedList_RemoveFirst.jpg"><br>  <b>LinkedList removeFirst operation chart 2.</b><br></p><br>这个操作只需要一步就可以完成。代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public E removeFirst()&#123;</div><div class="line">    if (root == null)&#123;</div><div class="line">        return null;</div><div class="line">    &#125; else &#123;</div><div class="line">        E e = root.treasure;</div><div class="line">        root = root.next;</div><div class="line">        return e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>if检查在这里也是很必要的，因为当这个链表为空的时候，任何涉及root内部元素的操作都会抛出NullpointerException。只有不为空的链表，我们才可以取出其中的元素，如同一个没有地址的纸条，自然没有办法为我们指向宝藏的位置。</p>
<h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>查找链表中的元素是很常用的操作。但是这个数据结构对于查找并不是很友好。从上面插入和删除第一个元素的操作，我们可以看出来，无论这个链表中有多少的元素，我们都只需要对root进行操作。也就是说，无论这个链表内部元素的数量N有多庞大，插入和删除第一个元素的操作耗费的时间总是一定的。这一类与N无关的操作我们称之为O(1)操作。在这里我们不多涉及O（）这一表现形式，在未来的文章中我们会进一步解释这个符号的含义以及在算法中代表的意义。<br>话题回到链表的查找操作。由介绍部分的例子我们可以看出，对于链表，我们的访问总是从头部开始的。无论有多少宝藏和藏宝的地点，我们只能从手中的纸条所给出的第一个地点一步一步寻找下去。对于   root -&gt; A -&gt; B -&gt; C -&gt; D 这条链来说，没有到达B之前，我们没有办法知道C在哪里。这就给搜索带来了很多的麻烦。<br>回到开头的例子。 我们想从宝藏中找到竹蜻蜓，那么我们该怎么做？逻辑很简单:<br><b>我们所在的藏宝点收藏的是竹蜻蜓吗？</b></p>
<ol>
<li>是。很好，我们找到了。</li>
<li>不是，我们去下一个地点。</li>
</ol>
<p>继续看图来帮助理解。</p>
<p></p><p align="center"><br>  <img src="LinkedList_Search.jpg"><br>  <b>LinkedList search operation chart 3.</b><br></p><br>代码的逻辑并不复杂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean search(E e) &#123;</div><div class="line">    Node current = root;</div><div class="line">    while (current != null)&#123;</div><div class="line">        if (current.treasure.equals(e))</div><div class="line">            return true;</div><div class="line"></div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>让我们用语言来复述一遍这个方法的具体逻辑，这有助于理解。<br>首先，我们不希望破坏现有的数据和结构，所以我们不对root和其他链表内的元素进行操作。我们用一个current来表示我们当前所在的藏宝点的位置，这个current起始点则是root。 下面我们就踏上了寻宝之旅。在走完全部的旅途之前，没有人知道将会遇到什么，所以我们需要这个while loop 一直持续，直到current成为null也就是到达终点为止。在遍历的过程中，我们不断比较，当前current的treasure元素是否是我们所寻找的？如果是，那说明我们找到了，只要返回true就好，这会打破while loop，并从方法中返回。如果不是，我们则使current指向current.next，也就是我们的下一个目标点。当current成为null，也就是说我们走到了旅途的终点，那么我们所寻找的元素就不存在于这个链表之中，于是我们返回false。<br>并不难吧？</p>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>这个操作可以从链表里删除一个节点。跟removeFirst相比，它们的不同之处在于removefirst只能删掉第一个元素，而这个remove我们希望可以删除任意的E，只要E在链表中。那么，机智如你，想必一定已经有了思路了吧？是的，只要对search方法稍加修改就可以了。在search方法中，我们沿着链表一路向北直到目的地或者尽头，然后返回是否找到，在Remove中，我们要做同样的事情。只需要额外的一步，当找到包含了元素E的节点之后，我们只需要让E所在的节点的前一个节点的next指向E元素之后的节点就可以了。依旧看图说话。</p>
<p></p><p align="center"><br>  <img src="LinkedList_Remove.jpg"><br>  <b>LinkedList search Remove chart 4.</b><br></p><br>由于删除一个节点，我们需要知道这个节点的上一个节点在哪里，所以相比于search方法，remove方法我们需要两个指针，一个指向目前所在的current，一个指向之前一个节点previous。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public boolean remove(E e) &#123;</div><div class="line">    if (root == null) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    if (root.treasure.equals(e)) &#123;</div><div class="line">        root = root.next;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Node current = root.next;</div><div class="line">    Node previous = root;</div><div class="line"></div><div class="line">    while (current != null) &#123;</div><div class="line">        if (current.treasure.equals(e))&#123;</div><div class="line">        previous.next = current.next;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        previous = current;</div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>我们看到，虽然逻辑很相似，但是这个代码的复杂程度要比search稍微高一点。不过不要紧，我们来一行一行的查看一下它的逻辑。首先依旧是null check，如果root是null的话，说明链表是空的，直接返回false表明无法删除目标元素E就可以了。 接下来是查看root节点。作为第一个节点，如果它所收藏的宝藏是我们的目标元素， 那么我们只需要让root指向他自身的next，也就是等于取出第一个元素。到这里为止，之前的逻辑跟removeFirst是一样的。再往下，我们声明了两个指针，previous指向了root，current指向了root.next。因为之前我们已经查看了root不为null，所以root.next是不会抛出NullPointerException的。经过了这些步骤，我们终于做好了准备，可以踏上旅途了。进入while循环之后，我们查看current是否是我们所寻找的元素， 如果是，那么我们的旅途可以成功结束，如果不是，则还要继续寻找。当我们从一个节点走入另一个节点时，我们不仅要更新我们当前所在的节点current，同时还要更新previous，让它指向我们刚刚离开的节点。这样的话，如果下一个节点的元素是目标元素，则我们可以使用previous来找到当前节点，并使得previous.next指向current也就是目标元素节点的next。<br>如果while loop结束了依旧没有，那么说明我们所在的链表不包含目标元素，返回false说明删除失败。</p>
<h3 id="Edit"><a href="#Edit" class="headerlink" title="Edit"></a>Edit</h3><p>到目前为止，我们实现了插入元素，删除第一个元素，删除目标元素和查找元素这四个方法。利用这四个方法，我们可以实现另一个修改某个目标元素的方法。 逻辑很简单，如果删除目标元素成功，那么插入新元素就可以了。如果删除失败，说明目标元素不存在，自然无法修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public boolean edit(E target, E updateTo) &#123;</div><div class="line">    if (remove(target))&#123;</div><div class="line">        add(updateTo);</div><div class="line">        return true;</div><div class="line">    &#125; else return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于逻辑很好理解，我们直接看代码吧。 如果remove 目标元素E返回了true， 那么我们用add方法插入新的元素， 而如果remove 返回了false，则说明这个元素不存在，修改失败。</p>
<h2 id="Analysis-amp-Finding"><a href="#Analysis-amp-Finding" class="headerlink" title="Analysis &amp; Finding"></a>Analysis &amp; Finding</h2><p>在本文的上一个部分，我们实现了一个链表，以及实现了链表的增删改查等基本方法。下面我们写一点代码来使用这个链表，试着插入删除修改链表的元素。<br>为了方便查看链表内的已有元素，我们来实现一个toString方法。关于这个方法我们在这里稍微解释一下，这跟Java的特性有关系。Java是面向对象的语言，对于Java来说，所有的类都是一个一个的Object，而这些类之间则是继承关系，所以当你在链表内实现了toString方法，实际上你是用你实现的toString覆盖了这个链表父类中默认的toString方法。我们会用下一篇博文来专门介绍Java的这些特性，这里只需要知道这个toString方法是Object类中固有的方法就可以了。<br>这个toString方法我们将会从root开始遍历，依次打印出全部的元素。我们来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String toString() &#123;</div><div class="line">    Node current = root;</div><div class="line">    StringBuilder listToString = new StringBuilder();</div><div class="line">    listToString.append(&quot;====&quot; + &apos;\n&apos;);</div><div class="line">    while (current != null) &#123;</div><div class="line">        listToString.append(current.treasure);</div><div class="line">        listToString.append(&quot; &quot;);</div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    listToString.append(&apos;\n&apos; + &quot;====&quot;);</div><div class="line">    return listToString.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很好理解，跟search的逻辑是一样的。从root开始，对于每一个节点都把元素变成String，再将String拼在一起返回。<br>下面我们来试着插入从0到9十个数字，然后随便查找删除添加一些数字试试看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    intTest();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void intTest()&#123;</div><div class="line">    LinkedList&lt;Integer&gt; l = new LinkedList&lt;&gt;();</div><div class="line">    IntStream.range(0, 10).forEach(i -&gt; l.add(i)); // 添加0到9</div><div class="line">    System.out.println(l); // 打印</div><div class="line">    System.out.println(&quot;5 in the list is &quot; + l.search(5)); // 搜索5</div><div class="line">    System.out.println(&quot;10 in the list is &quot; + l.search(10)); // 搜索10</div><div class="line">    System.out.println(&quot;remove first, it is &quot;+ l.removeFirst());</div><div class="line">    System.out.println(&quot;remove first, it is &quot;+ l.removeFirst());</div><div class="line">    System.out.println(&quot;remove first, it is &quot;+ l.removeFirst());</div><div class="line">    System.out.println(l);// 打印</div><div class="line">    System.out.println(&quot;remove 11 is &quot; + l.remove(11));</div><div class="line">    System.out.println(&quot;remove 6 is &quot; + l.remove(6));</div><div class="line">    System.out.println(&quot;remove 0 is &quot; + l.remove(0));</div><div class="line">    System.out.println(l);// 打印</div><div class="line">    IntStream.range(0, 10).forEach(i -&gt; l.add(i)); //添加0到9</div><div class="line">    System.out.println(l);// 打印</div><div class="line">    System.out.println(&quot;Modify number 4 to 99 is &quot; + l.edit(4, 99));</div><div class="line">    System.out.println(&quot;Modify number 40 to 98 is &quot; + l.edit(40, 98));</div><div class="line">    System.out.println(l);// 打印</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段程序的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">====</div><div class="line">9 8 7 6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">5 in the list is true</div><div class="line">10 in the list is false</div><div class="line">remove first, it is 9</div><div class="line">remove first, it is 8</div><div class="line">remove first, it is 7</div><div class="line">====</div><div class="line">6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">remove 11 is false</div><div class="line">remove 6 is true</div><div class="line">remove 0 is true</div><div class="line">====</div><div class="line">5 4 3 2 1  //注意这里和下一行数字输出</div><div class="line">====</div><div class="line">====</div><div class="line">9 8 7 6 5 4 3 2 1 0 5 4 3 2 1 </div><div class="line">====</div><div class="line">Modify number 4 to 99 is true</div><div class="line">Modify number 40 to 98 is false</div><div class="line">====</div><div class="line">99 9 8 7 6 5 3 2 1 0 5 4 3 2 1 </div><div class="line">====</div></pre></td></tr></table></figure></p>
<p>输出很直白，这里不再赘述。需要注意的一点是，链表中剩下1到5的情况下，再次插入0到9使得链表中出现了重复的元素，所以当我们将4修改成99的时候，列表中出现的第一个4被删除了，然后在首位置插入了99，所以列表中还有另外一个4。很多时候，我们不希望列表中出现重复的元素，我们可以对插入的方法进行一些修改来达成这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void add(E e) &#123;</div><div class="line">    if (!search(e)) &#123;</div><div class="line">        if (root == null) &#123;</div><div class="line">            root = new Node(e, null);</div><div class="line">        &#125; else &#123;</div><div class="line">            root = new Node(e, root);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改很直白，只有search返回false也就是当前链表中没有该元素，我们才会插入。再次运行同样的测试，输出如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">====</div><div class="line">9 8 7 6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">5 in the list is true</div><div class="line">10 in the list is false</div><div class="line">remove first, it is 9</div><div class="line">remove first, it is 8</div><div class="line">remove first, it is 7</div><div class="line">====</div><div class="line">6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">remove 11 is false</div><div class="line">remove 6 is true</div><div class="line">remove 0 is true</div><div class="line">====</div><div class="line">5 4 3 2 1 </div><div class="line">====</div><div class="line">====</div><div class="line">9 8 7 6 0 5 4 3 2 1 </div><div class="line">====</div><div class="line">Modify number 4 to 99 is true</div><div class="line">Modify number 40 to 98 is false</div><div class="line">====</div><div class="line">99 9 8 7 6 0 5 3 2 1 </div><div class="line">====</div></pre></td></tr></table></figure></p>
<p>可以看到，当链表中还有1到5的时候，只有0,6到9可以被插入该链表。当4被修改为99时，链表中的4就没有。另外如果你对于为什么<code>System.out.println(l)</code>可以打印出链表感兴趣，就请关注我的下一篇博文吧 :-)</p>
<p>##Conclusion<br>在这一篇文章中，我们从头实现了一个链表所包括的常见方法，并对这些方法进行了简单的测试。在前文中，我们提到过链表这一数据结构对于搜索的支持并不好，在以后的文章中我将会用其他结构和链表进行对比，来加深读者对于这些结构的理解。<br><br>下面是这篇文章实现的代码，需要的读者可以尝试运行。<br><br>
<button onclick="window.open('LinkedList.java')">点我下载 LinkedList.java</button>
<br><br>谢谢阅读。<br><br>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LinkedList&quot;&gt;&lt;a href=&quot;#LinkedList&quot; class=&quot;headerlink&quot; title=&quot;LinkedList&quot;&gt;&lt;/a&gt;LinkedList&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; cla
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
</feed>
