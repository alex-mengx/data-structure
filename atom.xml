<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alex&#39;s data structure class</title>
  
  <link href="/data-structure/atom.xml" rel="self"/>
  
  <link href="https://alex-mengx.github.io/"/>
  <updated>2017-03-27T04:24:59.222Z</updated>
  <id>https://alex-mengx.github.io/</id>
  
  <author>
    <name>弦子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第2天的BinaryTree遍历之深度优先</title>
    <link href="https://alex-mengx.github.io/2017/03/20/postDepthFirst/"/>
    <id>https://alex-mengx.github.io/2017/03/20/postDepthFirst/</id>
    <published>2017-03-21T01:52:49.000Z</published>
    <updated>2017-03-27T04:24:59.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-traversal"><a href="#Binary-Tree-traversal" class="headerlink" title="Binary Tree traversal"></a>Binary Tree traversal</h1><h2 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h2><p>今天我们来讲一讲二叉树的遍历。遍历的意思就是按照某种顺序依次访问每一个节点。对于二叉树，我们有三种常见的遍历方式：前序，中序和后序。这都属于深度优先遍历，除此之外还有广度优先遍历。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>深度优先和广度优先是两种概念不同的思想。不仅仅是遍历树或者图，这两种思想还可以用于多种算法。比如深度优先搜索常用于迷宫寻路，拓扑排序等，而广度优先查找则常见于最短路径查找，最大流量路径查找等等。今天我们不会将重点放在这两种搜索方式，而是通过实现二叉树的深度优先遍历，来让大家对于深度优先有初步的认识。在以后的文章中，我们会对拓扑和图进行介绍，之后我们再次尝试对于深度优先和广度优先进行深一步的介绍。</p>
<h2 id="depth-first-traversal-of-binary-tree"><a href="#depth-first-traversal-of-binary-tree" class="headerlink" title="depth-first traversal of binary tree"></a>depth-first traversal of binary tree</h2><p>深度优先遍历，顾名思义，主旨思想在于先尽量走到更深的地方，直到尽头在考虑如何转向其他的路径。就如同走迷宫，这种方式就好比我们沿着入口一侧的墙壁走到底，在返回最后一个分叉口，继续尝试另一个路径。这种方式的关键点在于，在我们走完某个分叉口A一侧的全部子分叉之前，我们不会去尝试A另一侧的分叉。树的深度优先遍历有三种常见的顺序，前序，中序和后序。我们先来看中序，这是相对比较好理解的顺序。</p>
<h3 id="In-order"><a href="#In-order" class="headerlink" title="In-order"></a>In-order</h3><p>二叉树的性质我们应该还记得，如果有比较陌生的小伙伴，建议先看一下这篇<a href="https://alex-mengx.github.io/data-structure/2017/03/01/postBinaryTree/">二叉树</a>来帮助理解。二叉树的重要性之之一就是递归性，每个节点的左右两个子树都是完整的二叉树。另外，插入元素时，小于当前节点的元素会被插入到左边子树，大于当前节点的元素则被插入到右边。所以对于任意一个二叉树而言，树左边的的全部元素都小于根节点元素，右边的的元素则全部大于根节点元素。那么在遍历过程，如果有一种便利的方式是这样的：我先遍历左侧子树，然后访问当前节点，然后在访问右侧子树，那么我访问全部节点的顺序是什么样子的？是的，如果我们打印出来的话，我们会发现我们访问全部的节点的顺序是从小到大的。首先先来看一下逻辑和图来帮助理解。</p>
<ol>
<li>访问左侧子树。</li>
<li>访问当前节点。</li>
<li>访问右侧子树。</li>
</ol>
<p>我们来用这种方式访问一下下面这个二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 很眼熟的一棵树。</div><div class="line">// 首先从根节点开始。</div><div class="line"></div><div class="line">                4 &lt;- 根节点开始</div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">Output：</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">    这里 -&gt; 2       9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 访问左侧子树：4.left</div><div class="line">// 2成为了新的根节点。 重复这个方法，第一步访问左子树，为null，第二部访问当前节点2，打印2， 第三步访问右子树，为null。</div><div class="line">// 2 这个子树已经全部访问完毕，返回4。</div><div class="line">Output：2</div><div class="line"></div><div class="line">                4 &lt;- 访问</div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 访问4。这里完成了4的左侧的访问和4的访问，下一步是4的右侧 4.right</div><div class="line">Output：2, 4</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 &lt;- 这里是新的根节点</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 9这个子树也是一样的访问顺序。先访问9.left</div><div class="line">Output：2, 4</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">        这里 -&gt; 6       12</div><div class="line">// 6和2的情况是一样的，没有子树，访问完6就可以返回9了</div><div class="line">Output：2, 4, 6</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 &lt;- 访问</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">// 访问9这个节点</div><div class="line">// 现在9的左侧和9都已经访问过了，继续访问9的右侧。</div><div class="line">Output：2, 4, 6, 9</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 </div><div class="line">                  /    \  </div><div class="line">                6       12 &lt;- 访问</div><div class="line">// 访问12的左侧为null，访问12， 访问12的右侧为null。跟2 和6的情况一样。</div><div class="line">Output：2, 4, 6, 9, 12</div><div class="line"></div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9 &lt;- 返回</div><div class="line">                  /    \  </div><div class="line">                6       12 </div><div class="line">// 9的右子树全部访问完成，回到了9</div><div class="line">Output：2, 4, 6, 9, 12</div><div class="line"></div><div class="line">                4 &lt;- 返回</div><div class="line">             /    \  </div><div class="line">           2        9 </div><div class="line">                  /    \  </div><div class="line">                6       12 </div><div class="line">// 4的右子树全部访问完成，已经是根节点，输出为最终输出</div><div class="line">Output：2, 4, 6, 9, 12</div></pre></td></tr></table></figure></p>
<p>上面的图给出了依照这个算法遍历树的每一个运行步骤，基本精确到了每行代码。我们按照这个思想来实现一下这个方法。首先这很显然是一个递归的方法。边界条件应该很清晰，就是如果这个节点不为null，则按照上面的三步逻辑来访问，如果为null，则返回上一层调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void inOrder(Node tree) &#123;</div><div class="line">    if (tree == null)</div><div class="line">        return;</div><div class="line">    inOrder(tree.left);</div><div class="line">    System.out.print(tree.treasure + &quot; &quot;);</div><div class="line">    inOrder(tree.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法接受一个二叉树的根节点，并且按照左中右的顺序遍历整棵树。这个实现为了便于理解，行数比较多，后面将使用更简略的方式来实现。</p>
<h3 id="Pre-Order"><a href="#Pre-Order" class="headerlink" title="Pre-Order"></a>Pre-Order</h3><p>前序，跟中序基本一致，唯一的区别就是这种顺序的遍历将会首先访问当前节点，然后是左子树和右子树。来看逻辑：</p>
<ol>
<li>访问当前节点。</li>
<li>访问左侧子树。</li>
<li>访问右侧子树</li>
</ol>
<p>因为跟中序很一致，我们直接看代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void preOrder(Node tree) &#123;</div><div class="line">    System.out.print(tree.treasure + &quot; &quot;);</div><div class="line">    Optional.ofNullable(tree.left).ifPresent(node -&gt; preOrder(node));</div><div class="line">    Optional.ofNullable(tree.right).ifPresent(node -&gt; preOrder(node));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前序的好处是最先访问当前节点而非子树，所以在一些场合会非常合适。最常见的应用就是算式处理。除了常见的算式表达方法，我们还有前缀表达法。比如(3+5)<em>8，用前缀表达法就是\</em> + 3 5 8，这种方式的语法不需要括号就可以顺利表达操作。写成树的形式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">       *</div><div class="line">     /   \</div><div class="line">   +       8</div><div class="line"> /   \</div><div class="line">3     5</div></pre></td></tr></table></figure></p>
<p>我们用前序遍历一下这个树，得到的结果就是 * + 3 5 8, 树形结构也很清晰的看出来我们计算的是3和5的和乘以8。</p>
<h3 id="Post-Order"><a href="#Post-Order" class="headerlink" title="Post-Order"></a>Post-Order</h3><p>这三种遍历的方式其实就是访问顺序的不同，实际实现起来只需要改动代码的顺序就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; void postOrder(BinaryTree&lt;T&gt;.Node tree) &#123;</div><div class="line">    Optional.ofNullable(tree.left).ifPresent(node -&gt; preOrder(node));</div><div class="line">    Optional.ofNullable(tree.right).ifPresent(node -&gt; preOrder(node));</div><div class="line">    System.out.print(tree.treasure + &quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到，与前序相反，后序的访问则是将对当前节点放到了最后面。这对于表达式的计算其实也很有帮助。我们来看一个稍微复杂一点的表达式树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">       *</div><div class="line">     /   \</div><div class="line">   +       8</div><div class="line"> /   \ </div><div class="line">3     *</div><div class="line">    /   \ </div><div class="line">   5     2</div></pre></td></tr></table></figure></p>
<p>这个式子是 ( ( 5 <em> 2 ) + 3 ) </em> 8，如果我们用后序来遍历，结果就是 3 5 2 <em> + 8 </em>。这个表达有什么好处呢？我们来看一个神奇的计算方试。首先我们建立一个stack，将这个式子压入stack。遇到数字就压入，遇到操作符号就pop出然后按照符号计算。我们来看看计算顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">式子: 3 5 2 * + 8 *</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                  top</div><div class="line">===========================</div><div class="line"></div><div class="line">step 1: 3 5 2 * + 8 * </div><div class="line">        ^  压入 3</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                    3</div><div class="line">===========================</div><div class="line"></div><div class="line">step 2: 3 5 2 * + 8 * </div><div class="line">          ^  压入 5</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                  3 5</div><div class="line">===========================</div><div class="line"></div><div class="line">step 3: 3 5 2 * + 8 * </div><div class="line">            ^  压入 2</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                3 5 2</div><div class="line">===========================</div><div class="line"></div><div class="line">step 4: 3 5 2 * + 8 * </div><div class="line">              ^  遇到* 操作符，弹出两次</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                    3    -&gt;  5 2 * 计算 5*2 = 10</div><div class="line">===========================</div><div class="line"></div><div class="line">step 5: 3 5 2 * + 8 * </div><div class="line">              ^  上一步得到的结果压入</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                 3 10</div><div class="line">===========================</div><div class="line"></div><div class="line">step 6: 3 5 2 * + 8 * </div><div class="line">                ^  遇到+操作符，弹出两次</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                          -&gt;  3 10 + 计算 3+10 = 13</div><div class="line">===========================</div><div class="line"></div><div class="line">step 7: 3 5 2 * + 8 * </div><div class="line">                ^  上一步得到的结果压入</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                   13</div><div class="line">===========================</div><div class="line"></div><div class="line">step 8: 3 5 2 * + 8 * </div><div class="line">                  ^  压入 8</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                 13 8</div><div class="line">===========================</div><div class="line"></div><div class="line">step 9: 3 5 2 * + 8 * </div><div class="line">                    ^  遇到操作符*，弹出两次</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                          -&gt;  13 8 * 计算 13*8 = 104</div><div class="line">===========================</div><div class="line"></div><div class="line">step 10: 3 5 2 * + 8 * </div><div class="line">                     ^  上一步得到的结果压入</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                  104</div><div class="line">===========================</div><div class="line"></div><div class="line">step 10: 3 5 2 * + 8 * </div><div class="line">                      ^  遇到了式子的结尾，弹出stack</div><div class="line">Stack:</div><div class="line">===========================</div><div class="line">bottom                          -&gt;  104  结果是104</div><div class="line">===========================</div><div class="line">如果到了式子结尾，这里stack内依然有内容，则表达式有错误。</div></pre></td></tr></table></figure></p>
<p>我们可以看到，实际上这种形式存储的计算式，后序遍历之后通过堆栈压入弹出可以很轻易的进行计算。这种后缀表达式的计算方式逻辑如下：<br>如果遇到数字，压入堆栈。<br>如果遇到计算符号，弹出两次，计算之后将结果压入。<br>重复这一步骤直到式子结束，式子正确的情况下，我们就可以得到式子的正确结果啦。</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>这一章我们介绍了深度优先遍历的三种顺序和常见的应用。中序遍历的输出结果会是按照顺序的，先序和后序则有其他的应用方式。<br>我们来稍微看一下三种便利的输出有什么不同吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    BinaryTree&lt;Integer&gt; intTree = new BinaryTree&lt;&gt;();</div><div class="line">    IntStream.range(0, 20).forEach(i -&gt; intTree.add((int) (Math.random() * 100)));</div><div class="line">    preOrder(intTree.root);</div><div class="line">    inOrder(intTree.root);</div><div class="line">    postOrder(intTree.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Output:</div><div class="line">pre-order: </div><div class="line">90 56 6 3 10 43 14 33 18 27 39 40 50 73 61 87 74 </div><div class="line"></div><div class="line">in-order: </div><div class="line">3 6 10 14 18 27 33 39 40 43 50 56 61 73 74 87 90 </div><div class="line"></div><div class="line">post-order</div><div class="line">3 27 18 40 39 33 14 50 43 10 6 61 74 87 73 56 90</div></pre></td></tr></table></figure></p>
<p>我们可以看到，中序会给出顺序。这也是一种排序的思路，既将全部的数字都插入二叉树，然后中序遍历。耗时分析为：<br>正常情况下，二叉树插入为log n，所以插入全部则是 O(n log(n))。遍历的耗时是O(n)，排序则是O(n log(n))。跟快排，merge排序和堆排序一样。但是二叉树的最好情况就是这样，最差情况下，有顺序的插入会带来n的插入耗时，既全部插入用时O(n^2)，排序总耗时 O(n^2)。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>深度优先就介绍到这里，下一章我们会介绍二叉树的广度优先遍历，并将使用堆栈和队列来实现更多的遍历方式。<br>下面是这一章实现的代码，请感兴趣的同学自取 :-)</p>
<p><br>二叉树遍历之一。<br><br>
<button onclick="window.open('BinaryTreeDepthFirst.java')">点我下载 BinaryTreeDepthFirst.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binary-Tree-traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree traversal&quot;&gt;&lt;/a&gt;Binary Tree traversal&lt;/
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://alex-mengx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>第3天的Stack和Queue</title>
    <link href="https://alex-mengx.github.io/2017/03/11/postStackAndQueue/"/>
    <id>https://alex-mengx.github.io/2017/03/11/postStackAndQueue/</id>
    <published>2017-03-11T06:13:50.000Z</published>
    <updated>2017-03-19T00:33:26.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><p>堆栈与队列</p>
<h1 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1.Abstract"></a>1.Abstract</h1><p>今天我们来聊一聊stack和queue。这两个数据结构在很多场合都有很有趣的应用。</p>
<h1 id="2-Stack"><a href="#2-Stack" class="headerlink" title="2. Stack"></a>2. Stack</h1><p>堆栈是一个很有趣的结构。还记得我们之前实现的链表LinkedList吗？堆栈stack就可以用链表来实现。我们先来看看堆栈是什么。堆栈是一个先进后出的结构，这个结构中的元素的出入顺序是无法改变的。想象一下手枪的弹夹，假设现在你有一个空的弹夹，在使用之前，你需要一颗子弹一颗子弹的将子弹压入弹夹。那么在上膛之后射击的过程中，你会发现，最先被激发的子弹是最后被压入弹夹的那一颗，而最后被激发的子弹则是第一个被压入的。同时，你并不需要将子弹压满弹夹，只要弹夹里有子弹， 你就可以上膛射击。同样，你也不需要将弹夹打空才能重新压入，只要弹夹有空间，你随时都可以取出弹夹压入新的子弹。这跟堆栈的操作方式是十分类似的。</p>
<h2 id="2-1-Stack-Operations"><a href="#2-1-Stack-Operations" class="headerlink" title="2.1 Stack Operations"></a>2.1 Stack Operations</h2><p>堆栈有两个最基本的操作，就是压入push和取出pop，也就是子弹压入push进弹夹，和射击时子弹被弹出pop。我们在链表中实现的操作有插入删除查找和修改，实际上用链表就可以很轻易的实现一个堆栈的结构。我们在这里将使用我们之前创建的LinkedList来实现堆栈。</p>
<h2 id="2-2-Stack-Implementation"><a href="#2-2-Stack-Implementation" class="headerlink" title="2.2 Stack Implementation"></a>2.2 Stack Implementation</h2><p>首先来实现一个堆栈的框架。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Stack&lt;E&gt; &#123;</div><div class="line">    LinkedList&lt;E&gt; stack;</div><div class="line">    int currentAmount;</div><div class="line"></div><div class="line">    public Stack () &#123;</div><div class="line">        this.stack = new LinkedList&lt;&gt;();</div><div class="line">        this.currentAmount = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>非常简单，我们需要一个LinkedList来作为存储数据的结构，需要一个currentAmount变量来追踪目前堆栈内的元素的数量。其实如果我们的LinkedList可以实现一个size方法来返回链表中的节点的数量，这样在堆栈中我们就不需要这个currentAmount了，但是因为我们的链表的设计并不完善，我们只好用额外的类变量来记录元素数量。这说明一开始的目标和设计很重要，另外使用现成的轮子也很重要（笑。我们知道，Java中是有List接口(interface)的，实际上正确的做法是使得我们的LinkedList链表implements List接口，这样我们就可以实现全部List所需要的方法了。不过既然链表已经完成了，我们就用这个不完善的链表来实现这个堆栈吧。</p>
<h3 id="2-2-1-Push-and-Pop"><a href="#2-2-1-Push-and-Pop" class="headerlink" title="2.2.1 Push and Pop"></a>2.2.1 Push and Pop</h3><p>入栈，就是将一个元素推入堆栈的方法。这个元素将会成为堆栈最顶端的元素，如果这次入栈之后的下一个操作是出栈pop的话，那么这个元素就会被取出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| 2 | 4 | 1 | 6       &lt;-  push 8</div><div class="line">底端          顶端</div><div class="line">| 2 | 4 | 1 | 6 | 8</div></pre></td></tr></table></figure></p>
<p>原本的堆栈的顶端是6，我们将8推入之后，顶端变成了8。很好理解，就像包装好的桶装羽毛球，装入第二个，第一个就会被压入底部。出栈也是很类似的，当堆栈不为空时，pop就会退出堆栈的顶部元素，并且返回该元素，就如同你从羽毛球筒中拿出了顶部的羽毛球，现在原本排在第二的羽毛球就成为了顶部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| 2 | 4 | 1 | 6 | 8   -&gt;  pop </div><div class="line">底端          顶端</div><div class="line">| 2 | 4 | 1 | 6               return 8</div></pre></td></tr></table></figure></p>
<p>实现也很简单，我们来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void push(E e) &#123;</div><div class="line">    this.stack.add(e);</div><div class="line">    this.currentAmount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E pop() &#123;</div><div class="line">    if (this.currentAmount &gt; 0)&#123;</div><div class="line">        this.currentAmount--;</div><div class="line">        return this.stack.removeFirst();</div><div class="line">    &#125; else return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相比于二叉树，这两个操作的逻辑实在是太简单了。push很好理解，直接将元素e从头部放入链表中，链表本身就会保持元素插入的顺序。pop也很好理解，如果堆栈中元素数量大于零，那么就从链表的头取出一个元素，并且堆栈元素数量减一。</p>
<h3 id="2-2-2-Peek-and-Size"><a href="#2-2-2-Peek-and-Size" class="headerlink" title="2.2.2 Peek and Size"></a>2.2.2 Peek and Size</h3><p>另外堆栈还有两个很有用的方法，一个是查看顶端元素peek，一个是元素数量size。这两个方法可以用来查看但是不移除堆栈的元素，和查看当前堆栈内的元素的数量。当然也可以添加一些辅助性的方法比如是否为空isEmpty，当内部元素数量为0时返回true，反之则返回false。我们来看看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public E peek() &#123;</div><div class="line">    if (isEmpty())</div><div class="line">        return null;</div><div class="line">    </div><div class="line">    E e = pop();</div><div class="line">    push(e);;</div><div class="line">    return e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int size() &#123;</div><div class="line">    return currentAmount;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isEmpty() &#123;</div><div class="line">    return currentAmount == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样,一个简单的堆栈就实现完成了。那么这个堆栈能用来做什么呢？我们一会再说，先看看这篇文章的另一个重点，队列。</p>
<h1 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h1><p>队列是一个很有用的结构。在很多复杂的应用中都可以看到它的身影。这个结构跟堆栈有一些类似的地方，也可以用一个链表来实现。跟堆栈不同的是，这个结构的元素的出入顺序是先进先出的。同样，队列中元素的出入顺序是无法改变的，先进入队列的元素一定会先出队列。这个队列我们会从头开始实现，以便加深理解，同时也可以和堆栈的实现方式作对比。</p>
<h2 id="3-1-Queue-Operations"><a href="#3-1-Queue-Operations" class="headerlink" title="3.1 Queue Operations"></a>3.1 Queue Operations</h2><p>队列有两个基本操作，进入队列push和从队列中取出poll。顾名思义，push就是将某元素推入队列，poll就是从队列中取出一个元素。除了这两个基本操作之外，跟堆栈一样，isEmpty和size也是很有用的方法。另外peek方法也很有帮助，同样可以查看但是不移除下一个将被拿出队列的元素。因为这一次我们要从头来实现一个队列，所以我们将不借助任何现有的结构。我们先来看看这两个主要的方法，然后再来设计我们该如何实现我们的队列。</p>
<h3 id="3-1-1-Push-and-Poll"><a href="#3-1-1-Push-and-Poll" class="headerlink" title="3.1.1 Push and Poll"></a>3.1.1 Push and Poll</h3><p>这里我们就不多话了，看图吧。push方法：从顶端推入新的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">8 push  -&gt;   2 | 4 | 1 | 6 </div><div class="line">           顶端       底端</div><div class="line">         8 | 2 | 4 | 1 | 6</div></pre></td></tr></table></figure></p>
<p>poll方法：从底端拿出队列中最先进入的元素。注意，所有的元素都是从顶端推入的，且进入队列后顺序不可更改，所以底端的元素一定是目前队列全部元素中最先进入的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">8 | 2 | 4 | 1 | 6 </div><div class="line">  顶端       底端</div><div class="line">8 | 2 | 4 | 1     -&gt;  poll 6</div></pre></td></tr></table></figure></p>
<h2 id="3-2-Queue-Design"><a href="#3-2-Queue-Design" class="headerlink" title="3.2 Queue Design"></a>3.2 Queue Design</h2><p>我们看到，队列首先是一个链状的结构。那么我们应该可以使用类似链表的结构来实现。但是我们仔细观察后发现，队列的操作是在两个方向的。换句话说，在堆栈中，我们可以通过操作链表的头来进行push和poll，因为元素只会从一个方向进入或被拿出，但是对于队列，我们需要知道一条链表的头和尾，因为我们将会从一端插入，另一端取出。链表的特性并不能满足这一要求，因为链表只有指向下一个节点的指针，就像在寻宝的过程中，你只能找到下一个藏宝点，而上一个藏宝点的位置已经不可知了。这样的话，如果我们的结构和链表完全一样，则如果每次插入都是在链表头部root节点，那么当我们取出(poll)的时候，我们就需要遍历整条链表。怎么解决这个问题呢？我们有两个选择。<br>1. 我们可以使用array。数组对于某个index位置的读取是O(1)操作，跟数组的元素数量没关系，这会使得队列的入队和出队都是O(1)操作。<br>2. 我们也可以使用双向链表。双向链表跟链表的区别就是，双向链表每个节点保有两个指针，分别指向前一个和后一个节点。这样我们也能实现O(1)操作，不会影响性能。</p>
<h2 id="3-3-Queue-Implementation"><a href="#3-3-Queue-Implementation" class="headerlink" title="3.3 Queue Implementation"></a>3.3 Queue Implementation</h2><p>在这个实现中，我们将使用简化版的双向链表。先来看看大体框架。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Queue&lt;E&gt; &#123;</div><div class="line">    Node top;</div><div class="line">    Node bottom;</div><div class="line">    </div><div class="line">    class Node &#123;</div><div class="line">        E e;</div><div class="line">        Node previous;</div><div class="line">        Node next;</div><div class="line">        </div><div class="line">        public Node(E e, Node previous, Node next) &#123;</div><div class="line">            this.e = e;</div><div class="line">            this.previous = previous;</div><div class="line">            this.next = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Queue() &#123;</div><div class="line">            this.top = null;</div><div class="line">            this.bottom = null;</div><div class="line">            this.size = 0;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，很类似链表的结构，只不过我们单个节点有了指向前节点的指针。另外不同于链表只有一个root节点，我们的队列有了top和bottom两个节点，分别指向我们的顶端和底端。我们来继续实现需要的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void push(E e) &#123;</div><div class="line">    this.top = new Node(e, null, top);</div><div class="line">    if (size++ == 0) &#123;</div><div class="line">        this.bottom = top;</div><div class="line">    &#125; else &#123;</div><div class="line">        this.top.next.previous = top;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E poll() &#123;</div><div class="line">    if (size == 0)</div><div class="line">        return null;</div><div class="line">    E e = bottom.e;</div><div class="line">    this.bottom = bottom.previous;</div><div class="line">    if (this.bottom != null)</div><div class="line">        this.bottom.next = null;</div><div class="line">    size--;</div><div class="line">    return e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E peek() &#123;</div><div class="line">    if (size == 0)</div><div class="line">        return null;</div><div class="line">    return bottom.e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int size() &#123;</div><div class="line">    return size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isEmpty() &#123;</div><div class="line">    return size == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>push的操作比较好理解，我们用图来表示这个双向链表来帮助理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">初始为空的队列：</div><div class="line">    top -&gt; null </div><div class="line">    null &lt;- bottom</div><div class="line"></div><div class="line">插入新节点1：</div><div class="line">    top  -&gt;  new Node 1: previous, next -&gt; null</div><div class="line">    null &lt;-                             &lt;- bottom</div><div class="line">    因为之前队列是空的，所以再插入第一个节点之后，top和bottom就都是这个节点了。</div><div class="line"></div><div class="line">插入新节点2：</div><div class="line">    top  -&gt;  new Node 2: previous, next -&gt; node 1 -&gt; null</div><div class="line">    null &lt;-                             &lt;-        &lt;- bottom</div><div class="line">    我们可以看到，插入都是在top进行的。</div></pre></td></tr></table></figure></p>
<p>从图上我们可以看到，插入的新节点都在top。插入的逻辑我们来看代码和图。只要是执行插入一个新节点的操作，我们就使得top等于这个新的节点，然后使这个新节点的next指向旧的top。这样，我们就在队列的顶端放入了一个新的节点。但是还没完，如果我们发现队列是空的，这是第一个节点，那么说明这个点也是底端节点，所以我们使得bottom也等于这个新节点。如果队列不为空，这说明新节点的next指向的旧的top是有节点的，所以我们要使得新节点的next的previous等于新节点。看起来有点绕，但是逻辑是很清楚的。新节点知道自己的next是旧的top。但是旧的top并不知道自己的previous变成了新节点。所以旧的top的previous依旧是null，需要我们来使得它指向新节点。poll的逻辑也是类似的。如果为空，返回null，否则返回底部的元素，并且使bottom指向bottom的前一个元素。这里注意的是，如果bottom不为null，则我们希望设置bottom的next指针为null。如果没有这一步，队列一样可以正常工作，但是在内存中，我们实际上将会保留全部插入过得元素，只有bottom指针的位置在随着poll出元素而改变。这样运行时间长了内存会被占用的越来越多。所以将不在使用的对象赋值成为null，保证没有指针指向可以被销毁的对象，是保证内存低占用的关键之一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">队列： 4，1，7，9，4，3，6</div><div class="line">    top -&gt; 4 -&gt; 1 -&gt; 7 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; null</div><div class="line">    null &lt;-  &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;- bottom</div><div class="line"></div><div class="line">poll: 有设置next = null</div><div class="line">    top -&gt; 4 -&gt; 1 -&gt; 7 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; null       poll 6</div><div class="line">    null &lt;-  &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;- bottom</div><div class="line"></div><div class="line">poll：没有设置next = null</div><div class="line">    top -&gt; 4 -&gt; 1 -&gt; 7 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; null</div><div class="line">    null &lt;-  &lt;-   &lt;-   &lt;-   &lt;-   &lt;-   &lt;- bottom</div></pre></td></tr></table></figure></p>
<p>区别很明显，没有this.bottom.next = null的话，从top到bottom的链表会越来越长，没有元素会被删除，只有bottom指针在随着poll不断地向左移动。想象一下我们这个队列是一个系统的消息队列，那么内存占用就会随着消息的传递而越来越大，就算队列表现为空，实际内存占用依然会居高不下，直到出现OutOfMemoryError或者虚拟机停机为止。所以在日常的工作或者学习中，注意内存的合理使用和销毁不必要的对象是很有必要的。</p>
<h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h2><p>今天我们实现了队列和堆栈这两种新的数据结构，这两种结构在一些算法的实现中非常常见。明天我们将会介绍一些有趣的问题，并且使用队列和堆栈来解决。</p>
<p><br>惯例，下面是这篇文章实现的队列和堆栈，需要的读者可以尝试运行。<br><br>
<button onclick="window.open('QueueStack.java')">点我下载 QueueStack.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Stack-and-Queue&quot;&gt;&lt;a href=&quot;#Stack-and-Queue&quot; class=&quot;headerlink&quot; title=&quot;Stack and Queue&quot;&gt;&lt;/a&gt;Stack and Queue&lt;/h1&gt;&lt;p&gt;堆栈与队列&lt;/p&gt;
&lt;h1 id=&quot;
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>第2天的BinaryTree</title>
    <link href="https://alex-mengx.github.io/2017/03/01/postBinaryTree/"/>
    <id>https://alex-mengx.github.io/2017/03/01/postBinaryTree/</id>
    <published>2017-03-02T03:57:09.000Z</published>
    <updated>2017-03-11T06:10:40.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Binary tree - a tree with binary branches.<br>在阅读这篇文章之前，如果你对于链表和递归不是很了解的话，建议先阅读一下这两篇文章，他们分别用简单生动的例子描述了递归和链表，对于理解本文会非常有帮助。<a href="https://alex-mengx.github.io/data-structure/2017/02/11/postLinkedList/">第1天的LinkedList</a> <a href="https://alex-mengx.github.io/data-structure/2017/02/24/postRecursive">第1天的递归</a>。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>二叉树，是鼎鼎大名的数据结构。我们之前讲过递归，我们已经理解了递归的含义和作用，二叉树其实也可以用递归的思想来理解。在理解结构之前，我们还是先来用生活的例子来浅尝辄止的接触一下。首先我们来回忆一下链表中那个藏宝和纸条的例子。在那个故事中，每个藏宝点都有一个宝藏和一张写着下一个藏宝点的纸条，而你的手中则掌握着指向第一个藏宝点的纸条。这样的话，只要你始终保有这张最初的纸条，你就总能够找到第一个藏宝点，进而沿着链路一直找到这条链的终点。现在我们来设想一种新的情况。你手中依旧掌握着一张最初的纸条，指向了某个藏宝的地点。然而，这一次，每个藏宝点都有两张纸条，指向了两个不同的藏宝点。你在找寻的过程中，就需要在每一个二叉路口作出决定：“向左走？向右走？”。这就是一颗由藏宝点构成的二叉树。链表有一个特性，就是无论从哪一个点开始访问，这个点向后一直到终点都是一条链表。二叉树有着一样的特性。一个二叉树的结构可以理解为它是由一个根节点和两个二叉树所构成的树。一个二叉树，它的两边的子树是两颗完整的二叉树。就如同宝藏二叉树，无论你站在哪个藏宝点，两张纸条上所标示的地点都是完整的二叉树。递归的特性就在这里体现了出来。针对根节点设计的方法，对于左右两个子树就会同样适用。</p>
<h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>我们来通过修改之前的LinkedList来一步一步的实现这个二叉树。先来看节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Node &#123;</div><div class="line">    E treasure;</div><div class="line"></div><div class="line">    Node left;</div><div class="line">    Node right;</div><div class="line"></div><div class="line">    public Node(E treasure, Node left, Node right) &#123;</div><div class="line">        this.treasure = treasure;</div><div class="line">        this.left = left;</div><div class="line">        this.right = right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到，这个节点跟链表的节点十分的类似，唯一的区别就是多了一个指向其他的节点的指针。这样这个节点就可以存储一份宝藏，同时可以指向另外两个藏宝点。但是，如果这两个藏宝点只是随便指向其他的点，那么我们寻找特定宝藏的时候就会很麻烦，可能需要走遍全部的宝藏才会找到。那么，我们怎样可以使得找寻特定宝藏这个操作变得简单快速呢？这其实就是二叉树的重要特性之一，有序性。在我们从零节点开始创建这个宝藏二叉树的时候，我们的插入就是有目的性的。想象一下，每个藏宝点的宝藏跟它所指向的下两个藏宝点的宝藏都有一定的关系，比如从你能去到的第一点开始，你就发现那里的两张纸条写着“食物向左”和“玩具向右”。如果我们想寻找“棉花糖”这个宝藏，我们就会向左走。左边的节点的两张纸条则是“糖果向左”和“饮料向右”， 我们就需要继续向左。依次深入，我们就会找到我们所找寻的棉花糖。在实际操作中，则可以是数字的大小，字符串的顺序等等。所以，从根节点开始，到任意一个叶节点 - 叶节点就是左右子树都是null的节点，也就是类似链表的终点，只不过这个终点在树中不唯一 - 都是一条完整的链表，链表的元素则是从小到大或者从大到小，或者是其他的某种顺序。所以，树可以被想象成多条链表，只不过相互有重合。现在我们来构建一个树的基本框架，方便我们后面的实现。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class BinaryTree &lt;T extends Comparable&lt;T&gt;&gt; &#123;</div><div class="line">    Node root;</div><div class="line"></div><div class="line">    class Node &#123;</div><div class="line">        T treasure;</div><div class="line">        Node left;</div><div class="line">        Node right;</div><div class="line">        public Node(T treasure, Node left, Node right) &#123;</div><div class="line">            this.treasure = treasure;</div><div class="line">            this.left = left;</div><div class="line">            this.right = right;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        @Override</div><div class="line">        public String toString()&#123;</div><div class="line">            return Optional.ofNullable(left).map(node -&gt; node.toString()).orElse(&quot; &quot;) </div><div class="line">                    + &quot; &quot; + treasure.toString() + &quot; &quot;</div><div class="line">                    + Optional.ofNullable(right).map(node -&gt; node.toString()).orElse(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是我们的树啦。为什么这个树的节点所包含的宝藏要是Comparable呢？我们先回忆一下之前的Java特性那篇文章。<a href="https://alex-mengx.github.io/data-structure/2017/02/17/postJavaProperties/">第1天的Java特性</a> 从这里，我们知道了extends的效果就是使得类可以从父类中继承所有的非私有方法和元素。在我们这棵树中，节点所包含的宝藏的类型是未知的，这样我们就可以装入任何的类型。但是，为了使得树的特性可以表现出来，既装入的元素需要可以判断相互关系。比如数字，比如字符串，或者其他的可以比较的类型。所以，这里的<code>BinaryTree &lt;T extends Comparable&lt;T&gt;&gt;</code>就限制了T必须要是Comparable的子类。也就是说，T必须要实现了T.compareTo(T t)的方法，返回-1,0,1来代表大于等于和小于的关系。这样，我们在放入元素的时候，就可以按照比如小的放左边，大的放右边的规律来插入。我们在实现插入查找之类的方法的时候，就会具体看到有这种关系和规律所带来的便利之处。另外多提一点，因为二叉树是递归的所以左右两侧都是两个完整的二叉树。所以假设我们有二叉树A，根节点包含了数字n，那么A的左边子树所包含的数字一定都小于n，而右边的子树则一定只包含大于n的数字。这条规律同样是递归的，适用于任何一个A的子树。比如对于A的某个右侧的子树n+m，则有n+m的左子树的全部数字都小于n+m，右子树的全部数字都大于n+m。这条推论反之也是成立的，既对于树A所包含的全部数字，小于n的一定在左侧。而子树n+m，这棵子树所包含的数字中小于n+m的数字也一定在子树n+m的左侧。你或许会感到矛盾，n不是也小于n+m吗？可是n作为A的根节点，怎么可能会在n+m这颗子树的左边子树呢？是的，注意n+m所包含的数字合集是远小于A的，n并不在n+m这棵树包含的数字中。只有n+m树所包含的数字，才符合这个逻辑。另外或许你对于这个toString方法很困惑，不要紧，我们先实现别的方法，最后再来看它，到时候你会很容易就理解它。</p>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>插入对于二叉树是很简单的。假设我们要插入数字n，来看逻辑：</p>
<ol>
<li>首先看根节点。如果root是null，则root变成新的Node(n, null,null)，既包含数字n，左右子树皆为null，返回即可。</li>
<li>逻辑分支一：如果能进行到这里，证明root不是null。那么我们来比较n和root.treasure,如果小于，则插入左边的子树。</li>
<li>逻辑分支二：如果n大于root.treasure，则插入右边的子树。</li>
</ol>
<p>重点在这里，我们如果用loop，代码量和判断会比较复杂。如果用递归的思想来解决这个问题，则会简化很多。我们来做一下简单的思维实验和设计。首先我们需要一个方法，这个方法的操作必须要针对一颗二叉树，这样对于子树我们就可以重复调用这么方法。其次我们需要边界判断，在条件满足的时候要停止继续递归深入。我们来先看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void add(T t) &#123;</div><div class="line">    if (t == null)</div><div class="line">            return;</div><div class="line">    if (root == null)</div><div class="line">        root = new Node(e, null, null);</div><div class="line">    else add(t, root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void add(T t, Node root)&#123;</div><div class="line">    if (root.treasure.equals(t))</div><div class="line">        return;</div><div class="line">    if (root.treasure.compareTo(t) &gt; 0)&#123;</div><div class="line">        if (root.left == null)</div><div class="line">            root.left = new Node(t, null, null);</div><div class="line">        else add(t, root.left);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (root.right == null)</div><div class="line">            root.right = new Node(t, null, null);</div><div class="line">        else add(t, root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个add方法只接受一个T作为参数，它更像是一个对外的接口，接受了要插入的元素T之后和跟节点一起传递给我们的递归的add方法。而私有的add方法就是我们的重点了。我们来看看每一行的逻辑。首先是签名，这个方法接受要插入的元素e，和开始插入的根节点root，然后将e插入到root树中合适的位置。在来看这个方法的实现，首先我们需要判断这个根节点root所保存的元素与要被插入的元素t是否相等。因为我们限制了T必需是Comparable的子类，所以T一定有compare这个方法的实现。通过判断，如果root元素与t相等，则我们可以停止插入的动作并且返回，因为我们不想插入同样的元素。继续看下面的代码。如果不相等，则我们需要用conpareTo方法来判断root元素和t的关系，用这个关系来决定t应该被插入哪边的子树。在这个实现中，如果t小于root元素，则我们插入左边。反之则插入右边。再决定了插入哪侧子树之后，我们查看这一侧的树是否是null，如果是null，则新建一个节点，让root的对应的指针指向这个节点。而如果这一侧的树不为null，则我们需要做的事情就是获取这个子树的根节点和t然后找到一个方法可以接受子树的root节点和t，来将t插入到子树合适的位置。由二叉树和递归的特性可以知道，二叉树的子树也是一个完整的二叉树，而子树的根节点就是父节点的某一侧的节点。由此可知，我们实现的add方法，不仅对于根节点root和t有效，应该也对于root.left或者root.right和元素t有效。所以我们可以递归调用<code>add(T t, Node root)</code>方法来实现插入。<br>我们来看一个实际运行的例子。假设我们有数字集合<code>{4,2,9,5,7}</code>，我们来按照代码一步一步的插入这些数字到一个空的二叉树中。<br>插入数字4，add(4)。root为null，所以root = new Node(4, null,null);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    4   // first number, in the root</div><div class="line">  /   \</div><div class="line">null  null</div></pre></td></tr></table></figure></p>
<p>插入数字2，add(2). 因为root 不为 null, 所以我们调用add(4, root)。 进入私有add方法，2小于4，所以2将被插入4的左边的子树。4左边为null，所以建立新的节点new Node(2, null, null)，4的左侧指向新的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">       4   </div><div class="line">     /   \</div><div class="line">    2   null</div><div class="line">  /   \</div><div class="line">null  null</div></pre></td></tr></table></figure></p>
<p>插入数字9，add(9). 因为root 不为 null, 所以我们调用add(9, root)。 进入私有add方法，9大于4，所以所以9将被插入4的右边的子树。4右边为null，所以建立新的节点new Node(9, null, null)，4的右侧指向新的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">            4  </div><div class="line">         /    \  </div><div class="line">       2       9</div><div class="line">    /   \     /   \</div><div class="line">null  null  null  null</div></pre></td></tr></table></figure></p>
<p>插入数字5，add(5). 因为root 不为 null, 所以我们调用add(5, root)。 进入私有add方法，5大于4，所以所以5将被插入4的右边的子树。4右边的子树不为null，我们对5和4的右子树调用add方法。add(5, 9)。5小于9，所以5将被插入9左边的子树。9左边为null，所以我们建立新的节点new Node(5, null, null),使得9的左边指向这个新节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">            4  </div><div class="line">         /    \  </div><div class="line">       2       9</div><div class="line">    /   \     /   \</div><div class="line">null  null   5   null</div><div class="line">           /  \</div><div class="line">        null  null</div></pre></td></tr></table></figure></p>
<p>插入数字7，同样的调用和判断方式，7将被插入5的右侧子树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">            4  </div><div class="line">         /    \  </div><div class="line">       2       9</div><div class="line">    /   \     /   \</div><div class="line">null  null   5   null</div><div class="line">           /  \</div><div class="line">        null   7</div><div class="line">             /   \ </div><div class="line">         null    null</div></pre></td></tr></table></figure></p>
<p>这个例子的讲解比较繁琐和细致，基本体现到了每一行代码的执行过程。这样我们对于二叉树插入操作的递归方式应该就有了具体的了解。接下来我们来看看查找操作。</p>
<h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>查找的代码跟插入十分的类似，基本逻辑是一样的。首先判断根节点的元素是否是查找的目标元素，不是的话就根据查找的目标和根节点的元素的比较关系判断应该向左右两侧哪一侧深入查找，然后用递归的方式查找子二叉树。我们来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean contains(final T t) &#123;</div><div class="line">    if (t == null || root == null)</div><div class="line">        return false;</div><div class="line">    else return contains(t, root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean contains(final T t, final Node root) &#123;</div><div class="line">    if (root == null)</div><div class="line">        return false;</div><div class="line">    if (root.treasure.equals(t))</div><div class="line">        return true;</div><div class="line"></div><div class="line">    if (root.treasure.compareTo(t) &gt; 0)</div><div class="line">        return contains(t, root.left);</div><div class="line">    else return contains(t, root.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与add方法一样，public的contains方法提供了一个接口，并对于根节点root调用了递归的私有contains方法。私有contains方法中递归的边界条件有两个，第一个是找到了尽头，即root等于null，这说明我们按照逻辑判断走到了尽头，依旧没有找到目标元素，则目标元素不存在。第二个边界条件则是当前root节点就包含着目标元素，则我们返回true表示目标元素存在。如果这两个边界条件都不满足，则说明我们目前还没有找到目标元素，我们需要继续向下查找，所以根据大小判断，我们来决定向左侧或者右侧递归深入。这里就不在给出具体例子和逐行代码运行解释了，可以按照上面add方法的例子来自行尝试。</p>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>删除的逻辑就要稍微复杂一点了。因为我们需要在删除了某个节点之后，整个二叉树必须要继续遵循我们订好的规律和要求。之前的例子中为了方便查看我们把为null的子节点也标示了出来，后面的例子将不再标示null。看下图中的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     4  </div><div class="line">  /    \  </div><div class="line">2        9</div><div class="line">       /    \  </div><div class="line">     6       12</div><div class="line">   /  \     /  \</div><div class="line">  5    7   11   14</div></pre></td></tr></table></figure></p>
<p>这颗二叉树是符合我们的逻辑的。即对于每一个节点，以这个节点为根节点的二叉树都符合这样的要求：左边的子树包含的数字一定小于这个根节点，右边的子树所包含的数字一定大于这个根节点。举例来说，我们看到数字9这个节点，那么以这个节点作为根节点的二叉树则包含了<code>{9,6,12,5,7,11,14}</code>这几个数字。那么在9左边的子树包含的数字是6，5和7，全部小于9，而右边子树包含的数字是12,11和14，则全部大于9。对于任意一个节点，这个规定都一定成立。那么当我们需要删除一个节点的时候，会发生什么情况呢？如果我们删除2 ，5，7，11 或者14，那么我们可以直接删除这些节点，因为这些节点在叶子上，它们都没有子节点，所以删除它们不会对树的特性有任何的影响，这棵树依旧会符合我们上述的要求和逻辑。但是如果我们试图删除节点9，那么会发生什么呢？二叉树的特性决定了一个节点如果有子节点，那么这个节点一定不能为空，因为我们需要这个节点的元素来进行比较，进而判断节点左右子树的大小规律。所以如果我们想要删除一个节点，那么我们必须要重新对二叉树的结构进行整理，来保障二叉树的性质不变。继续看图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     4  </div><div class="line">  /    \  </div><div class="line">2        删除9这个节点</div><div class="line">       /    \  </div><div class="line">     6       12</div><div class="line">   /  \     /  \</div><div class="line">  5    7   11   14</div></pre></td></tr></table></figure></p>
<p>我们需要一个方法来从9的子树之中选出合适的数字填在被删除的节点的位置。具体做法我们后面来讲。现在我们来总结一下删除节点可能会遇见的几种情况：</p>
<ol>
<li>删除的节点没有子节点。</li>
<li>删除的节点有一个子节点。</li>
<li>删除的节点有两个子节点。</li>
</ol>
<p>我们来依次看这三种情况吧。</p>
<h5 id="1-没有子节点的情况。"><a href="#1-没有子节点的情况。" class="headerlink" title="1. 没有子节点的情况。"></a>1. 没有子节点的情况。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">// 删除数字7</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /        /  \</div><div class="line">             5        11   14</div></pre></td></tr></table></figure>
<p>直接删除就可以了，6.right = null; 对于树的结构没有影响。</p>
<h5 id="2-有一个子节点的情况"><a href="#2-有一个子节点的情况" class="headerlink" title="2. 有一个子节点的情况"></a>2. 有一个子节点的情况</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                7       12</div><div class="line">              /        /  \</div><div class="line">             6        11   14</div><div class="line">           /   \</div><div class="line">          5     8</div><div class="line"></div><div class="line">// 删除数字7</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /   \</div><div class="line">             5    8   11    14</div></pre></td></tr></table></figure>
<p>如果只有一个子节点，那么只要将子节点的整个树都放在被删除的节点的位置就可以了。这是因为，由于二叉树的性质，节点7由于在9的左侧，所以以7为根节点的树的全部元素都一定小于9，所以只要拿走7，并将7唯一的子节点放在7的位置上，这样二叉树就会保持原有的性质。</p>
<h5 id="3-有两个子节点的情况"><a href="#3-有两个子节点的情况" class="headerlink" title="3. 有两个子节点的情况"></a>3. 有两个子节点的情况</h5><p>这个情况就会复杂一下，需要一些变换。依旧可以依靠递归的思想来解决问题。先来说一下基本逻辑：假设要被删除的节点为N，N节点有左右两个子树，则我们需要从子树中找到合适的数字来放在这个被删除的节点N。对于有两个子节点的情况，我们实际上不需要真的删除这个节点，我们可以替换节点中的数字。为了保证节点N左边的子树的数字都小于这个新数字，右边的子树的数字都大于这个新数字，我们有两个选择。我们可以从左树中找到最大的数字，或者从右树中找到最小的数字，放在N节点，这样的话N节点左右的子树就会依旧保证遵循同样的规律。但是用数字替换了N节点之后，子树中就出现了重复的数字，我们需要删除这个数字。我们可以用递归的思想，从子树中删除这个数字。我们用图像来看看两个节点的删除方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">// 删除数字9</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        7 // 在这个例子中我们将使用左树最大值来代替被删除的节点。</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">// 用同样的方法删除7， 7没有子节点，则情况1的逻辑适用。</div><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        7</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /        /  \</div><div class="line">             5        11   14</div></pre></td></tr></table></figure></p>
<p>从这个例子中我们可以看到双子节点的删除逻辑。</p>
<p>上面这三种类型就是删除节点的三种情况，我们来看代码如何实现这些逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public void remove(final T t) &#123;</div><div class="line">    root = remove(t, root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Node remove(final T t, final Node root) &#123;</div><div class="line">    if (root == null)</div><div class="line">        return null;</div><div class="line">    else if (root.treasure.compareTo(t) &gt; 0)</div><div class="line">        root.left = remove(t, root.left);</div><div class="line">    else if (root.treasure.compareTo(t) &lt; 0)</div><div class="line">        root.right = remove(t, root.right);</div><div class="line">    else if (root.left != null &amp;&amp; root.right != null)&#123;</div><div class="line">        root.treasure = findMax(root.left);</div><div class="line">        root.left = remove(root.treasure, root.left);</div><div class="line">    &#125; else return root.left == null ? root.right : root.left;</div><div class="line">    return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private T findMax(Node root) &#123;</div><div class="line">    if (root.right != null)</div><div class="line">        return findMax(root.right);</div><div class="line">    return root.treasure;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>public的remove方法是一样的，是递归方法的入口。私有的findMax方法也很好理解，因为所有的节点都遵循大的数字放右边的规律，所以只需要一直向右走到尽头，该节点的数字就是这棵树的最大数字。代码的逻辑就是：如果右树不为空，则递归调用这个方法来获取右树的最大值。如果右树为空，则这个节点的数字就是最大数字，因为所有的左树的数字都小于根节点。来看这个私有的remove方法，这个方法的逻辑就稍微复杂了一点。为了简化逻辑和代码，我们用返回节点的方式来递归。这个方法接受一个元素和一个二叉树的根节点，然后返回去除了元素的二叉树。注意，这个方法是针对一个完整的二叉树设计的，也就是说只要给出元素t和二叉树的根节点root，这个方法就应该返回删除了t元素之后的二叉树。首先判断root是否为null，如果为null，说明这一个二叉树为空，我们可以直接返回null来代表这个空的二叉树。继续判断元素t和当前root.treasure的关系，t小则t有可能存在于root的左子树，反之则说明t可能会在root的右子树。之所以说t可能存在于子树，是因为也许当前树不包含t这个元素。继续往下看，确定了应当找寻的方向之后，我们需要一个方法来从子树中删除元素t，所以我们用递归的方式调用remove方法本身，且让root.子树 = remove(t, toot.子树)。remove会返回删除了元素t的二叉树，所以root.left = remove(t, root.left)或者root.right = remove(t, root.right) 就会让root的子树成为去除了元素t的二叉树。这里的逻辑稍微有点复杂，我们再来重新观察一下。首先，remove方法接受元素t和一个二叉树，然后返回删除了元素t的二叉树。所以，当root这棵树的左树包含了t，那么我们就可以使得root.left 等于remove(t, root.left)，这样root的左树就会成为删除了元素t的二叉树。让root的子树等于删除了元素t的二叉树之后，就可以返回root了，只不过我们把return root放在了最后一行。继续向下看，如果root.treasure既不大于t也不小于t，这说明当前节点就是包含了元素t的节点。那么，我们的三种情况就适用于这里了。如果左树和右树都不为null，那么我们应用第三种方法，我们使得当前root节点的元素等于左树的最大值，来保证二叉树的特性不被破坏，然后从root的左树中删除这个最大值。这里依旧递归调用remove(max_in_left, root.left)。如果左树或者右树有一个树为null，那么第二种情况就适用于这里，我们可以直接返回不为null的那个树。因为上一层的调用会使得对应的父节点的子树等于我们这一层返回的这颗树，那么这一层的root节点就会被删掉。大概逻辑是这样的：第一层 A.child = remove(n, A.child) -&gt; 第二层 return A.child.child -&gt; 第一层 A.child = A.child.child。这样，包含了目标元素t的A.child就会被删除。这就是删除的逻辑了。重点在于删除节点的三种不同的情况，和如何递归调用remove方法。</p>
<h3 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h3><p>我们已经有了contains，remove和add方法，所以修改就变得十分的容易了。直接看代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void modify(T oldT, T newT)&#123;</div><div class="line">    if (oldT == null || root == null || oldT.equals(newT))</div><div class="line">        return;</div><div class="line">    if(newT == null)</div><div class="line">        remove(oldT);</div><div class="line">    else if (contains(oldT))&#123;</div><div class="line">        remove(oldT);</div><div class="line">        add(newT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>旧值和新值，如果旧值在树立，那么就删除旧值，插入新值。当然，效率并不高，读者可以自行实现一个修改的方法 :-)</p>
<h2 id="Conclution-and-More"><a href="#Conclution-and-More" class="headerlink" title="Conclution and More"></a>Conclution and More</h2><p>在一开始的Node代码中，我们有一个toString的方法，如果你尝试调用的话，你会发现这个方法会按照从小到大的顺序打印出树中的全部数字或者元素。我们把代码拿出来单独看一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String toString()&#123;</div><div class="line">    return Optional.ofNullable(left).map(node -&gt; node.toString()).orElse(&quot; &quot;) </div><div class="line">            + &quot; &quot; + treasure.toString() + &quot; &quot;</div><div class="line">            + Optional.ofNullable(right).map(node -&gt; node.toString()).orElse(&quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法直接来看有点复杂，我们先来变形一下以便于理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void print(Node root) &#123;</div><div class="line">    if (root == null)</div><div class="line">        return;</div><div class="line">    print(root.left);</div><div class="line">    System.out.print(&quot; &quot; + root.treasure);</div><div class="line">    print(root.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就会容易很多。print接受一个二叉树，然后打印出该二叉树的全部数字。逻辑很简单，打印左侧子树，然后打印root节点，然后打印右侧子树。我们来看看实际运行的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(final String[] args) &#123;</div><div class="line">    final BinaryTree&lt;Integer&gt; bTree = new BinaryTree&lt;&gt;();</div><div class="line">    IntStream.range(0, 20).forEach(i -&gt; bTree.add((int)(Math.random()*20)));</div><div class="line">    bTree.print(bTree.root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// output :  0 1 5 7 8 10 13 14 15 16 17 18 19</div></pre></td></tr></table></figure></p>
<p>main方法中，我们对bTree进行了二十次插入操作，每次插入的数字都是介于0到20之间，所以实际插入的数字和个数都不确定。然后我们调用print方法来打印。因为打印方法是打印出左侧子树，然后打印根节点，最后打印右节点，所以打印出来的数字是有序的，按从小到大的顺序打印。因为递归调用的原因，当我们打印左侧子树的时候，我们实际上会尝试打印左侧子树的左侧子树，直到左侧是null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                4  </div><div class="line">             /    \  </div><div class="line">           2        9</div><div class="line">                  /    \  </div><div class="line">                6       12</div><div class="line">              /  \     /  \</div><div class="line">             5    7   11   14</div><div class="line"></div><div class="line">打印的顺序是左，中，右。所以输出是 2,4,5,6,7,9,11,12,14</div></pre></td></tr></table></figure></p>
<p>这下toString方法也很好理解了吧？我们其实就是把左侧子树变成String，然后加上根节点的元素的String形式，再加上右子树。这样toString对于根节点调用返回的就是一个从小到大包含了全部数字的字符串。<br>以左，中，右的顺序访问这个树，就是传说中的中序。相应的，我们可以轻易地修改这些方法，改变访问的顺序。中，左，右的顺序就是先序，左，右，中的顺序就是后序。不同的访问方式，打印出来的元素的排列方式也是不相同的，感兴趣的小伙伴可以自行尝试。</p>
<p>另外，现在我们已经知道二叉树是一层一层的结构了，那么我们怎样可以按行来打印出二叉树的元素呢？比如对于上面这棵树，我们如何打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line">2 9</div><div class="line">6 12</div><div class="line">5 7 11 14</div></pre></td></tr></table></figure></p>
<p>这样的形式呢？下面的代码中我写出了答案，感兴趣的小伙伴也可以下载查看。当然，愿意自己思考并且尝试的话，就更好了。不过这需要我们认识一种新的数据结构，在下一篇文章中，我们将会讲一讲queue和stack，和它们可以应用的场景和算法。</p>
<p><br>下面是这篇文章实现的二叉树，需要的读者可以尝试运行。<br><br>
<button onclick="window.open('BinaryTree.java')">点我下载 BinaryTree.java</button>
<br><br>谢谢阅读。<br></p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binary-Tree&quot;&gt;&lt;a href=&quot;#Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree&quot;&gt;&lt;/a&gt;Binary Tree&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot;
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>第1天的递归</title>
    <link href="https://alex-mengx.github.io/2017/02/24/postRecursive/"/>
    <id>https://alex-mengx.github.io/2017/02/24/postRecursive/</id>
    <published>2017-02-25T04:44:46.000Z</published>
    <updated>2017-03-02T03:42:59.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>这是我们遇到的第一只拦路虎。这只名为‘递归’的大猫看似凶残，不少人因之望而却步。然则征途伊始，怎可不战便退？让我们试着化繁为简，用简单的语言和例子来理解这个概念，再以简驭繁，用这个看似简单的概念来解决复杂的问题吧！</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>递归 (Recursion) 是解决一些特定的复杂问题的常见方式之一。它之所以广受欢迎，不仅是因为它能够细分问题，将复杂问题抽丝剥茧般层层剥离，更是因为其独特的思维方式跳出了线性思维的禁锢。 让我们先从简单的问题入手吧。</p>
<h3 id="What-is-recursion"><a href="#What-is-recursion" class="headerlink" title="What is recursion?"></a>What is recursion?</h3><p>递归不是一种具体的事物。它不是某一类的算法，也不是某一类语言的特性，更不是数据的结构。它是思维的方式，是解决问题的手段，是审视问题的另一个角度。它帮助你在纷杂的逻辑中另辟蹊径，能让你在斑驳的代码里游刃有余。那么，它到底是什么呢?<br>在理解递归之前，我们需要先理解什么是函数。首先，函数这个概念大家应该都有所耳闻。函数是一个对应的方式，所描述的是两个合集之间的映射关系。比如<code>{1，2，3，4，5，6...}</code>这个合集所包括的就是自然数。而函数<code>f(x) = 2x</code>所描述的，就是自然数合集和偶数合集的关系。用合集的形式写出来就是 <code>{1,2,3,4,5,6...} -&gt; f(x) = 2x -&gt; {2,4,6,8,10,12...}</code>这个函数所描述的关系非常简单，对于自然数合集中的每一个元素，偶数合集之中都有一个数字是该元素的两倍。<br>题外话：是的，自然数合集所包含的数字的数量，和偶数合集所包含的数字的数量是相等的。这看似反直觉，但是可以通过数学证明推导。<br>回到主题。简单的函数很好理解,给一个输入就会有一个输出，还是用上面的例子来帮助理解。我们看这个数列:<code>{1,3,5,7,9,11....}</code>注意这是一个数列，而不是一个数组，它的位置是从1开始的。我们可以看到数字和它所在的位置有很清楚的关系。用n来表示第n个数字，那么第一个数字是1，第二个数字是3，第三个数字是5，以此类推。不需要拼凑公式，我们通过经验也可以知道，这组数的第n个数字一定是 <code>f(n) = 2n-1</code>。我们就可以说，这个函数描述了自然数数列1,2,3…和奇数数列1,3,5…的映射关系。现在我们对于函数有了很清晰的认识，我们可以来看递归了。</p>
<p>什么是递归呢？一个函数调用自身的过程，就是递归。听起来很不明所以吧？我们来详细的挖掘一下这句话的意思。依旧用一组数字来作为例子。<code>{0,1,1,2,3,5,8,13,21,34...}</code>这个数列叫做 斐波那契数列（Fibonacci number）。那么这个数列的数字和它的位置有没有关系呢？通过观察，我们发现了这个数列的每一个数字，都等于它前两个数字的和。用函数公式来表达 <code>f(n) = f(n-1) + f(n-2)</code>。 只要知道第一个和第二个数字分别是0和1，那么我们就可以通过这个函数得知，f(3) = 0 + 1 = 1，f(4) = f(3) + f(2) = 1 + 1 = 2。以此类推。这个函数我们通过观察，可以看到它有一个很明显的特点，就是它调用了自身。也就是说，自然数数列作为一个合集，和斐波那契数列这个合集的映射关系不是线性的关系，而是与其自身相关。我们把这个特点抽象出来，就会发现，这是一类问题的共通之处。</p>
<h3 id="Why-recursive"><a href="#Why-recursive" class="headerlink" title="Why recursive?"></a>Why recursive?</h3><p>通常，递归可以有效的表达解决问题的逻辑。虽然不会减少甚至可能增加复杂度，但是它可以有效的减少键盘敲击的数量（笑。当然，很多时候它可以帮助我们理清思路，减少不必要的复杂代码。我们再来看几个简单的例子。</p>
<h4 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// F(n) = F(n-1) + F(n-2)</div><div class="line"></div><div class="line">int fibonacci(int n) &#123;</div><div class="line">    return fibonacci(n-1) + fibonacci(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在就有了一个可以计算fibonacci数的函数。只要调用fibonacci(n)， 我们就可以计算第n位的fibonacci数字。但是当我们尝试调用的时候，却发现这个函数无法退出，直到出现了StackOverflowError。这是因为，这个函数没有终点，会一直尝试对n－1和n－2进行调用，直到溢出。那么我们该怎么改进呢？很简单，只需要给定一个结束的条件就可以了。但是，这个结束的条件并不是针对函数的流程，而是针对n本身。原因很简单，这个函数会被运行很多次，我们无法通过流程判断，但是n可以告诉我们结束的正确时机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// F(n) =   1                   n = 1</div><div class="line">//          0                   n = 0</div><div class="line">//          F(n-1) + F(n-2)     n &gt; 1</div><div class="line"></div><div class="line">int fibonacci(int n) &#123;</div><div class="line">    if (n == 1)</div><div class="line">        return 1;</div><div class="line">    if (n == 0)</div><div class="line">        return 0;</div><div class="line">    return fibonacci(n-1) + fibonacci(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，这个程序现在就不会stack over flow了。我们来画个递归树来看一下运行过程。画树是分析算法复杂性的常用方式，以后我们会专门详细解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">为了方便，我们把 fibonacci 简写成 f， 我们来看看f(5)是怎么运行的</div><div class="line">                                                  f(5)</div><div class="line">                                __________________/ \_____________________</div><div class="line">                               |                                          |</div><div class="line">                              f(3)                                       f(4)</div><div class="line">                       _______/ \_______                         ________/ \_______</div><div class="line">                      |                 |                       |                  |</div><div class="line">                     f(1)              f(2)                   f(2)                f(3)</div><div class="line">                                   ____/ \_____          ______/ \_____      ______/ \_______</div><div class="line">                                  |            |        |             |      |               |</div><div class="line">                                 f(0)         f(1)     f(0)          f(1)   f(1)            f(2)</div><div class="line">                                                                                        ____/ \_____</div><div class="line">                                                                                       |            |</div><div class="line">                                                                                     f(0)         f(1)</div></pre></td></tr></table></figure></p>
<p>通过这个树，我们可以很清晰的看到这个函数自我调用的过程。在这里我们不去深究这个函数的复杂度，只对于耗时稍加讨论。一般来说，我们习惯用字母<code>T</code>来表示时间，所以这个函数对于f(5)的耗时可以表达成为T(5)。通过观察可得知，T(5) = T(3) + T(4) + 1。 1是在得到了f(3)与f(4)之后的相加操作，因为是对常量的操作，所以耗时为1，写作O(1)。不要太过于纠结T和O的含义，以后我们会详细说明。追寻到底，我们可以发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(5) = f(1) + f(0) + f(1) + f(0) + f(1) + f(1) + f(0) + f(1) = 5</div></pre></td></tr></table></figure></p>
<p>具体时间复杂度就不在画树了，同样是对于所有叶子节点的累加。通过这个例子，我们发现，递归可以有效地减少代码数量，并且逻辑很清晰。但是缺点也同样明显，观察运行树，可以发现f(3)的值被重复计算了两遍，f(2)的值被重复计算了三遍。随着n的增加，重复计算的分量以N^2的速度增加。这就是为什么明明fibonacci的耗时可以是O(n)，但是递归算法的耗时是O(n^2)。</p>
<h3 id="Factorial"><a href="#Factorial" class="headerlink" title="Factorial"></a>Factorial</h3><p>阶乘是另一个非常助于理解递归的例子。我们来写一下阶乘的函数。<code>f(n) = n * (n-1) * (n-2) * ... * 2 * 1</code>，一目了然，n的阶乘就是从n乘到1的结果。那么，这个函数怎么写可以简单一点呢？我们来变化一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f(n) = n * (n-1) * (n-2) * ... * 2 * 1 = n!</div><div class="line">f(n-1) = (n-1) * (n-2) * ... * 2 * 1 = (n-1)!</div><div class="line"></div><div class="line">==&gt; f(n) = n * (n-1)! = n * f(n-1)</div></pre></td></tr></table></figure></p>
<p>是不是看起来很眼熟？是的，这里也可以用递归的方式来计算阶乘。n的阶乘，就是n和(n-1)的阶乘的乘积。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int factorial(int n) &#123;</div><div class="line">    if (n == 1)</div><div class="line">        return 1;</div><div class="line">    return n * factorial(n-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的边界条件很简单，等于1的时候就是1。这样，这个函数就可以通过调用自身来计算n-1的阶乘，从而计算出n的阶乘。不同于斐波那契数，这个阶乘的递归算法不仅不会增加时间复杂度，逻辑也更加清晰明了。这是因为再一次调用中，它只对自身进行了一次调用，而斐波那契算法则对自身调用了两次。</p>
<h2 id="More-Problems"><a href="#More-Problems" class="headerlink" title="More Problems"></a>More Problems</h2><p>通过上面的介绍，我们已经理解了递归的原理和逻辑，同时对于适用的一类问题有了一些基本的了解。现在让我们来看一看稍微复杂一点的问题吧，看看递归能给我们带来怎样的便利。</p>
<h3 id="GCD-Greatest-Common-Divisor"><a href="#GCD-Greatest-Common-Divisor" class="headerlink" title="GCD Greatest Common Divisor"></a>GCD Greatest Common Divisor</h3><p>寻找两个数字的最大公约数。这个问题直觉上来说最容易想到的办法就是挨个试。比如我们想找1000和300 的最大公约数，我们就可以从两个数字中的较小的数字开始向下寻找。如果两个数字都可以被300除尽，那么300就是最大公约数，不可以的话，就试试299.以此类推，直到2，如果都找不到，说明最大公约数是1。 但是对于大数字，这个办法耗时良久且效率低下。<br>那么，可不可以给力一点呢？<br>可以的，我们可以为这两个数分别列举出来它们全部的约数，然后在两个合集的交集之中寻找最大值。这样的好处是不用一个一个数字尝试，但是缺点也很明显，列举出全部约数并不是一件容易的事情。比如20，2<em>3</em>4=20，但是2*10也等于20， 2,3,4,5,10,20 都是20的约数。所以我们要化简到最小素数乘积，然后找最大的共同素数乘积。<br>那么。可不可以在给力一点呢？<br>我们来借助一下古人的智慧吧。西汉末年，有奇书记载了一种计算约数的方术，名曰“更相减损术”。术云:</p>
<blockquote>
<p>可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。</p>
</blockquote>
<p>又有合分术曰：</p>
<blockquote>
<p>母互乘子，并以为实，母相乘为法，实如法而一。不满法者，以法 命之。其母同者，直相从之。</p>
</blockquote>
<p>从九章算术中的记载，我们可以看到求最大公约数的简便方法。稍微解释一下。可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。 这句话的意思就是，两个数，我们用大数除以小数，大数整除的部分不要，只保留余数。之后，用小数除以保留的余数，整除部分不要，只保留余数。更相交替计算，一直到没有余数，可以整除，那么这个除数就是两个数字的最大公约数了。我们用1000和300举例。mod 运算就是求余的意思，1000 mod 300 = 100,300 mod 100 = 0， 所以100就是1000和三百的最大公约数。我们先来列一下函数看看逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g(n,m) = m              if n % m == 0</div><div class="line">         g(m, n % m)    if n % m != 0</div></pre></td></tr></table></figure></p>
<p>逻辑很清楚，小数能被大数整除，小数就是最大公约数，不能被整除，那么大数除小数取余，就是新的小数，原本的小数就变成了大数。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int gcd(int big, int small) &#123;</div><div class="line">    if (big % small == 0)</div><div class="line">        return small;</div><div class="line">    return gcd(small, big % small);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重点在于大小数取余之后位置的交换。另外，这个算法每一次迭代都会计算两次取余，我们来修改一下优化一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int gcd(int big, int small) &#123;</div><div class="line">    if ( small == 0)</div><div class="line">        return big;</div><div class="line">    return gcd(small, big % small);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的话，我们只需要计算一次取余，效率瞬间飙升了一倍。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们复习了递归的原理，用简单的例子解释了递归的特性。总体来说这篇博文比较容易理解，也没有复杂的问题。等到后面我们讲完二叉树和简单的算法分析，我们再试着用递归解决一些更复杂的问题吧。</p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Recursion&quot;&gt;&lt;a href=&quot;#Recursion&quot; class=&quot;headerlink&quot; title=&quot;Recursion&quot;&gt;&lt;/a&gt;Recursion&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://alex-mengx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>第1天的Java特性</title>
    <link href="https://alex-mengx.github.io/2017/02/17/postJavaProperties/"/>
    <id>https://alex-mengx.github.io/2017/02/17/postJavaProperties/</id>
    <published>2017-02-18T04:29:42.000Z</published>
    <updated>2017-03-02T02:31:36.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-encapsulation-inheritance-polymorphism"><a href="#Java-encapsulation-inheritance-polymorphism" class="headerlink" title="Java encapsulation inheritance polymorphism"></a>Java encapsulation inheritance polymorphism</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>java是一门面向对象的语言，讲究封装继承和多态。不要被这些名字吓到，通过阅读本文，你应该会对这些概念有更直观的理解。本文会试着举出一些有趣而准确地例子帮助你接受并了解面向对象语言的一些共通的特性。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>面向对象是设计模式的一种。为了避免陷入到堆砌专业名词而使得初学者难以理解的困境中，我们暂且不对设计模式进行解释。对于特性的名字也不必要去钻牛角尖，通过例子会有直观的感受，这比强行记住佶屈聱牙的定义要容易且有效很多。作为程序员，我们的准则就是高效且准确，所以就让我们进入到Java的世界，用代码和例子来代替文字定义吧。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>首先我们来通过例子理解封装，继承和多态的大概含义。这些概念之间有着密切的相互联系，让我们一个一个慢慢来看。</p>
<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>封装，顾名思义，把内部的东西包裹起来，封住具体的细节，只保留必要的接口。这既是出于安全角度考虑，同样也会使得开发的过程变得不易出错且易于修改。为什么封装会有这样的效果呢？我们来举例说明吧。<br>想象一台ATM取款机，这个取款机就是一个封装的很好的系统，我们只能通过操作界面(interface)来操作。现在我们把这个取款机当做一个Java的类，然后把取款机的方法列举出来看看我们都有什么。取款机最基本的功能就是输入密码取钱存钱， 我们先无视掉别的功能，来写一个Java的类实现输入密码取钱存钱的功能，并且来看看封装能带来什么好处。为了简化这个模型，我们假设你是一个超级重要的VIP客户，银行在你家里设立了一台定制的ATM取款机，这个ATM只有你一个人可以使用，里面只保存了你一个人的信息，只要输对了密码就能取钱，里面也只有你一个人的余额信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ATM &#123;</div><div class="line">    public String password = &quot;p@ssw0rd&quot;;</div><div class="line">    public int balance = 0;;</div><div class="line"></div><div class="line">    public ATM() &#123;&#125;</div><div class="line"></div><div class="line">    public void withdraw(String password, int howMuch) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            if (balance &gt; howMuch) &#123;</div><div class="line">                balance -= howMuch;</div><div class="line">                System.out.println(&quot;Withdraw &quot; + howMuch + &quot;, you have remaining balance &quot; + balance);</div><div class="line">            &#125; else</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void save(String password, int howMuch) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            balance += howMuch;</div><div class="line">            System.out.println(&quot;Save &quot; + howMuch + &quot;, you have remaining balance &quot; + balance);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int query(String password) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            return balance;</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，上面就是一个很简单的ATM的实现，银行建立一个包含了初始密码和0余额的ATM，放在你家里，你就可以开始使用了。我们可以看到，这个ATM实现了三个方法，分别是存款(save)，取款(withdraw)和查询余额(query)。 下面我们来试着存钱取钱试试看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ATM atm = new ATM();</div><div class="line">    atm.save(&quot;wrong&quot;, 100); //错误的密码</div><div class="line">    System.out.println(&quot;I have &quot; + atm.query(&quot;p@ssw0rd&quot;) + &quot; in ATM.&quot;); //正确的密码查余额</div><div class="line">    atm.save(&quot;p@ssw0rd&quot;, 100); // 存100</div><div class="line">    System.out.println(&quot;I have &quot; + atm.query(&quot;p@ssw0rd&quot;) + &quot; in ATM.&quot;);</div><div class="line">    atm.withdraw(&quot;p@ssw0rd&quot;, 50); //取50</div><div class="line">    System.out.println(&quot;I have &quot; + atm.query(&quot;p@ssw0rd&quot;) + &quot; in ATM.&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">Authorization Error!</div><div class="line">I have 0 in ATM.</div><div class="line">Save 100, you have remaining balance 100</div><div class="line">I have 100 in ATM.</div><div class="line">Withdraw 50, you have remaining balance 50</div><div class="line">I have 50 in ATM.</div></pre></td></tr></table></figure></p>
<p>我们看到，输入密码，我们就可以存钱取钱。但是，这个系统真的安全吗？如果我们直接修改密码或者余额，会发生什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">atm.password = &quot;&quot;;</div><div class="line">atm.balance = 9999;</div><div class="line">System.out.println(&quot;I have &quot; + atm.query(&quot;&quot;) + &quot; in ATM.&quot;);</div><div class="line"></div><div class="line">输出：</div><div class="line">I have 9999 in ATM.</div></pre></td></tr></table></figure></p>
<p>啊哈，直接修改余额，我们现在有了9999的余额，而且密码变成了空白。显然，这个ATM十分的不安全，我们不用通过操作界面也就是系统提供的那些方法，就可以对数据进行操作。那么，我们来试着封装一下这个ATM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class ATM &#123;</div><div class="line">    private String password = &quot;p@ssw0rd&quot;; //修改为private</div><div class="line">    private int balance = 0;</div></pre></td></tr></table></figure></p>
<p>我们为这两个元素添加了private关键字。现在再试着运行同样的程序，我们会看到这样的错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The field ATM.password is not visible</div><div class="line">The field ATM.balance is not visible</div></pre></td></tr></table></figure></p>
<p>这下我们的ATM就安全多啦！这两个元素的可见性从公共的程度降低到了私有，也就是说，除了ATM机这个class的内部方法以外，没有别的方法可以读取和修改你的密码和余额啦！下面是这个ATM的Java代码，包含了存款取款修改密码和查询功能，有兴趣的小伙伴可以下载之后修改余额和密码的可见性，做一些其他的尝试。<br>
<button onclick="window.open('ATM.java')">点我下载 ATM.java</button>
<br>封装的概念比较容易理解，实际上就是控制外部对于类内部数据的访问，为了保证安全，我们尽量使得内部的数据私有化(private)，使外部用户只能通过规定的public方法来进行操作。表现在以上的例子中就是ATM中的密码，只能通过changePassword方法来修改，这就要求用户输入正确的密码，而不是可以随意对ATM内部的密码变量进行直接修改。封装的概念在下文中还会被多次提及，因为Java的特性大多数时候是相互影响的，我们会通过例子来看到这些变化和影响。</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>继承，算是Java最重要的特性之一。他的意思很简单，父亲有的东西，儿子一样会有。举例来说，假如你是一个造船厂的老板，你可以生产帆船，汽油机船和人力船三种船。生产每一种船都很耗费时间，所以每次拿到订单工期都会很赶，而没有订单的时候工人们又很闲。但是你是一个很聪明的老板，你发现，这三种船可以使用同一个模具建造出来的基本款船，只要加上船帆，发动机或者船桨，就会成为不同的产品。于是，闲暇时期你开始生产基本款，而接到订单后，只需要根据数量来安装对应的模块，就会很高效的完成订单。在这个例子中，三种成品都是继承于船体这个父类，生产中可以节约完成订单的时间，而表现在代码中则是很多代码都可以重复使用，而不需要重新编写。<br>现在，你应该对于继承有了一个大概的感觉，似乎明白了什么是继承，但是又无法跟代码联系起来。不要紧，下面我们就回到ATM的例子，来试着用代码表现出继承这一特性。上面的例子中，ATM是针对你这个超级VIP设计的，他可以满足你存取款修改密码查询余额的要求。假设现在我们又有了一个超级VIP，他不仅要求以上这些功能，同时他还需要转账功能，我们该怎么办呢？ATM不能被修改，因为你这个VIP还在使用，那我们是不是应该重新制作一个不一样的ATM呢？这种时候，继承的优点就表现出来了。让我们来建立一个可以转账的TransATM吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class TransATM extends ATM &#123;</div><div class="line"></div><div class="line">    public void transferTo(String password, int howMuch, long toAccount) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            if (this.balance &gt;= howMuch) &#123;</div><div class="line">                this.balance -= howMuch;</div><div class="line">                System.out.println(&quot;Successfully transferred &quot; + howMuch + &quot; to the account &quot; + toAccount + &quot; , balance is &quot; + balance);</div><div class="line">            &#125; else</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个TransATM继承了ATM的全部non-private的元素和方法。但是你会发现，当你调用这个transferTo方法的时候，Java会提醒你<code>The field ATM.password is not visible</code>。这是为什么呢？答案很简单，这个方法中this.password试图调用的是ATM这个父类当中的password变量，而这个变量我们为了安全性将可视性变为了private，所以就算是ATM的子类，这个变量也是不可见得。将ATM中的这两个变量修改为默认default，这个TransATM就可以正常工作了，而ATM的这两个变量的可视性则增加到了包，也就是在同一个package内的类都可以访问这两个变量了。在封装的部分中我们为了安全而将其设置成了私有，这里为了能够使得子类继承到这两个变量，我们修改了变量的可见性，这自然会降低安全性。那么，有没有什么办法能够既保证安全，又能减少重复劳动呢？复制黏贴代码并不是一个好习惯，让我们从设计的角度来思考一下更加可行的解决方法吧。<br>上文中的这个TransATM和ATM类的关系是父子关系，可以说TransATM “is-a” ATM，非私有的方法和元素都可以被继承。这是一种“是”的关系，例如玛莎拉蒂和五菱宏光都是车，他大舅他二舅都是他舅，这就是典型的“是”关系。除了“是”以外，我们还可以有“has-a”的关系。比如，玛莎拉蒂有发动机，帆船有帆，这都是有的关系。具体到我们ATM的例子，我们可以用有的关系来尝试解决这个问题。想象一下，我们为了节省工作负荷，再生产TransATM的时候，我们将一台ATM内嵌到了TransATM之中，然后增加了新的模块来实现转账功能，这也是继承关系的一种，是“有”的关系。来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TransATM &#123;</div><div class="line">    private String password = &quot;transP@ssw0rd&quot;;</div><div class="line">    private ATM atm;</div><div class="line">    </div><div class="line">    public TransATM() &#123;</div><div class="line">        this.atm = new ATM();</div><div class="line">        atm.changePassword(&quot;p@ssw0rd&quot;, this.password);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void withdraw(String password, int howMuch) &#123;</div><div class="line">        atm.withdraw(password, howMuch);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void save(String password, int howMuch) &#123;</div><div class="line">        atm.save(password, howMuch);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int query(String password) &#123;</div><div class="line">        return atm.query(password);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void changePassword(String password, String newPassword) &#123;</div><div class="line">        atm.changePassword(password, newPassword);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void transferTo(String password, int howMuch, long toAccount) &#123;</div><div class="line">        if (this.password.equals(password)) &#123;</div><div class="line">            if ( atm.query(password) &gt;= howMuch) &#123;</div><div class="line">                atm.withdraw(password, howMuch);</div><div class="line">                System.out.println(&quot;Successfully transferred &quot; + howMuch + &quot; to the account &quot; + toAccount + &quot; , balance is &quot; + atm.query(password));</div><div class="line">            &#125; else</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + atm.query(password) + &quot; left!&quot;);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Authorization Error!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，这个TransATM实际上就是给ATM套了一个外壳，但是安全性有了很大的提升，不仅可以有不同的初始密码，密码变量和内部的atm对于用户也是不可见的。这就是封装和继承之间的平衡。找准主要需求，在设计上进行改变来满足需求是程序员解决问题的必要思路。从这个例子中我们可以看到由于ATM类原本不是为了可延展设计的，所以在继承方面需要我们或者改变可见度，或者改变继承的类型来适应。那么，如果一开始就是为了可以延展而设计，这些ATM可以有哪些改变呢？</p>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>因为你和你的小伙伴太成功了，越来越多的定制ATM需求被提了出来。于是银行发现，为了满足这些定制的ATM，要么每一次都重新开发，要么就要对已经投入使用的ATM进行修改。修改正在使用的ATM会导致你们这些超级VIP的ATM也需要更新修改，代价过于高昂，于是银行打算从头来设计一套易于延伸，便与定制同时还要安全稳定的ATM标准，来作为以后ATM的设计方案基础。这就涉及到了多态的特性。首先我们暂时放下ATM的这些事情，先来了解一下interface的概念。interface，就是接口，也是Java的常用关键字之一。它所表示的意思跟它的字面意思是一样的，表示它所标示的是一系列类型的共同操作方式。接口，顾名思义，是指一个系统接受输入和输出的部分。我们来举几个简单的例子帮助理解。假设我们要实现一些class，这些class都有一些共同的方法，那么我们就可以定义一个interface来表示这个共同的方法。比如我们有dog,cat,他们都会摇尾巴，我们就可以定义一个interface来定义摇尾巴这个动作，但凡有新的动物会摇尾巴，我们就可以要求这个动物implements这个interface。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">interface ShakeTail &#123;</div><div class="line">    public void shakeTail();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog implements ShakeTail&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;dog shake tail&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat implements ShakeTail &#123;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;cat shake tail&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子里，dog和cat在定义中包含了ShakeTail的接口，所以他们必须要实现shakeTail这个方法。但是interface只是一个接口，不能有具体的实现，如果我们想要一个interface，同时需要包含一些可以通用的方法，那么我们可以使用abstract类。abstract类跟普通类很相似，区别在于abstract类不能实例化，也就是不能‘new’。只有子类extends abstract类，子类才可以被实例化。来看具体例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">abstract class Animal &#123;</div><div class="line"></div><div class="line">    public void move() &#123;</div><div class="line">        System.out.println(&quot;Animal move&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的Dog类继承了Animal类中的move方法，所以<code>new Dog().move()</code>会调用Animal中的move方法。那么什么时候用抽象（abstract）类，什么时候用接口呢？这里实际上依旧是上文描述过的”is-a”和”has-a”的关系。如果你有一类的东西，那么你可以给这一类的东西归类成一个抽象类。比如我们有猫，有狗，有鸟，我们就可以有一个抽象的动物类，然后实现一些全体动物共同的特性。而当某几类的动物有共同的特征时，我们可以为这个特征建立接口，有这一特征的动物就可以实现这个接口。依旧来看例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">abstract class Animal &#123;</div><div class="line">    public void move() &#123;</div><div class="line">        System.out.println(&quot;Animal move&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface LickPaw &#123;</div><div class="line">    public void lickpaw();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface ShakeTail &#123;</div><div class="line">    public void shakeTail();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal implements ShakeTail &#123;</div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;dog shake tail&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal implements ShakeTail, LickPaw&#123;</div><div class="line">    @Override</div><div class="line">    public void shakeTail() &#123;</div><div class="line">        System.out.println(&quot;cat shake tail&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void lickpaw() &#123;</div><div class="line">        System.out.println(&quot;cat lick paw&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    shakeTail(new Cat());</div><div class="line">    move(new Dog());</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void shakeTail(ShakeTail l) &#123;</div><div class="line">    l.shakeTail();</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void move(Animal a) &#123;</div><div class="line">    a.move();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们从上往下依次来看。首先我们定义了一个抽象的Animal类，包含了一个move的方法。这个类是无法‘new’实例化（instantiation）的。然后我们定义了舔爪子和摇尾巴两个接口。为什么Animal是抽象类而这两个接口是接口呢？因为我们将要定义的类将‘是’动物，而‘有’某些接口定义的方法。所以我们可以说猫是动物，可以舔爪子，而不能反过来。如果我们要创建抽象类是猫，而定义的多个类是各种猫，那么‘舔爪子’这个方法就应该放在抽象类猫之中了。下面的猫和狗我们可以看到，都是动物类的子类，都有摇尾巴的方法，而猫则多出了舔爪子的方法。这样做的优点有几种。首先是代码的重复利用，Animal中的方法猫狗都可以直接调用，而不用重新写。另外是看最下面的方法，<code>new Dog()</code> 可以被只接受Animal的方法接受，<code>new Cat()</code> 也可以被只接受ShakeTail的方法接受。这是因为dog一定是Animal，包含了Animal能被外部调用的全部方法和元素，所以Animal能被看见的能被调用的，dog一定也有。而Cat实现了ShakeTail，所以ShakeTail规定的方法Cat一定全部都实现了，所以对于接受ShakeTail的方法，Cat一定包含了对其对应方法的实现。这样带来的好处有很多，比如Java的executor，你可以有各类job的实现，然后executor只要调用job的run方法，就可以完成各类工作，而不需要了解不同job的具体实现。我们来看用这种抽象思想实现的ATM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">abstract class AbstractATM &#123;</div><div class="line">    </div><div class="line">    protected abstract Map&lt;String, Account&gt; getAccounts();</div><div class="line"></div><div class="line">    public void openAccount(String username, String password) &#123;</div><div class="line">        getAccounts().put(username, new Account(password, 0));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void withdraw(String username, String password, int howMuch) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line"></div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            int balance = account.getBalance();</div><div class="line">            if (balance &gt;= howMuch) &#123;</div><div class="line">                account.setBalance(balance - howMuch);</div><div class="line">                System.out.println(&quot;Withdraw &quot; + howMuch + &quot;, you have remaining balance &quot; + account.getBalance());</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void save(String username, String password, int howMuch) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line"></div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            int balance = account.getBalance();</div><div class="line">            account.setBalance(balance + howMuch); </div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Integer query(String username, String password) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            return account.getBalance(); </div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changePassword(String username, String password, String newPassword) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            account.setPassword(newPassword);</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    protected class Account &#123;</div><div class="line">        </div><div class="line">        private String password;</div><div class="line">        private int balance;</div><div class="line">        </div><div class="line">        protected Account(String password, int balance) &#123;</div><div class="line">            this.password = password;</div><div class="line">            this.balance = balance;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        protected int getBalance() &#123;</div><div class="line">            return balance;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        protected String getPassword() &#123;</div><div class="line">            return password;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        protected void setBalance(int balance) &#123;</div><div class="line">            this.balance = balance;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        protected void setPassword(String password) &#123;</div><div class="line">            this.password = password;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个抽象类就是ATM的原型机，我们可以看到他实现了全部的基本操作，同时用一个可以被override的方法来从子类中获得账户信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TransferATM extends AbstractATM &#123;</div><div class="line">    private Map&lt;String, Account&gt; accounts;</div><div class="line"></div><div class="line">    public TransferATM(String username, String password) &#123;</div><div class="line">        super();</div><div class="line">        accounts = new HashMap&lt;&gt;();</div><div class="line">        accounts.put(username, new Account(password, 0));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Map&lt;String, Account&gt; getAccounts() &#123;</div><div class="line">        return accounts;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void transferTo(String username, String password, int howMuch, long toAccount) &#123;</div><div class="line">        Account account = getAccounts().get(</div><div class="line">                Optional.ofNullable(username).orElseThrow(() -&gt; new IllegalArgumentException(&quot;Please input user name.&quot;)));</div><div class="line"></div><div class="line">        if (account.getPassword().equals(password)) &#123;</div><div class="line">            int balance = account.getBalance();</div><div class="line">            if (balance &gt;= howMuch) &#123;</div><div class="line">                account.setBalance(balance - howMuch);</div><div class="line">                System.out.println(&quot;Transfer &quot; + howMuch + &quot; to account &quot; + toAccount + &quot;, you have remaining balance &quot; + account.getBalance());</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(&quot;Insufficient balance! Only has &quot; + balance + &quot; left!&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            System.out.println(&quot;Wrong password!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个子类就是具体的ATM实现，override了getAcccount方法，所以父类中的方法可以获得子类中的账户信息。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>今天我们回顾了Java的部分特性，了解了继承多态和封装的基本概念。我们来总结一下。封装是为了安全，良好的系统应该接近黑盒，用户需要根据文档学习使用，而系统内部的运作方式和数据处理过程对外部来说是不可见的。良好的封装不仅增加安全性，同时会降低系统的复杂度，减低用户学习的难度。继承是指类与类之间的关系，而概念跟字面意思是一致的。除了private的方法和元素之外，子类可以继承父类的其他元素，提高代码的重复使用率。多态是指同一个签名拥有不同的实现方法，根据不同场景，可以选择对应的实现方法。这些特性相辅相成，相互影响，共同构成了安全高效的系统。</p>
<p>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-encapsulation-inheritance-polymorphism&quot;&gt;&lt;a href=&quot;#Java-encapsulation-inheritance-polymorphism&quot; class=&quot;headerlink&quot; title=&quot;Java e
    
    </summary>
    
    
      <category term="Java" scheme="https://alex-mengx.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第0天的Hello World!</title>
    <link href="https://alex-mengx.github.io/2017/02/15/hello-world/"/>
    <id>https://alex-mengx.github.io/2017/02/15/hello-world/</id>
    <published>2017-02-16T01:45:27.844Z</published>
    <updated>2017-02-18T05:22:47.272Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://alex-mengx.github.io/data-structure/">弦子的数据结构小分享</a>! This is my very first post :)</p>
<p>I can be reached by Email: Alex.mengxiangwei@gmail.com</p>
<p>The Goal of this blog is to share my understanding of data structures. Each post would implement one of the most widely used data structure in Java. No specific reason for choosing Java as the developing language, and each language should be treated equally with dignity no matter what their circumstances :D </p>
<h3 id="May-the-force-be-with-you"><a href="#May-the-force-be-with-you" class="headerlink" title="May the force be with you."></a>May the force be with you.</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://alex-mengx.github.io/data-structure/&quot;&gt;弦子的数据结构小分享&lt;/a&gt;! This is my very first post :)&lt;/p&gt;
&lt;p&gt;I can be reached b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第1天的LinkedList</title>
    <link href="https://alex-mengx.github.io/2017/02/11/postLinkedList/"/>
    <id>https://alex-mengx.github.io/2017/02/11/postLinkedList/</id>
    <published>2017-02-12T04:29:42.000Z</published>
    <updated>2017-03-02T02:31:21.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>LinkedList - it is a linked list.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>链表 （ linkedlist） 是常见的数据结构之一。顾名思义，链表由一个一个的节点链接而成。每一个节点，都包含了承载的数据，以及一个指向下一个节点的指针。我们可以通过想象力来帮助我们理解这个数据结构是如何构成的。<br>想象一下儿时玩过的藏宝游戏。你的父亲给了你一张小纸条，上面写了一个地址 - 也许是卧室的窗台上，也许是长廊的过道边  - ， 游戏就由此开始了。 你来到了纸条上描述的位置，发现了一块美味的糖果，和另一张写着其他地址的纸条，于是你吃掉了糖果，向着下一个目的地出发。每个目的地都有一些宝藏，也许是糖果，也许是玩具，最重要的是都会有一张写着地址的小纸条。 你可以一直找寻下去，直到有一天，你抵达了这条链的终点，那里不再有写着地址的纸条，只有父亲在微笑的看着你。<br>这就是一条典型的链表，每个藏着宝藏的地点就是链表的一个节点，写着地址的纸条则成为了指向下一个节点的指针。一个有限长度的链表必然存在着头和尾，在上文的例子中，第一张纸条可以被看做链表头，而没有纸条的最后一个藏宝点则是链表尾。</p>
<h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>这篇博文将用Java来一步一步实现一个拥有基本功能的链表来帮助读者理解这个结构。<br>首先，我们先为藏宝点建立格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Node&#123;</div><div class="line">    E treasure;</div><div class="line">    Node next;</div><div class="line"></div><div class="line">    public Node(E treasure, Node next) &#123;</div><div class="line">        this.treasure = treasure;</div><div class="line">        this.next = next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，一个简单的节点就建立起来了。treasure 可以是任何类型的元素，可以是其他object，也可以是数字或者字符串， 而next则指向了Node这个类。在实例中，next将会指向其他的Node实例。<br>有了藏宝的点，我们现在需要建立我们的第一张写着地址的小纸条了，这个纸条将会成为链表的头，所有的操作都将会通过这个小纸条来进行，它将是我们唯一的接入点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class LinkedList&lt;E&gt; &#123;</div><div class="line">    Node root;</div><div class="line">    </div><div class="line">    class Node&#123;</div><div class="line">        E treasure;</div><div class="line">        Node next;</div><div class="line"></div><div class="line">        public Node(E treasure, Node next) &#123;</div><div class="line">            this.treasure = treasure;</div><div class="line">            this.next = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个LinkedList类，就是我们的链表，而类元素root，则成为了我们可以接入这条链表的接入点。<br>现在我们有了一个框架，那么是时候为这条链表增加一些方法了。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>从上文的例子和部分实现中，我们已经对链表有了一个抽象的认识。那么链表的操作该如何完成呢？<br>下面我们来一步一步的增加增删改查这些常用的方法。</p>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>最简单的插入方式，就是从头部插入新的节点。假设目前你手里握着第一张纸条，那么增加一个新的藏宝点到这个长链中的最简单的的方式则是建立一个新的藏宝点，把你手中的纸条藏在哪里，然后拿出一张新的纸条，记录下来这个新的藏宝点的地址。 这个操作完成之后，新的节点会成为链表的头，而原先的链表头则成为了链中的第二个节点。</p>
<p></p><p align="center"><br>  <img src="LinkedList_Insertion.jpg"><br>  <b>LinkedList insertion operation chart 1.</b><br></p><br>上图解释了插入的过程。基本上可以分为两步：<p></p>
<ol>
<li>新建一个Node，这个Node的next指向原本的root节点。</li>
<li>断开原本的头部，指向新建的节点。</li>
</ol>
<p>这样，一个节点的插入操作就完成了。我们来看一下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void add(E e) &#123;</div><div class="line">    if (root == null)&#123;</div><div class="line">        root = new Node(e, null);</div><div class="line">    &#125; else &#123;</div><div class="line">        root = new Node(e, root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这个if条件是因为当这个链表为空的时候，这个root是null值，没有next元素，所以只需要让root指向新建的节点就可以了。当链表已经有了至少一个元素的时候，我们才需要断开root -&gt; node，然后新节点的next指向node， root指向新节点.</p>
<h3 id="RemoveFirst"><a href="#RemoveFirst" class="headerlink" title="RemoveFirst"></a>RemoveFirst</h3><p>取出并删除头结点的过程和插入类似，只要将root指向root.next就可以了。看图会清晰一点。</p>
<p></p><p align="center"><br>  <img src="LinkedList_RemoveFirst.jpg"><br>  <b>LinkedList removeFirst operation chart 2.</b><br></p><br>这个操作只需要一步就可以完成。代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public E removeFirst()&#123;</div><div class="line">    if (root == null)&#123;</div><div class="line">        return null;</div><div class="line">    &#125; else &#123;</div><div class="line">        E e = root.treasure;</div><div class="line">        root = root.next;</div><div class="line">        return e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>if检查在这里也是很必要的，因为当这个链表为空的时候，任何涉及root内部元素的操作都会抛出NullpointerException。只有不为空的链表，我们才可以取出其中的元素，如同一个没有地址的纸条，自然没有办法为我们指向宝藏的位置。</p>
<h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>查找链表中的元素是很常用的操作。但是这个数据结构对于查找并不是很友好。从上面插入和删除第一个元素的操作，我们可以看出来，无论这个链表中有多少的元素，我们都只需要对root进行操作。也就是说，无论这个链表内部元素的数量N有多庞大，插入和删除第一个元素的操作耗费的时间总是一定的。这一类与N无关的操作我们称之为O(1)操作。在这里我们不多涉及O（）这一表现形式，在未来的文章中我们会进一步解释这个符号的含义以及在算法中代表的意义。<br>话题回到链表的查找操作。由介绍部分的例子我们可以看出，对于链表，我们的访问总是从头部开始的。无论有多少宝藏和藏宝的地点，我们只能从手中的纸条所给出的第一个地点一步一步寻找下去。对于   root -&gt; A -&gt; B -&gt; C -&gt; D 这条链来说，没有到达B之前，我们没有办法知道C在哪里。这就给搜索带来了很多的麻烦。<br>回到开头的例子。 我们想从宝藏中找到竹蜻蜓，那么我们该怎么做？逻辑很简单:<br><b>我们所在的藏宝点收藏的是竹蜻蜓吗？</b></p>
<ol>
<li>是。很好，我们找到了。</li>
<li>不是，我们去下一个地点。</li>
</ol>
<p>继续看图来帮助理解。</p>
<p></p><p align="center"><br>  <img src="LinkedList_Search.jpg"><br>  <b>LinkedList search operation chart 3.</b><br></p><br>代码的逻辑并不复杂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean search(E e) &#123;</div><div class="line">    Node current = root;</div><div class="line">    while (current != null)&#123;</div><div class="line">        if (current.treasure.equals(e))</div><div class="line">            return true;</div><div class="line"></div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>让我们用语言来复述一遍这个方法的具体逻辑，这有助于理解。<br>首先，我们不希望破坏现有的数据和结构，所以我们不对root和其他链表内的元素进行操作。我们用一个current来表示我们当前所在的藏宝点的位置，这个current起始点则是root。 下面我们就踏上了寻宝之旅。在走完全部的旅途之前，没有人知道将会遇到什么，所以我们需要这个while loop 一直持续，直到current成为null也就是到达终点为止。在遍历的过程中，我们不断比较，当前current的treasure元素是否是我们所寻找的？如果是，那说明我们找到了，只要返回true就好，这会打破while loop，并从方法中返回。如果不是，我们则使current指向current.next，也就是我们的下一个目标点。当current成为null，也就是说我们走到了旅途的终点，那么我们所寻找的元素就不存在于这个链表之中，于是我们返回false。<br>并不难吧？</p>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>这个操作可以从链表里删除一个节点。跟removeFirst相比，它们的不同之处在于removefirst只能删掉第一个元素，而这个remove我们希望可以删除任意的E，只要E在链表中。那么，机智如你，想必一定已经有了思路了吧？是的，只要对search方法稍加修改就可以了。在search方法中，我们沿着链表一路向北直到目的地或者尽头，然后返回是否找到，在Remove中，我们要做同样的事情。只需要额外的一步，当找到包含了元素E的节点之后，我们只需要让E所在的节点的前一个节点的next指向E元素之后的节点就可以了。依旧看图说话。</p>
<p></p><p align="center"><br>  <img src="LinkedList_Remove.jpg"><br>  <b>LinkedList search Remove chart 4.</b><br></p><br>由于删除一个节点，我们需要知道这个节点的上一个节点在哪里，所以相比于search方法，remove方法我们需要两个指针，一个指向目前所在的current，一个指向之前一个节点previous。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public boolean remove(E e) &#123;</div><div class="line">    if (root == null) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    if (root.treasure.equals(e)) &#123;</div><div class="line">        root = root.next;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Node current = root.next;</div><div class="line">    Node previous = root;</div><div class="line"></div><div class="line">    while (current != null) &#123;</div><div class="line">        if (current.treasure.equals(e))&#123;</div><div class="line">        previous.next = current.next;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        previous = current;</div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>我们看到，虽然逻辑很相似，但是这个代码的复杂程度要比search稍微高一点。不过不要紧，我们来一行一行的查看一下它的逻辑。首先依旧是null check，如果root是null的话，说明链表是空的，直接返回false表明无法删除目标元素E就可以了。 接下来是查看root节点。作为第一个节点，如果它所收藏的宝藏是我们的目标元素， 那么我们只需要让root指向他自身的next，也就是等于取出第一个元素。到这里为止，之前的逻辑跟removeFirst是一样的。再往下，我们声明了两个指针，previous指向了root，current指向了root.next。因为之前我们已经查看了root不为null，所以root.next是不会抛出NullPointerException的。经过了这些步骤，我们终于做好了准备，可以踏上旅途了。进入while循环之后，我们查看current是否是我们所寻找的元素， 如果是，那么我们的旅途可以成功结束，如果不是，则还要继续寻找。当我们从一个节点走入另一个节点时，我们不仅要更新我们当前所在的节点current，同时还要更新previous，让它指向我们刚刚离开的节点。这样的话，如果下一个节点的元素是目标元素，则我们可以使用previous来找到当前节点，并使得previous.next指向current也就是目标元素节点的next。<br>如果while loop结束了依旧没有，那么说明我们所在的链表不包含目标元素，返回false说明删除失败。</p>
<h3 id="Edit"><a href="#Edit" class="headerlink" title="Edit"></a>Edit</h3><p>到目前为止，我们实现了插入元素，删除第一个元素，删除目标元素和查找元素这四个方法。利用这四个方法，我们可以实现另一个修改某个目标元素的方法。 逻辑很简单，如果删除目标元素成功，那么插入新元素就可以了。如果删除失败，说明目标元素不存在，自然无法修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public boolean edit(E target, E updateTo) &#123;</div><div class="line">    if (remove(target))&#123;</div><div class="line">        add(updateTo);</div><div class="line">        return true;</div><div class="line">    &#125; else return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于逻辑很好理解，我们直接看代码吧。 如果remove 目标元素E返回了true， 那么我们用add方法插入新的元素， 而如果remove 返回了false，则说明这个元素不存在，修改失败。</p>
<h2 id="Analysis-amp-Finding"><a href="#Analysis-amp-Finding" class="headerlink" title="Analysis &amp; Finding"></a>Analysis &amp; Finding</h2><p>在本文的上一个部分，我们实现了一个链表，以及实现了链表的增删改查等基本方法。下面我们写一点代码来使用这个链表，试着插入删除修改链表的元素。<br>为了方便查看链表内的已有元素，我们来实现一个toString方法。关于这个方法我们在这里稍微解释一下，这跟Java的特性有关系。Java是面向对象的语言，对于Java来说，所有的类都是一个一个的Object，而这些类之间则是继承关系，所以当你在链表内实现了toString方法，实际上你是用你实现的toString覆盖了这个链表父类中默认的toString方法。我们会用下一篇博文来专门介绍Java的这些特性，这里只需要知道这个toString方法是Object类中固有的方法就可以了。<br>这个toString方法我们将会从root开始遍历，依次打印出全部的元素。我们来看代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String toString() &#123;</div><div class="line">    Node current = root;</div><div class="line">    StringBuilder listToString = new StringBuilder();</div><div class="line">    listToString.append(&quot;====&quot; + &apos;\n&apos;);</div><div class="line">    while (current != null) &#123;</div><div class="line">        listToString.append(current.treasure);</div><div class="line">        listToString.append(&quot; &quot;);</div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    listToString.append(&apos;\n&apos; + &quot;====&quot;);</div><div class="line">    return listToString.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很好理解，跟search的逻辑是一样的。从root开始，对于每一个节点都把元素变成String，再将String拼在一起返回。<br>下面我们来试着插入从0到9十个数字，然后随便查找删除添加一些数字试试看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    intTest();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void intTest()&#123;</div><div class="line">    LinkedList&lt;Integer&gt; l = new LinkedList&lt;&gt;();</div><div class="line">    IntStream.range(0, 10).forEach(i -&gt; l.add(i)); // 添加0到9</div><div class="line">    System.out.println(l); // 打印</div><div class="line">    System.out.println(&quot;5 in the list is &quot; + l.search(5)); // 搜索5</div><div class="line">    System.out.println(&quot;10 in the list is &quot; + l.search(10)); // 搜索10</div><div class="line">    System.out.println(&quot;remove first, it is &quot;+ l.removeFirst());</div><div class="line">    System.out.println(&quot;remove first, it is &quot;+ l.removeFirst());</div><div class="line">    System.out.println(&quot;remove first, it is &quot;+ l.removeFirst());</div><div class="line">    System.out.println(l);// 打印</div><div class="line">    System.out.println(&quot;remove 11 is &quot; + l.remove(11));</div><div class="line">    System.out.println(&quot;remove 6 is &quot; + l.remove(6));</div><div class="line">    System.out.println(&quot;remove 0 is &quot; + l.remove(0));</div><div class="line">    System.out.println(l);// 打印</div><div class="line">    IntStream.range(0, 10).forEach(i -&gt; l.add(i)); //添加0到9</div><div class="line">    System.out.println(l);// 打印</div><div class="line">    System.out.println(&quot;Modify number 4 to 99 is &quot; + l.edit(4, 99));</div><div class="line">    System.out.println(&quot;Modify number 40 to 98 is &quot; + l.edit(40, 98));</div><div class="line">    System.out.println(l);// 打印</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段程序的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">====</div><div class="line">9 8 7 6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">5 in the list is true</div><div class="line">10 in the list is false</div><div class="line">remove first, it is 9</div><div class="line">remove first, it is 8</div><div class="line">remove first, it is 7</div><div class="line">====</div><div class="line">6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">remove 11 is false</div><div class="line">remove 6 is true</div><div class="line">remove 0 is true</div><div class="line">====</div><div class="line">5 4 3 2 1  //注意这里和下一行数字输出</div><div class="line">====</div><div class="line">====</div><div class="line">9 8 7 6 5 4 3 2 1 0 5 4 3 2 1 </div><div class="line">====</div><div class="line">Modify number 4 to 99 is true</div><div class="line">Modify number 40 to 98 is false</div><div class="line">====</div><div class="line">99 9 8 7 6 5 3 2 1 0 5 4 3 2 1 </div><div class="line">====</div></pre></td></tr></table></figure></p>
<p>输出很直白，这里不再赘述。需要注意的一点是，链表中剩下1到5的情况下，再次插入0到9使得链表中出现了重复的元素，所以当我们将4修改成99的时候，列表中出现的第一个4被删除了，然后在首位置插入了99，所以列表中还有另外一个4。很多时候，我们不希望列表中出现重复的元素，我们可以对插入的方法进行一些修改来达成这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void add(E e) &#123;</div><div class="line">    if (!search(e)) &#123;</div><div class="line">        if (root == null) &#123;</div><div class="line">            root = new Node(e, null);</div><div class="line">        &#125; else &#123;</div><div class="line">            root = new Node(e, root);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改很直白，只有search返回false也就是当前链表中没有该元素，我们才会插入。再次运行同样的测试，输出如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">====</div><div class="line">9 8 7 6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">5 in the list is true</div><div class="line">10 in the list is false</div><div class="line">remove first, it is 9</div><div class="line">remove first, it is 8</div><div class="line">remove first, it is 7</div><div class="line">====</div><div class="line">6 5 4 3 2 1 0 </div><div class="line">====</div><div class="line">remove 11 is false</div><div class="line">remove 6 is true</div><div class="line">remove 0 is true</div><div class="line">====</div><div class="line">5 4 3 2 1 </div><div class="line">====</div><div class="line">====</div><div class="line">9 8 7 6 0 5 4 3 2 1 </div><div class="line">====</div><div class="line">Modify number 4 to 99 is true</div><div class="line">Modify number 40 to 98 is false</div><div class="line">====</div><div class="line">99 9 8 7 6 0 5 3 2 1 </div><div class="line">====</div></pre></td></tr></table></figure></p>
<p>可以看到，当链表中还有1到5的时候，只有0,6到9可以被插入该链表。当4被修改为99时，链表中的4就没有。另外如果你对于为什么<code>System.out.println(l)</code>可以打印出链表感兴趣，就请关注我的下一篇博文吧 :-)</p>
<p>##Conclusion<br>在这一篇文章中，我们从头实现了一个链表所包括的常见方法，并对这些方法进行了简单的测试。在前文中，我们提到过链表这一数据结构对于搜索的支持并不好，在以后的文章中我将会用其他结构和链表进行对比，来加深读者对于这些结构的理解。<br><br>下面是这篇文章实现的代码，需要的读者可以尝试运行。<br><br>
<button onclick="window.open('LinkedList.java')">点我下载 LinkedList.java</button>
<br><br>谢谢阅读。<br><br>　/) /)<br>ฅ(• - •)ฅ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LinkedList&quot;&gt;&lt;a href=&quot;#LinkedList&quot; class=&quot;headerlink&quot; title=&quot;LinkedList&quot;&gt;&lt;/a&gt;LinkedList&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; cla
    
    </summary>
    
    
      <category term="data structure" scheme="https://alex-mengx.github.io/tags/data-structure/"/>
    
  </entry>
  
</feed>
